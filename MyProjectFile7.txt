import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import ExecutionSummary from './ExecutionSummary';
import TrendAnalysis from './TrendAnalysis';
import TestPerformanceChart from './TestPerformanceChart';
import TestReliabilityMatrix from './TestReliabilityMatrix';
import FailureAnalysis from './FailureAnalysis';
import DateRangeFilter from '../shared/filters/DateRangeFilter';
import ProjectSelector from '../shared/filters/ProjectSelector';
import { format } from 'date-fns';
import './ReportingDashboard.css';

// Types
interface DashboardSummary {
  totalExecutions: number;
  passedTests: number;
  failedTests: number;
  passRate: number;
  averageDuration: number;
  activeExecutions: any[];
}

interface TrendData {
  datePoints: any[];
  metrics: {
    [key: string]: number[];
  };
}

interface Project {
  id: string;
  name: string;
}

const ReportingDashboard: React.FC = () => {
  const { projectId } = useParams<{ projectId: string }>();
  const navigate = useNavigate();
  
  const [summary, setSummary] = useState<DashboardSummary | null>(null);
  const [trends, setTrends] = useState<TrendData | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [projects, setProjects] = useState<Project[]>([]);
  const [selectedProject, setSelectedProject] = useState<string>(projectId || '');
  
  const [dateRange, setDateRange] = useState({
    startDate: format(new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), 'yyyy-MM-dd'),
    endDate: format(new Date(), 'yyyy-MM-dd')
  });
  
  // Fetch projects
  useEffect(() => {
    const fetchProjects = async () => {
      try {
        const response = await fetch('/api/projects');
        if (!response.ok) {
          throw new Error('Failed to fetch projects');
        }
        
        const data = await response.json();
        setProjects(data);
        
        // If no project is selected and we have projects, select the first one
        if (!selectedProject && data.length > 0) {
          setSelectedProject(data[0].id);
          navigate(`/reporting/${data[0].id}`);
        }
      } catch (err) {
        setError('Failed to load projects. Please refresh the page.');
        console.error(err);
      }
    };
    
    fetchProjects();
  }, []);
  
  // Fetch dashboard data when project or date range changes
  useEffect(() => {
    if (!selectedProject) return;
    
    const fetchDashboardData = async () => {
      setLoading(true);
      try {
        // Fetch summary data
        const summaryResponse = await fetch(`/api/reporting/dashboard/${selectedProject}`);
        if (!summaryResponse.ok) {
          throw new Error('Failed to fetch summary data');
        }
        
        const summaryData = await summaryResponse.json();
        setSummary(summaryData);
        
        // Fetch trend data
        const trendResponse = await fetch(
          `/api/reporting/trends/${selectedProject}?startDate=${dateRange.startDate}&endDate=${dateRange.endDate}`
        );
        
        if (!trendResponse.ok) {
          throw new Error('Failed to fetch trend data');
        }
        
        const trendData = await trendResponse.json();
        setTrends(trendData);
        
        setError(null);
      } catch (err) {
        setError('Failed to load reporting data. Please refresh the page.');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchDashboardData();
  }, [selectedProject, dateRange]);
  
  // Handle project change
  const handleProjectChange = (projectId: string) => {
    setSelectedProject(projectId);
    navigate(`/reporting/${projectId}`);
  };
  
  // Handle date range change
  const handleDateRangeChange = (startDate: string, endDate: string) => {
    setDateRange({ startDate, endDate });
  };
  
  if (loading && !summary) {
    return <div className="loading">Loading dashboard data...</div>;
  }
  
  if (error) {
    return <div className="error">{error}</div>;
  }
  
  return (
    <div className="reporting-dashboard">
      <div className="dashboard-header">
        <h1>Test Reporting Dashboard</h1>
        
        <div className="dashboard-filters">
          <ProjectSelector 
            projects={projects} 
            selectedProject={selectedProject} 
            onProjectChange={handleProjectChange} 
          />
          
          <DateRangeFilter 
            startDate={dateRange.startDate} 
            endDate={dateRange.endDate} 
            onDateRangeChange={handleDateRangeChange} 
          />
        </div>
      </div>
      
      {summary && (
        <>
          <div className="dashboard-summary">
            <ExecutionSummary summary={summary} />
          </div>
          
          <div className="dashboard-trends">
            <h2>Test Execution Trends</h2>
            {trends ? (
              <TrendAnalysis data={trends} dateRange={dateRange} />
            ) : (
              <div className="loading">Loading trend data...</div>
            )}
          </div>
          
          <div className="dashboard-reliability">
            <h2>Test Reliability Analysis</h2>
            <TestReliabilityMatrix 
              projectId={selectedProject}
              startDate={dateRange.startDate}
              endDate={dateRange.endDate} 
            />
          </div>
          
          <div className="dashboard-performance">
            <h2>Test Performance Analysis</h2>
            <TestPerformanceChart 
              projectId={selectedProject}
              startDate={dateRange.startDate}
              endDate={dateRange.endDate} 
            />
          </div>
          
          <div className="dashboard-failures">
            <h2>Failure Analysis</h2>
            <FailureAnalysis 
              projectId={selectedProject}
              startDate={dateRange.startDate}
              endDate={dateRange.endDate} 
            />
          </div>
        </>
      )}
    </div>
  );
};

export default ReportingDashboard;




import React from 'react';
import './ExecutionSummary.css';

interface DashboardSummary {
  totalExecutions: number;
  passedTests: number;
  failedTests: number;
  passRate: number;
  averageDuration: number;
  activeExecutions: any[];
}

interface ExecutionSummaryProps {
  summary: DashboardSummary;
}

const ExecutionSummary: React.FC<ExecutionSummaryProps> = ({ summary }) => {
  const {
    totalExecutions,
    passedTests,
    failedTests,
    passRate,
    averageDuration,
    activeExecutions
  } = summary;

  // Format average duration
  const formatDuration = (duration: number): string => {
    if (duration < 1000) {
      return `${duration}ms`;
    } else if (duration < 60000) {
      return `${(duration / 1000).toFixed(1)}s`;
    } else {
      const minutes = Math.floor(duration / 60000);
      const seconds = Math.floor((duration % 60000) / 1000);
      return `${minutes}m ${seconds}s`;
    }
  };

  // Calculate total tests
  const totalTests = passedTests + failedTests;

  // Determine the status color based on pass rate
  const getStatusColor = (rate: number): string => {
    if (rate >= 90) return 'success';
    if (rate >= 75) return 'warning';
    return 'danger';
  };

  return (
    <div className="execution-summary">
      <div className="summary-card executions">
        <h3>Executions</h3>
        <div className="metric">
          <span className="metric-value">{totalExecutions}</span>
          <span className="metric-label">Total</span>
        </div>
        <div className="metric">
          <span className="metric-value">{activeExecutions.length}</span>
          <span className="metric-label">Active</span>
        </div>
      </div>

      <div className="summary-card tests">
        <h3>Test Results</h3>
        <div className="metric">
          <span className="metric-value">{totalTests}</span>
          <span className="metric-label">Total Tests</span>
        </div>
        <div className="metric success">
          <span className="metric-value">{passedTests}</span>
          <span className="metric-label">Passed</span>
        </div>
        <div className="metric danger">
          <span className="metric-value">{failedTests}</span>
          <span className="metric-label">Failed</span>
        </div>
      </div>

      <div className="summary-card performance">
        <h3>Performance</h3>
        <div className="metric">
          <span className="metric-value">{formatDuration(averageDuration)}</span>
          <span className="metric-label">Avg. Duration</span>
        </div>
      </div>

      {activeExecutions.length > 0 && (
        <div className="summary-card active-executions">
          <h3>Active Executions</h3>
          <ul className="active-list">
            {activeExecutions.map(execution => (
              <li key={execution.id} className="active-item">
                <span className="execution-name">{execution.name || execution.id}</span>
                <span className="execution-env">{execution.environment}</span>
                <span className="execution-browser">{execution.browser}</span>
                <span className="execution-progress">{execution.progress || 0}%</span>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};

export default ExecutionSummary;

import React, { useState } from 'react';
import LineChart from '../shared/charts/LineChart';
import './TrendAnalysis.css';

interface DatePoint {
  date: string;
  executionCount: number;
  passCount: number;
  failCount: number;
  errorCount: number;
  averageDuration: number;
  passRate: number;
}

interface TrendData {
  datePoints: DatePoint[];
  metrics: {
    [key: string]: number[];
  };
}

interface TrendAnalysisProps {
  data: TrendData;
  dateRange: {
    startDate: string;
    endDate: string;
  };
}

type MetricType = 'passRate' | 'executionCount' | 'passCount' | 'failCount' | 'duration';

const TrendAnalysis: React.FC<TrendAnalysisProps> = ({ data, dateRange }) => {
  const [selectedMetric, setSelectedMetric] = useState<MetricType>('passRate');

  // Convert data for chart component
  const prepareChartData = (metric: MetricType) => {
    const chartData = data.datePoints.map((point, index) => {
      return {
        x: index, // Use index for x-axis positioning
        y: metric === 'duration' ? point.averageDuration : 
           metric === 'passRate' ? point.passRate :
           metric === 'executionCount' ? point.executionCount :
           metric === 'passCount' ? point.passCount :
           point.failCount
      };
    });

    return chartData;
  };

  // Get dates for x-axis labels
  const getDateLabels = () => {
    return data.datePoints.map(point => {
      const date = new Date(point.date);
      return `${date.getMonth() + 1}/${date.getDate()}`;
    });
  };

  // Get metric color
  const getMetricColor = (metric: MetricType): string => {
    switch (metric) {
      case 'passRate':
        return '#28a745';
      case 'executionCount':
        return '#007bff';
      case 'passCount':
        return '#20c997';
      case 'failCount':
        return '#dc3545';
      case 'duration':
        return '#6f42c1';
      default:
        return '#007bff';
    }
  };

  // Get metric label
  const getMetricLabel = (metric: MetricType): string => {
    switch (metric) {
      case 'passRate':
        return 'Pass Rate (%)';
      case 'executionCount':
        return 'Execution Count';
      case 'passCount':
        return 'Passed Tests';
      case 'failCount':
        return 'Failed Tests';
      case 'duration':
        return 'Avg. Duration (ms)';
      default:
        return '';
    }
  };

  // Handle metric change
  const handleMetricChange = (metric: MetricType) => {
    setSelectedMetric(metric);
  };

  // Format the date range for display
  const formatDateRange = () => {
    const start = new Date(dateRange.startDate);
    const end = new Date(dateRange.endDate);
    return `${start.toLocaleDateString()} - ${end.toLocaleDateString()}`;
  };

  if (!data || !data.datePoints || data.datePoints.length === 0) {
    return <div className="no-data">No trend data available for the selected period.</div>;
  }

  const chartData = prepareChartData(selectedMetric);
  const dateLabels = getDateLabels();

  return (
    <div className="trend-analysis">
      <div className="chart-controls">
        <div className="date-range-display">
          <span>Period: {formatDateRange()}</span>
        </div>
        
        <div className="metric-selector">
          <button
            className={`metric-button ${selectedMetric === 'passRate' ? 'active' : ''}`}
            onClick={() => handleMetricChange('passRate')}
          >
            Pass Rate
          </button>
          <button
            className={`metric-button ${selectedMetric === 'executionCount' ? 'active' : ''}`}
            onClick={() => handleMetricChange('executionCount')}
          >
            Executions
          </button>
          <button
            className={`metric-button ${selectedMetric === 'passCount' ? 'active' : ''}`}
            onClick={() => handleMetricChange('passCount')}
          >
            Passed
          </button>
          <button
            className={`metric-button ${selectedMetric === 'failCount' ? 'active' : ''}`}
            onClick={() => handleMetricChange('failCount')}
          >
            Failed
          </button>
          <button
            className={`metric-button ${selectedMetric === 'duration' ? 'active' : ''}`}
            onClick={() => handleMetricChange('duration')}
          >
            Duration
          </button>
        </div>
      </div>

      <div className="chart-container">
        <LineChart 
          data={chartData}
          width={800}
          height={400}
          color={getMetricColor(selectedMetric)}
          xAxis="Date"
          yAxis={getMetricLabel(selectedMetric)}
          labels={dateLabels}
        />
      </div>

      <div className="trend-summary">
        <div className="trend-metric">
          <span className="trend-label">Average Pass Rate</span>
          <span className="trend-value">{(data.datePoints.reduce((acc, point) => acc + point.passRate, 0) / data.datePoints.length).toFixed(1)}%</span>
        </div>
        <div className="trend-metric">
          <span className="trend-label">Total Executions</span>
          <span className="trend-value">{data.datePoints.reduce((acc, point) => acc + point.executionCount, 0)}</span>
        </div>
        <div className="trend-metric">
          <span className="trend-label">Total Passed Tests</span>
          <span className="trend-value">{data.datePoints.reduce((acc, point) => acc + point.passCount, 0)}</span>
        </div>
        <div className="trend-metric">
          <span className="trend-label">Total Failed Tests</span>
          <span className="trend-value">{data.datePoints.reduce((acc, point) => acc + point.failCount, 0)}</span>
        </div>
      </div>
    </div>
  );
};

export default TrendAnalysis;

Frontend Components
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ reporting/
â”‚   â”‚   â”œâ”€â”€ ReportingDashboard.tsx         # Main dashboard component
â”‚   â”‚   â”œâ”€â”€ ExecutionSummary.tsx           # Test execution summary
â”‚   â”‚   â”œâ”€â”€ TrendAnalysis.tsx              # Historical trend visualization
â”‚   â”‚   â”œâ”€â”€ TestPerformanceChart.tsx       # Performance metrics charts
â”‚   â”‚   â”œâ”€â”€ TestReliabilityMatrix.tsx      # Test reliability heatmap
â”‚   â”‚   â”œâ”€â”€ FailureAnalysis.tsx            # Failure categorization and analysis
â”‚   â”‚   â”œâ”€â”€ ExecutionDetails.tsx           # Detailed execution view
â”‚   â”‚   â”œâ”€â”€ ExecutionComparison.tsx        # Execution comparison view
â”‚   â”‚   â”œâ”€â”€ TestCoverageMap.tsx            # Coverage visualization
â”‚   â”‚   â”œâ”€â”€ ReportExporter.tsx             # Report export functionality
â”‚   â”‚   â””â”€â”€ ReportScheduler.tsx            # Report scheduling interface
â”‚   â””â”€â”€ shared/
â”‚       â”œâ”€â”€ charts/
â”‚       â”‚   â”œâ”€â”€ LineChart.tsx              # Reusable line chart component
â”‚       â”‚   â”œâ”€â”€ BarChart.tsx               # Reusable bar chart component
â”‚       â”‚   â”œâ”€â”€ HeatMap.tsx                # Reusable heatmap component
â”‚       â”‚   â”œâ”€â”€ SunburstChart.tsx          # Hierarchical visualization component
â”‚       â”‚   â””â”€â”€ TimelineChart.tsx          # Timeline visualization component
â”‚       â””â”€â”€ filters/
â”‚           â”œâ”€â”€ DateRangeFilter.tsx        # Date range selection
â”‚           â”œâ”€â”€ TestStatusFilter.tsx       # Filter by test status
â”‚           â””â”€â”€ ProjectFilter.tsx          # Filter by project/feature
Backend Components
com.automation.api/
â”œâ”€â”€ controllers/
â”‚   â””â”€â”€ reporting/
â”‚       â”œâ”€â”€ ReportingController.java       # Main reporting REST API
â”‚       â”œâ”€â”€ TrendController.java           # Trend analysis endpoints
â”‚       â”œâ”€â”€ PerformanceController.java     # Performance metrics endpoints
â”‚       â”œâ”€â”€ ReliabilityController.java     # Reliability analysis endpoints
â”‚       â”œâ”€â”€ ExportController.java          # Report export endpoints
â”‚       â””â”€â”€ ScheduleController.java        # Report scheduling endpoints
â”œâ”€â”€ models/
â”‚   â””â”€â”€ reporting/
â”‚       â”œâ”€â”€ DashboardSummary.java          # Dashboard summary data
â”‚       â”œâ”€â”€ TrendData.java                 # Trend analysis data
â”‚       â”œâ”€â”€ PerformanceMetrics.java        # Performance metrics
â”‚       â”œâ”€â”€ ReliabilityMatrix.java         # Reliability data
â”‚       â”œâ”€â”€ FailureCategory.java           # Failure categorization
â”‚       â”œâ”€â”€ TestExecutionComparison.java   # Execution comparison data
â”‚       â”œâ”€â”€ ReportSchedule.java            # Report scheduling configuration
â”‚       â””â”€â”€ ExportConfig.java              # Export configuration
â””â”€â”€ services/
    â””â”€â”€ reporting/
        â”œâ”€â”€ ReportingService.java          # Core reporting service
        â”œâ”€â”€ TrendAnalysisService.java      # Trend analysis service
        â”œâ”€â”€ PerformanceService.java        # Performance metrics service
        â”œâ”€â”€ ReliabilityService.java        # Reliability analysis service
        â”œâ”€â”€ FailureAnalysisService.java    # Failure categorization service
        â”œâ”€â”€ ExportService.java             # Report export service
        â”œâ”€â”€ ScheduleService.java           # Report scheduling service
        â””â”€â”€ AnomalyDetectionService.java   # Anomaly detection service


import React, { useState, useEffect } from 'react';
import BarChart from '../shared/charts/BarChart';
import LineChart from '../shared/charts/LineChart';
import './TestPerformanceChart.css';

interface PerformanceAnomaly {
  executionId: string;
  executionDate: string;
  duration: number;
  expectedDuration: number;
  deviationPercentage: number;
  possibleCause: string;
}

interface ExecutionTime {
  executionId: string;
  executionDate: string;
  duration: number;
  environment: string;
  browser: string;
}

interface PerformanceMetrics {
  testCaseId: string;
  testCaseName: string;
  executionTimes: ExecutionTime[];
  averageDuration: number;
  minDuration: number;
  maxDuration: number;
  standardDeviation: number;
  anomalies: PerformanceAnomaly[];
}

interface TestPerformanceChartProps {
  projectId: string;
  startDate: string;
  endDate: string;
}

const TestPerformanceChart: React.FC<TestPerformanceChartProps> = ({ 
  projectId, 
  startDate, 
  endDate 
}) => {
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [testCases, setTestCases] = useState<Array<{ id: string, name: string }>>([]);
  const [selectedTestCase, setSelectedTestCase] = useState<string>('');
  const [performanceData, setPerformanceData] = useState<PerformanceMetrics | null>(null);
  const [chartType, setChartType] = useState<'bar' | 'line'>('line');

  // Fetch test cases
  useEffect(() => {
    if (!projectId) return;

    const fetchTestCases = async () => {
      try {
        const response = await fetch(`/api/projects/${projectId}/testcases`);
        if (!response.ok) {
          throw new Error('Failed to fetch test cases');
        }
        
        const data = await response.json();
        setTestCases(data);
        
        // Select first test case by default
        if (data.length > 0 && !selectedTestCase) {
          setSelectedTestCase(data[0].id);
        }
      } catch (err) {
        setError('Failed to load test cases');
        console.error(err);
      }
    };
    
    fetchTestCases();
  }, [projectId]);

  // Fetch performance data for selected test case
  useEffect(() => {
    if (!projectId || !selectedTestCase) return;

    const fetchPerformanceData = async () => {
      setLoading(true);
      try {
        const response = await fetch(
          `/api/reporting/performance/${projectId}/${selectedTestCase}?startDate=${startDate}&endDate=${endDate}`
        );
        
        if (!response.ok) {
          throw new Error('Failed to fetch performance data');
        }
        
        const data = await response.json();
        setPerformanceData(data);
        setError(null);
      } catch (err) {
        setError('Failed to load performance data');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchPerformanceData();
  }, [projectId, selectedTestCase, startDate, endDate]);

  // Handle test case change
  const handleTestCaseChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedTestCase(e.target.value);
  };

  // Toggle chart type
  const toggleChartType = () => {
    setChartType(chartType === 'bar' ? 'line' : 'bar');
  };

  // Format date for display
  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return `${date.getMonth() + 1}/${date.getDate()}`;
  };

  // Prepare chart data
  const prepareChartData = () => {
    if (!performanceData || !performanceData.executionTimes) {
      return [];
    }

    return performanceData.executionTimes.map((execution, index) => ({
      x: index,
      y: execution.duration,
      label: formatDate(execution.executionDate)
    }));
  };

  if (loading && !performanceData) {
    return <div className="loading">Loading performance data...</div>;
  }

  if (error) {
    return <div className="error">{error}</div>;
  }

  if (!testCases || testCases.length === 0) {
    return <div className="no-data">No test cases available for performance analysis.</div>;
  }

  const chartData = prepareChartData();

  return (
    <div className="test-performance-chart">
      <div className="performance-controls">
        <div className="test-case-selector">
          <label htmlFor="test-case-select">Select Test Case:</label>
          <select 
            id="test-case-select" 
            value={selectedTestCase} 
            onChange={handleTestCaseChange}
          >
            {testCases.map(testCase => (
              <option key={testCase.id} value={testCase.id}>{testCase.name}</option>
            ))}
          </select>
        </div>
        
        <div className="chart-type-toggle">
          <button 
            className={`toggle-button ${chartType === 'line' ? 'active' : ''}`} 
            onClick={toggleChartType}
          >
            {chartType === 'line' ? 'Line Chart' : 'Bar Chart'}
          </button>
        </div>
      </div>

      {performanceData && (
        <>
          <div className="performance-summary">
            <div className="metric">
              <span className="metric-label">Average Duration</span>
              <span className="metric-value">{performanceData.averageDuration}ms</span>
            </div>
            <div className="metric">
              <span className="metric-label">Min Duration</span>
              <span className="metric-value">{performanceData.minDuration}ms</span>
            </div>
            <div className="metric">
              <span className="metric-label">Max Duration</span>
              <span className="metric-value">{performanceData.maxDuration}ms</span>
            </div>
            <div className="metric">
              <span className="metric-label">Standard Deviation</span>
              <span className="metric-value">{performanceData.standardDeviation.toFixed(2)}</span>
            </div>
          </div>

          <div className="chart-container">
            {chartType === 'line' ? (
              <LineChart 
                data={chartData}
                width={800}
                height={400}
                color="#6f42c1"
                xAxis="Execution"
                yAxis="Duration (ms)"
                labels={chartData.map(item => item.label)}
              />
            ) : (
              <BarChart 
                data={chartData}
                width={800}
                height={400}
                color="#6f42c1"
                xAxis="Execution"
                yAxis="Duration (ms)"
                labels={chartData.map(item => item.label)}
              />
            )}
          </div>

          {performanceData.anomalies && performanceData.anomalies.length > 0 && (
            <div className="anomalies-section">
              <h3>Performance Anomalies</h3>
              <table className="anomalies-table">
                <thead>
                  <tr>
                    <th>Date</th>
                    <th>Duration</th>
                    <th>Expected</th>
                    <th>Deviation</th>
                    <th>Possible Cause</th>
                  </tr>
                </thead>
                <tbody>
                  {performanceData.anomalies.map(anomaly => (
                    <tr key={anomaly.executionId}>
                      <td>{formatDate(anomaly.executionDate)}</td>
                      <td>{anomaly.duration}ms</td>
                      <td>{anomaly.expectedDuration}ms</td>
                      <td className={anomaly.deviationPercentage > 0 ? 'negative' : 'positive'}>
                        {anomaly.deviationPercentage > 0 ? '+' : ''}{anomaly.deviationPercentage.toFixed(1)}%
                      </td>
                      <td>{anomaly.possibleCause}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </>
      )}
    </div>
  );
};

export default TestPerformanceChart;


import React, { useState, useEffect } from 'react';
import HeatMap from '../shared/charts/HeatMap';
import './TestReliabilityMatrix.css';

interface ReliabilityMatrix {
  testCaseIds: string[];
  testCaseNames: string[];
  reliabilityScores: number[][];
  testCaseFailureCount: { [key: string]: number };
  testCaseReliabilityPercentage: { [key: string]: number };
}

interface TestReliabilityMatrixProps {
  projectId: string;
  startDate: string;
  endDate: string;
}

const TestReliabilityMatrix: React.FC<TestReliabilityMatrixProps> = ({
  projectId,
  startDate,
  endDate
}) => {
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [reliabilityData, setReliabilityData] = useState<ReliabilityMatrix | null>(null);
  const [sortBy, setSortBy] = useState<'name' | 'reliability'>('reliability');

  // Fetch reliability data
  useEffect(() => {
    if (!projectId) return;

    const fetchReliabilityData = async () => {
      setLoading(true);
      try {
        const response = await fetch(
          `/api/reporting/reliability/${projectId}?startDate=${startDate}&endDate=${endDate}`
        );
        
        if (!response.ok) {
          throw new Error('Failed to fetch reliability data');
        }
        
        const data = await response.json();
        setReliabilityData(data);
        setError(null);
      } catch (err) {
        setError('Failed to load reliability data');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchReliabilityData();
  }, [projectId, startDate, endDate]);

  // Handle sort by change
  const handleSortByChange = (type: 'name' | 'reliability') => {
    setSortBy(type);
  };

  // Sort test cases based on the selected sort type
  const getSortedTestCases = () => {
    if (!reliabilityData) return [];

    const { testCaseIds, testCaseNames, testCaseReliabilityPercentage } = reliabilityData;
    
    // Create array of test case objects
    const testCases = testCaseIds.map((id, index) => ({
      id,
      name: testCaseNames[index],
      reliability: testCaseReliabilityPercentage[id] || 0
    }));
    
    // Sort based on selected sort type
    if (sortBy === 'name') {
      return testCases.sort((a, b) => a.name.localeCompare(b.name));
    } else {
      return testCases.sort((a, b) => b.reliability - a.reliability);
    }
  };

  // Get reliability status class
  const getReliabilityStatusClass = (percentage: number): string => {
    if (percentage >= 90) return 'high-reliability';
    if (percentage >= 75) return 'medium-reliability';
    return 'low-reliability';
  };

  if (loading && !reliabilityData) {
    return <div className="loading">Loading reliability data...</div>;
  }

  if (error) {
    return <div className="error">{error}</div>;
  }

  if (!reliabilityData || reliabilityData.testCaseIds.length === 0) {
    return <div className="no-data">No test cases available for reliability analysis.</div>;
  }

  const sortedTestCases = getSortedTestCases();

  return (
    <div className="test-reliability-matrix">
      <div className="reliability-controls">
        <div className="sort-controls">
          <span>Sort by:</span>
          <button
            className={`sort-button ${sortBy === 'name' ? 'active' : ''}`}
            onClick={() => handleSortByChange('name')}
          >
            Test Name
          </button>
          <button
            className={`sort-button ${sortBy === 'reliability' ? 'active' : ''}`}
            onClick={() => handleSortByChange('reliability')}
          >
            Reliability
          </button>
        </div>
      </div>

      <div className="reliability-table-container">
        <table className="reliability-table">
          <thead>
            <tr>
              <th>Test Case</th>
              <th>Reliability</th>
              <th>Failures</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            {sortedTestCases.map(testCase => {
              const reliability = reliabilityData.testCaseReliabilityPercentage[testCase.id] || 0;
              const failures = reliabilityData.testCaseFailureCount[testCase.id] || 0;
              const statusClass = getReliabilityStatusClass(reliability);
              
              return (
                <tr key={testCase.id}>
                  <td className="test-name">{testCase.name}</td>
                  <td className="reliability-score">{reliability.toFixed(1)}%</td>
                  <td className="failure-count">{failures}</td>
                  <td className="reliability-status">
                    <span className={`status-indicator ${statusClass}`}></span>
                    {reliability >= 90 ? 'Stable' : reliability >= 75 ? 'Moderate' : 'Unstable'}
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>

      <div className="reliability-summary">
        <div className="summary-metric">
          <span className="metric-value">
            {sortedTestCases.filter(tc => reliabilityData.testCaseReliabilityPercentage[tc.id] >= 90).length}
          </span>
          <span className="metric-label">Stable Tests</span>
        </div>
        <div className="summary-metric">
          <span className="metric-value">
            {sortedTestCases.filter(tc => {
              const reliability = reliabilityData.testCaseReliabilityPercentage[tc.id] || 0;
              return reliability >= 75 && reliability < 90;
            }).length}
          </span>
          <span className="metric-label">Moderate Tests</span>
        </div>
        <div className="summary-metric">
          <span className="metric-value">
            {sortedTestCases.filter(tc => {
              const reliability = reliabilityData.testCaseReliabilityPercentage[tc.id] || 0;
              return reliability < 75;
            }).length}
          </span>
          <span className="metric-label">Unstable Tests</span>
        </div>
        <div className="summary-metric">
          <span className="metric-value">
            {(sortedTestCases.reduce((acc, tc) => {
              return acc + (reliabilityData.testCaseReliabilityPercentage[tc.id] || 0);
            }, 0) / sortedTestCases.length).toFixed(1)}%
          </span>
          <span className="metric-label">Avg. Reliability</span>
        </div>
      </div>

      {sortedTestCases.length > 0 && reliabilityData.testCaseReliabilityPercentage && (
        <div className="reliability-recommendations">
          <h3>Recommendations</h3>
          <ul className="recommendations-list">
            {sortedTestCases
              .filter(tc => (reliabilityData.testCaseReliabilityPercentage[tc.id] || 0) < 75)
              .slice(0, 3)
              .map(tc => (
                <li key={tc.id} className="recommendation-item">
                  <span className="test-name">{tc.name}</span>: Review and stabilize this test to improve overall reliability.
                </li>
              ))}
            
            {sortedTestCases.length > 0 && sortedTestCases.filter(tc => (reliabilityData.testCaseReliabilityPercentage[tc.id] || 0) < 75).length === 0 && (
              <li className="recommendation-item">
                All tests have good reliability scores. Continue monitoring to maintain quality.
              </li>
            )}
          </ul>
        </div>
      )}
    </div>
  );
};

export default TestReliabilityMatrix;


import React, { useState, useEffect } from 'react';
import './FailureAnalysis.css';

interface TestCaseFailure {
  id: string;
  type: string;
  message: string;
  location: string;
  stackTrace: string;
  screenshot: string;
  recurrent: boolean;
  suggestedActions: string[];
}

interface FailureCategory {
  name: string;
  failures: TestCaseFailure[];
  errorPatterns: { [key: string]: number };
  recommendations: string[];
}

interface FailureAnalysisProps {
  projectId: string;
  startDate: string;
  endDate: string;
}

const FailureAnalysis: React.FC<FailureAnalysisProps> = ({ 
  projectId, 
  startDate, 
  endDate 
}) => {
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [failureData, setFailureData] = useState<{ [key: string]: FailureCategory } | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<string>('');
  const [selectedFailure, setSelectedFailure] = useState<TestCaseFailure | null>(null);

  // Fetch failure data
  useEffect(() => {
    if (!projectId) return;

    const fetchFailureData = async () => {
      setLoading(true);
      try {
        const response = await fetch(
          `/api/reporting/failures/${projectId}?startDate=${startDate}&endDate=${endDate}`
        );
        
        if (!response.ok) {
          throw new Error('Failed to fetch failure data');
        }
        
        const data = await response.json();
        setFailureData(data);
        
        // Select first category by default
        if (Object.keys(data).length > 0 && !selectedCategory) {
          setSelectedCategory(Object.keys(data)[0]);
        }
        
        setError(null);
      } catch (err) {
        setError('Failed to load failure data');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchFailureData();
  }, [projectId, startDate, endDate]);

  // Handle category change
  const handleCategoryChange = (category: string) => {
    setSelectedCategory(category);
    setSelectedFailure(null); // Reset selected failure when changing category
  };

  // Handle failure selection
  const handleFailureSelect = (failure: TestCaseFailure) => {
    setSelectedFailure(failure);
  };

  // Close failure details
  const closeFailureDetails = () => {
    setSelectedFailure(null);
  };

  // Get category color
  const getCategoryColor = (category: string): string => {
    switch (category) {
      case 'selector':
        return '#007bff';
      case 'timeout':
        return '#fd7e14';
      case 'assertion':
        return '#6f42c1';
      case 'javascript':
        return '#20c997';
      case 'network':
        return '#17a2b8';
      default:
        return '#6c757d';
    }
  };

  // Get category icon
  const getCategoryIcon = (category: string): string => {
    switch (category) {
      case 'selector':
        return 'ğŸ”';
      case 'timeout':
        return 'â±ï¸';
      case 'assertion':
        return 'âŒ';
      case 'javascript':
        return 'ğŸ“œ';
      case 'network':
        return 'ğŸŒ';
      default:
        return 'âš ï¸';
    }
  };

  if (loading && !failureData) {
    return <div className="loading">Loading failure analysis data...</div>;
  }

  if (error) {
    return <div className="error">{error}</div>;
  }

  if (!failureData || Object.keys(failureData).length === 0) {
    return <div className="no-data">No failure data available for analysis in the selected period.</div>;
  }

  const categories = Object.keys(failureData);
  const currentCategory = selectedCategory ? failureData[selectedCategory] : null;

  return (
    <div className="failure-analysis">
      <div className="category-tabs">
        {categories.map(category => (
          <button
            key={category}
            className={`category-tab ${selectedCategory === category ? 'active' : ''}`}
            style={{ borderColor: getCategoryColor(category) }}
            onClick={() => handleCategoryChange(category)}
          >
            <span className="category-icon">{getCategoryIcon(category)}</span>
            <span className="category-name">{failureData[category].name}</span>
            <span className="failure-count">{failureData[category].failures.length}</span>
          </button>
        ))}
      </div>

      {currentCategory && (
        <div className="category-content">
          <div className="category-header">
            <h3>{currentCategory.name}</h3>
            <div className="category-summary">
              <span className="failure-total">{currentCategory.failures.length} failures</span>
            </div>
          </div>

          <div className="category-details">
            <div className="error-patterns">
              <h4>Common Error Patterns</h4>
              <ul className="pattern-list">
                {Object.entries(currentCategory.errorPatterns).map(([pattern, count]) => (
                  <li key={pattern} className="pattern-item">
                    <span className="pattern-count">{count}</span>
                    <span className="pattern-text">{pattern}</span>
                  </li>
                ))}
              </ul>
            </div>

            <div className="recommendations">
              <h4>Recommendations</h4>
              <ul className="recommendation-list">
                {currentCategory.recommendations.map((recommendation, index) => (
                  <li key={index} className="recommendation-item">{recommendation}</li>
                ))}
              </ul>
            </div>
          </div>

          <div className="failures-list-container">
            <h4>Failure Details</h4>
            <table className="failures-table">
              <thead>
                <tr>
                  <th>Error Type</th>
                  <th>Message</th>
                  <th>Location</th>
                  <th>Recurrent</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                {currentCategory.failures.slice(0, 10).map(failure => (
                  <tr 
                    key={failure.id} 
                    className={selectedFailure?.id === failure.id ? 'selected' : ''}
                  >
                    <td>{failure.type}</td>
                    <td className="message-cell">{failure.message}</td>
                    <td>{failure.location}</td>
                    <td>{failure.recurrent ? 'Yes' : 'No'}</td>
                    <td>
                      <button 
                        className="view-details-button"
                        onClick={() => handleFailureSelect(failure)}
                      >
                        View Details
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>

            {currentCategory.failures.length > 10 && (
              <div className="more-failures">
                {currentCategory.failures.length - 10} more failures not shown
              </div>
            )}
          </div>

          {selectedFailure && (
            <div className="failure-details-overlay">
              <div className="failure-details-panel">
                <div className="details-header">
                  <h3>Failure Details</h3>
                  <button className="close-button" onClick={closeFailureDetails}>Ã—</button>
                </div>
                
                <div className="details-content">
                  <div className="details-section">
                    <h4>Error Information</h4>
                    <div className="detail-item">
                      <span className="detail-label">Type:</span>
                      <span className="detail-value">{selectedFailure.type}</span>
                    </div>
                    <div className="detail-item">
                      <span className="detail-label">Message:</span>
                      <span className="detail-value">{selectedFailure.message}</span>
                    </div>
                    <div className="detail-item">
                      <span className="detail-label">Location:</span>
                      <span className="detail-value">{selectedFailure.location}</span>
                    </div>
                    <div className="detail-item">
                      <span className="detail-label">Recurrent:</span>
                      <span className="detail-value">{selectedFailure.recurrent ? 'Yes' : 'No'}</span>
                    </div>
                  </div>
                  
                  {selectedFailure.stackTrace && (
                    <div className="details-section">
                      <h4>Stack Trace</h4>
                      <pre className="stack-trace">{selectedFailure.stackTrace}</pre>
                    </div>
                  )}
                  
                  {selectedFailure.screenshot && (
                    <div className="details-section">
                      <h4>Screenshot</h4>
                      <div className="screenshot-container">
                        <img 
                          src={`/api/screenshots/${selectedFailure.screenshot}`} 
                          alt="Failure Screenshot" 
                          className="failure-screenshot" 
                        />
                      </div>
                    </div>
                  )}
                  
                  {selectedFailure.suggestedActions && selectedFailure.suggestedActions.length > 0 && (
                    <div className="details-section">
                      <h4>Suggested Actions</h4>
                      <ul className="suggested-actions">
                        {selectedFailure.suggestedActions.map((action, index) => (
                          <li key={index}>{action}</li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default FailureAnalysis;


import React, { useEffect, useRef } from 'react';
import './Charts.css';

interface DataPoint {
  x: number;
  y: number;
  label?: string;
}

interface LineChartProps {
  data: DataPoint[];
  width: number;
  height: number;
  color: string;
  xAxis: string;
  yAxis: string;
  labels?: string[];
}

const LineChart: React.FC<LineChartProps> = ({ 
  data, 
  width, 
  height, 
  color, 
  xAxis, 
  yAxis,
  labels 
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  
  useEffect(() => {
    if (!svgRef.current || data.length === 0) return;
    
    // Clear previous content
    const svg = svgRef.current;
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }
    
    // Set margins
    const margin = { top: 20, right: 20, bottom: 60, left: 60 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;
    
    // Find min and max values
    const xValues = data.map(d => d.x);
    const yValues = data.map(d => d.y);
    
    const xMin = Math.min(...xValues);
    const xMax = Math.max(...xValues);
    // Ensure y starts from 0 unless there are negative values
    const yMin = Math.min(0, ...yValues);
    const yMax = Math.max(...yValues) * 1.1; // Add 10% padding on top
    
    // Create scales
    const xScale = (x: number) => margin.left + ((x - xMin) / (Math.max(1, xMax - xMin))) * innerWidth;
    const yScale = (y: number) => margin.top + innerHeight - ((y - yMin) / (Math.max(1, yMax - yMin))) * innerHeight;
    
    // Create group for the chart
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Draw axes
    // X-axis
    const xAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxisLine.setAttribute('x1', `${margin.left}`);
    xAxisLine.setAttribute('y1', `${margin.top + innerHeight}`);
    xAxisLine.setAttribute('x2', `${margin.left + innerWidth}`);
    xAxisLine.setAttribute('y2', `${margin.top + innerHeight}`);
    xAxisLine.setAttribute('stroke', '#333');
    xAxisLine.setAttribute('stroke-width', '1');
    g.appendChild(xAxisLine);
    
    // Y-axis
    const yAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    yAxisLine.setAttribute('x1', `${margin.left}`);
    yAxisLine.setAttribute('y1', `${margin.top}`);
    yAxisLine.setAttribute('x2', `${margin.left}`);
    yAxisLine.setAttribute('y2', `${margin.top + innerHeight}`);
    yAxisLine.setAttribute('stroke', '#333');
    yAxisLine.setAttribute('stroke-width', '1');
    g.appendChild(yAxisLine);
    
    // Draw grid lines (horizontal)
    const gridCount = 5;
    for (let i = 0; i <= gridCount; i++) {
      const yPos = margin.top + (innerHeight / gridCount) * i;
      const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      gridLine.setAttribute('x1', `${margin.left}`);
      gridLine.setAttribute('y1', `${yPos}`);
      gridLine.setAttribute('x2', `${margin.left + innerWidth}`);
      gridLine.setAttribute('y2', `${yPos}`);
      gridLine.setAttribute('stroke', '#e0e0e0');
      gridLine.setAttribute('stroke-width', '1');
      g.appendChild(gridLine);
      
      // Y-axis labels
      const yValue = yMax - (i / gridCount) * (yMax - yMin);
      const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      yLabel.setAttribute('x', `${margin.left - 10}`);
      yLabel.setAttribute('y', `${yPos}`);
      yLabel.setAttribute('text-anchor', 'end');
      yLabel.setAttribute('dominant-baseline', 'middle');
      yLabel.setAttribute('font-size', '12px');
      yLabel.setAttribute('fill', '#666');
      yLabel.textContent = yValue.toLocaleString(undefined, { 
        maximumFractionDigits: yValue > 100 ? 0 : 1 
      });
      g.appendChild(yLabel);
    }
    
    // X-axis labels
    const xLabelInterval = Math.max(1, Math.ceil(data.length / 10)); // Show max 10 labels
    data.forEach((point, i) => {
      if (i % xLabelInterval === 0 || i === data.length - 1) {
        const xPos = xScale(point.x);
        
        // Tick mark
        const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        tick.setAttribute('x1', `${xPos}`);
        tick.setAttribute('y1', `${margin.top + innerHeight}`);
        tick.setAttribute('x2', `${xPos}`);
        tick.setAttribute('y2', `${margin.top + innerHeight + 5}`);
        tick.setAttribute('stroke', '#333');
        tick.setAttribute('stroke-width', '1');
        g.appendChild(tick);
        
        // Label
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', `${xPos}`);
        label.setAttribute('y', `${margin.top + innerHeight + 20}`);
        label.setAttribute('text-anchor', 'middle');
        label.setAttribute('font-size', '12px');
        label.setAttribute('fill', '#666');
        
        // Use custom label if provided, otherwise use x value
        const labelText = labels && labels[i] ? labels[i] : point.x.toString();
        label.textContent = labelText;
        g.appendChild(label);
      }
    });
    
    // Draw area under the line
    const areaPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    let areaPathD = `M ${xScale(data[0].x)} ${yScale(data[0].y)}`;
    
    for (let i = 1; i < data.length; i++) {
      areaPathD += ` L ${xScale(data[i].x)} ${yScale(data[i].y)}`;
    }
    
    // Complete the area path
    areaPathD += ` L ${xScale(data[data.length - 1].x)} ${yScale(yMin)}`;
    areaPathD += ` L ${xScale(data[0].x)} ${yScale(yMin)}`;
    areaPathD += ` Z`;
    
    areaPath.setAttribute('d', areaPathD);
    areaPath.setAttribute('fill', color);
    areaPath.setAttribute('fill-opacity', '0.1');
    g.appendChild(areaPath);
    
    // Draw line
    const linePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    let linePathD = `M ${xScale(data[0].x)} ${yScale(data[0].y)}`;
    
    for (let i = 1; i < data.length; i++) {
      linePathD += ` L ${xScale(data[i].x)} ${yScale(data[i].y)}`;
    }
    
    linePath.setAttribute('d', linePathD);
    linePath.setAttribute('fill', 'none');
    linePath.setAttribute('stroke', color);
    linePath.setAttribute('stroke-width', '2');
    g.appendChild(linePath);
    
    // Draw points
    data.forEach(point => {
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', `${xScale(point.x)}`);
      circle.setAttribute('cy', `${yScale(point.y)}`);
      circle.setAttribute('r', '4');
      circle.setAttribute('fill', 'white');
      circle.setAttribute('stroke', color);
      circle.setAttribute('stroke-width', '2');
      
      // Add hover effect
      circle.setAttribute('class', 'chart-point');
      
      // Add tooltip with data value
      circle.addEventListener('mouseover', (e) => {
        const tooltip = document.createElement('div');
        tooltip.className = 'chart-tooltip';
        tooltip.textContent = point.y.toLocaleString();
        tooltip.style.position = 'absolute';
        tooltip.style.left = `${e.pageX + 10}px`;
        tooltip.style.top = `${e.pageY - 25}px`;
        document.body.appendChild(tooltip);
      });
      
      circle.addEventListener('mouseout', () => {
        const tooltips = document.querySelectorAll('.chart-tooltip');
        tooltips.forEach(t => t.remove());
      });
      
      g.appendChild(circle);
    });
    
    // Add axis labels
    // X-axis label
    const xAxisLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    xAxisLabel.setAttribute('x', `${margin.left + innerWidth / 2}`);
    xAxisLabel.setAttribute('y', `${height - 10}`);
    xAxisLabel.setAttribute('text-anchor', 'middle');
    xAxisLabel.setAttribute('font-size', '14px');
    xAxisLabel.setAttribute('font-weight', 'bold');
    xAxisLabel.setAttribute('fill', '#333');
    xAxisLabel.textContent = xAxis;
    g.appendChild(xAxisLabel);
    
    // Y-axis label
    const yAxisLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yAxisLabel.setAttribute('transform', `rotate(-90, 20, ${margin.top + innerHeight / 2})`);
    yAxisLabel.setAttribute('x', '20');
    yAxisLabel.setAttribute('y', `${margin.top + innerHeight / 2}`);
    yAxisLabel.setAttribute('text-anchor', 'middle');
    yAxisLabel.setAttribute('font-size', '14px');
    yAxisLabel.setAttribute('font-weight', 'bold');
    yAxisLabel.setAttribute('fill', '#333');
    yAxisLabel.textContent = yAxis;
    g.appendChild(yAxisLabel);
    
    svg.appendChild(g);
  }, [data, width, height, color, xAxis, yAxis, labels]);
  
  return (
    <div className="chart-container">
      <svg
        ref={svgRef}
        width={width}
        height={height}
        viewBox={`0 0 ${width} ${height}`}
        className="line-chart"
      />
    </div>
  );
};

export default LineChart;

import React, { useEffect, useRef } from 'react';
import './Charts.css';

interface DataPoint {
  x: number;
  y: number;
  label?: string;
}

interface BarChartProps {
  data: DataPoint[];
  width: number;
  height: number;
  color: string;
  xAxis: string;
  yAxis: string;
  labels?: string[];
}

const BarChart: React.FC<BarChartProps> = ({ 
  data, 
  width, 
  height, 
  color, 
  xAxis, 
  yAxis,
  labels 
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  
  useEffect(() => {
    if (!svgRef.current || data.length === 0) return;
    
    // Clear previous content
    const svg = svgRef.current;
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }
    
    // Set margins
    const margin = { top: 20, right: 20, bottom: 60, left: 60 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;
    
    // Find min and max values
    const xValues = data.map(d => d.x);
    const yValues = data.map(d => d.y);
    
    const xMin = Math.min(...xValues);
    const xMax = Math.max(...xValues);
    // Ensure y starts from 0 unless there are negative values
    const yMin = Math.min(0, ...yValues);
    const yMax = Math.max(...yValues) * 1.1; // Add 10% padding on top
    
    // Calculate bar width based on data points and chart width
    const barWidth = Math.min(
      50, // Maximum bar width
      Math.floor(innerWidth / data.length) * 0.7 // 70% of available width per data point
    );
    
    // Create scales
    const xScale = (x: number) => margin.left + ((x - xMin) / (Math.max(1, xMax - xMin))) * innerWidth;
    const yScale = (y: number) => margin.top + innerHeight - ((y - yMin) / (Math.max(1, yMax - yMin))) * innerHeight;
    
    // Create group for the chart
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Draw axes
    // X-axis
    const xAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxisLine.setAttribute('x1', `${margin.left}`);
    xAxisLine.setAttribute('y1', `${margin.top + innerHeight}`);
    xAxisLine.setAttribute('x2', `${margin.left + innerWidth}`);
    xAxisLine.setAttribute('y2', `${margin.top + innerHeight}`);
    xAxisLine.setAttribute('stroke', '#333');
    xAxisLine.setAttribute('stroke-width', '1');
    g.appendChild(xAxisLine);
    
    // Y-axis
    const yAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    yAxisLine.setAttribute('x1', `${margin.left}`);
    yAxisLine.setAttribute('y1', `${margin.top}`);
    yAxisLine.setAttribute('x2', `${margin.left}`);
    yAxisLine.setAttribute('y2', `${margin.top + innerHeight}`);
    yAxisLine.setAttribute('stroke', '#333');
    yAxisLine.setAttribute('stroke-width', '1');
    g.appendChild(yAxisLine);
    
    // Draw grid lines (horizontal)
    const gridCount = 5;
    for (let i = 0; i <= gridCount; i++) {
      const yPos = margin.top + (innerHeight / gridCount) * i;
      const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      gridLine.setAttribute('x1', `${margin.left}`);
      gridLine.setAttribute('y1', `${yPos}`);
      gridLine.setAttribute('x2', `${margin.left + innerWidth}`);
      gridLine.setAttribute('y2', `${yPos}`);
      gridLine.setAttribute('stroke', '#e0e0e0');
      gridLine.setAttribute('stroke-width', '1');
      g.appendChild(gridLine);
      
      // Y-axis labels
      const yValue = yMax - (i / gridCount) * (yMax - yMin);
      const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      yLabel.setAttribute('x', `${margin.left - 10}`);
      yLabel.setAttribute('y', `${yPos}`);
      yLabel.setAttribute('text-anchor', 'end');
      yLabel.setAttribute('dominant-baseline', 'middle');
      yLabel.setAttribute('font-size', '12px');
      yLabel.setAttribute('fill', '#666');
      yLabel.textContent = yValue.toLocaleString(undefined, { 
        maximumFractionDigits: yValue > 100 ? 0 : 1 
      });
      g.appendChild(yLabel);
    }
    
    // Draw bars and X-axis labels
    const xLabelInterval = Math.max(1, Math.ceil(data.length / 10)); // Show max 10 labels
    
    data.forEach((point, i) => {
      const xPos = xScale(point.x);
      const barHeight = yScale(yMin) - yScale(point.y);
      
      // Draw bar
      const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bar.setAttribute('x', `${xPos - barWidth / 2}`);
      bar.setAttribute('y', `${yScale(point.y)}`);
      bar.setAttribute('width', `${barWidth}`);
      bar.setAttribute('height', `${barHeight}`);
      bar.setAttribute('fill', color);
      
      // Add hover effect
      bar.setAttribute('class', 'chart-bar');
      
      // Add tooltip with data value
      bar.addEventListener('mouseover', (e) => {
        const tooltip = document.createElement('div');
        tooltip.className = 'chart-tooltip';
        tooltip.textContent = point.y.toLocaleString();
        tooltip.style.position = 'absolute';
        tooltip.style.left = `${e.pageX}px`;
        tooltip.style.top = `${e.pageY - 40}px`;
        document.body.appendChild(tooltip);
        
        // Highlight the bar
        bar.setAttribute('fill-opacity', '0.8');
      });
      
      bar.addEventListener('mouseout', () => {
        const tooltips = document.querySelectorAll('.chart-tooltip');
        tooltips.forEach(t => t.remove());
        
        // Reset bar highlight
        bar.setAttribute('fill-opacity', '1');
      });
      
      g.appendChild(bar);
      
      // X-axis labels (show every nth label or if it's the last point)
      if (i % xLabelInterval === 0 || i === data.length - 1) {
        // Tick mark
        const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        tick.setAttribute('x1', `${xPos}`);
        tick.setAttribute('y1', `${margin.top + innerHeight}`);
        tick.setAttribute('x2', `${xPos}`);
        tick.setAttribute('y2', `${margin.top + innerHeight + 5}`);
        tick.setAttribute('stroke', '#333');
        tick.setAttribute('stroke-width', '1');
        g.appendChild(tick);
        
        // Label
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', `${xPos}`);
        label.setAttribute('y', `${margin.top + innerHeight + 20}`);
        label.setAttribute('text-anchor', 'middle');
        label.setAttribute('font-size', '12px');
        label.setAttribute('fill', '#666');
        
        // Use custom label if provided, otherwise use x value
        const labelText = labels && labels[i] ? labels[i] : point.x.toString();
        label.textContent = labelText;
        
        // Rotate label if many data points
        if (data.length > 10) {
          label.setAttribute('transform', `rotate(45, ${xPos}, ${margin.top + innerHeight + 20})`);
          label.setAttribute('text-anchor', 'start');
        }
        
        g.appendChild(label);
      }
    });
    
    // Add axis labels
    // X-axis label
    const xAxisLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    xAxisLabel.setAttribute('x', `${margin.left + innerWidth / 2}`);
    xAxisLabel.setAttribute('y', `${height - 10}`);
    xAxisLabel.setAttribute('text-anchor', 'middle');
    xAxisLabel.setAttribute('font-size', '14px');
    xAxisLabel.setAttribute('font-weight', 'bold');
    xAxisLabel.setAttribute('fill', '#333');
    xAxisLabel.textContent = xAxis;
    g.appendChild(xAxisLabel);
    
    // Y-axis label
    const yAxisLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yAxisLabel.setAttribute('transform', `rotate(-90, 20, ${margin.top + innerHeight / 2})`);
    yAxisLabel.setAttribute('x', '20');
    yAxisLabel.setAttribute('y', `${margin.top + innerHeight / 2}`);
    yAxisLabel.setAttribute('text-anchor', 'middle');
    yAxisLabel.setAttribute('font-size', '14px');
    yAxisLabel.setAttribute('font-weight', 'bold');
    yAxisLabel.setAttribute('fill', '#333');
    yAxisLabel.textContent = yAxis;
    g.appendChild(yAxisLabel);
    
    svg.appendChild(g);
  }, [data, width, height, color, xAxis, yAxis, labels]);
  
  return (
    <div className="chart-container">
      <svg
        ref={svgRef}
        width={width}
        height={height}
        viewBox={`0 0 ${width} ${height}`}
        className="bar-chart"
      />
    </div>
  );
};

export default BarChart;

import React, { useEffect, useRef } from 'react';
import './Charts.css';

interface HeatMapProps {
  data: number[][];
  rowLabels: string[];
  colLabels: string[];
  width: number;
  height: number;
  colorScale?: [string, string, string]; // [min, mid, max] colors
  title?: string;
}

const HeatMap: React.FC<HeatMapProps> = ({
  data,
  rowLabels,
  colLabels,
  width,
  height,
  colorScale = ['#e74c3c', '#f1c40f', '#2ecc71'], // Default red-yellow-green scale
  title
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  
  useEffect(() => {
    if (!svgRef.current || !data || data.length === 0) return;
    
    // Clear previous content
    const svg = svgRef.current;
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }
    
    // Set margins
    const margin = { top: 40, right: 20, bottom: 60, left: 120 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;
    
    // Calculate cell dimensions
    const cellWidth = innerWidth / Math.max(1, colLabels.length);
    const cellHeight = innerHeight / Math.max(1, rowLabels.length);
    
    // Create group for the chart
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Find min and max values for color scaling
    let minValue = Number.MAX_VALUE;
    let maxValue = Number.MIN_VALUE;
    
    for (const row of data) {
      for (const value of row) {
        if (value < minValue) minValue = value;
        if (value > maxValue) maxValue = value;
      }
    }
    
    // Create color scale function
    const getColor = (value: number): string => {
      // Handle edge cases
      if (minValue === maxValue) return colorScale[1];
      
      // Normalize value to 0-1 range
      const normalizedValue = (value - minValue) / (maxValue - minValue);
      
      // Apply color scale
      if (normalizedValue <= 0.5) {
        // Blend between min and mid colors
        const t = normalizedValue * 2; // Scale to 0-1 for this range
        return blendColors(colorScale[0], colorScale[1], t);
      } else {
        // Blend between mid and max colors
        const t = (normalizedValue - 0.5) * 2; // Scale to 0-1 for this range
        return blendColors(colorScale[1], colorScale[2], t);
      }
    };
    
    // Add title if provided
    if (title) {
      const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      titleElement.setAttribute('x', `${width / 2}`);
      titleElement.setAttribute('y', `${margin.top / 2}`);
      titleElement.setAttribute('text-anchor', 'middle');
      titleElement.setAttribute('font-size', '16px');
      titleElement.setAttribute('font-weight', 'bold');
      titleElement.setAttribute('fill', '#333');
      titleElement.textContent = title;
      g.appendChild(titleElement);
    }
    
    // Draw column labels
    colLabels.forEach((label, col) => {
      const labelElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      const xPos = margin.left + cellWidth * col + cellWidth / 2;
      labelElement.setAttribute('x', `${xPos}`);
      labelElement.setAttribute('y', `${margin.top - 10}`);
      labelElement.setAttribute('text-anchor', 'middle');
      labelElement.setAttribute('font-size', '12px');
      labelElement.setAttribute('fill', '#666');
      
      // Truncate long labels
      const maxLength = Math.max(5, Math.floor(cellWidth / 7)); // Rough estimate of chars per cell
      const displayLabel = label.length > maxLength 
        ? label.substring(0, maxLength - 3) + '...' 
        : label;
      
      labelElement.textContent = displayLabel;
      
      // Rotate if many columns
      if (colLabels.length > 8) {
        labelElement.setAttribute('transform', `rotate(-45, ${xPos}, ${margin.top - 10})`);
        labelElement.setAttribute('text-anchor', 'end');
      }
      
      // Add title for full text on hover
      if (label.length > maxLength) {
        const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'title');
        titleElement.textContent = label;
        labelElement.appendChild(titleElement);
      }
      
      g.appendChild(labelElement);
    });
    
    // Draw row labels
    rowLabels.forEach((label, row) => {
      const labelElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      const yPos = margin.top + cellHeight * row + cellHeight / 2;
      labelElement.setAttribute('x', `${margin.left - 10}`);
      labelElement.setAttribute('y', `${yPos}`);
      labelElement.setAttribute('text-anchor', 'end');
      labelElement.setAttribute('dominant-baseline', 'middle');
      labelElement.setAttribute('font-size', '12px');
      labelElement.setAttribute('fill', '#666');
      
      // Truncate long labels
      const maxLength = Math.min(25, Math.floor(margin.left / 7)); // Rough estimate of chars
      const displayLabel = label.length > maxLength 
        ? label.substring(0, maxLength - 3) + '...' 
        : label;
      
      labelElement.textContent = displayLabel;
      
      // Add title for full text on hover
      if (label.length > maxLength) {
        const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'title');
        titleElement.textContent = label;
        labelElement.appendChild(titleElement);
      }
      
      g.appendChild(labelElement);
    });
    
    // Draw heatmap cells
    for (let row = 0; row < data.length; row++) {
      for (let col = 0; col < data[row].length; col++) {
        const value = data[row][col];
        const cell = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        
        cell.setAttribute('x', `${margin.left + cellWidth * col}`);
        cell.setAttribute('y', `${margin.top + cellHeight * row}`);
        cell.setAttribute('width', `${cellWidth}`);
        cell.setAttribute('height', `${cellHeight}`);
        cell.setAttribute('fill', getColor(value));
        cell.setAttribute('stroke', '#fff');
        cell.setAttribute('stroke-width', '1');
        
        // Add tooltip with value
        cell.addEventListener('mouseover', (e) => {
          const tooltip = document.createElement('div');
          tooltip.className = 'chart-tooltip';
          tooltip.innerHTML = `${rowLabels[row]}<br>${colLabels[col]}<br>Value: ${value}`;
          tooltip.style.position = 'absolute';
          tooltip.style.left = `${e.pageX + 10}px`;
          tooltip.style.top = `${e.pageY - 40}px`;
          document.body.appendChild(tooltip);
          
          // Highlight the cell
          cell.setAttribute('stroke', '#333');
          cell.setAttribute('stroke-width', '2');
        });
        
        cell.addEventListener('mouseout', () => {
          const tooltips = document.querySelectorAll('.chart-tooltip');
          tooltips.forEach(t => t.remove());
          
          // Reset cell highlight
          cell.setAttribute('stroke', '#fff');
          cell.setAttribute('stroke-width', '1');
        });
        
        g.appendChild(cell);
        
        // Add text label for the value if cells are large enough
        if (cellWidth >= 30 && cellHeight >= 20) {
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', `${margin.left + cellWidth * col + cellWidth / 2}`);
          text.setAttribute('y', `${margin.top + cellHeight * row + cellHeight / 2}`);
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('dominant-baseline', 'middle');
          text.setAttribute('font-size', '11px');
          
          // Set text color based on cell color lightness
          const color = getColor(value);
          const isLight = isLightColor(color);
          text.setAttribute('fill', isLight ? '#333' : '#fff');
          
          text.textContent = value.toString();
          g.appendChild(text);
        }
      }
    }
    
    // Add color legend
    const legendWidth = 200;
    const legendHeight = 20;
    const legendX = width - legendWidth - margin.right;
    const legendY = height - legendHeight - 10;
    
    // Create gradient for legend
    const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
    gradient.setAttribute('id', 'heatmap-gradient');
    gradient.setAttribute('x1', '0%');
    gradient.setAttribute('y1', '0%');
    gradient.setAttribute('x2', '100%');
    gradient.setAttribute('y2', '0%');
    
    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop1.setAttribute('offset', '0%');
    stop1.setAttribute('stop-color', colorScale[0]);
    
    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop2.setAttribute('offset', '50%');
    stop2.setAttribute('stop-color', colorScale[1]);
    
    const stop3 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop3.setAttribute('offset', '100%');
    stop3.setAttribute('stop-color', colorScale[2]);
    
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    gradient.appendChild(stop3);
    
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.appendChild(gradient);
    g.appendChild(defs);
    
    // Create legend rectangle
    const legendRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    legendRect.setAttribute('x', `${legendX}`);
    legendRect.setAttribute('y', `${legendY}`);
    legendRect.setAttribute('width', `${legendWidth}`);
    legendRect.setAttribute('height', `${legendHeight}`);
    legendRect.setAttribute('fill', 'url(#heatmap-gradient)');
    g.appendChild(legendRect);
    
    // Add legend labels
    const minLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    minLabel.setAttribute('x', `${legendX}`);
    minLabel.setAttribute('y', `${legendY + legendHeight + 15}`);
    minLabel.setAttribute('text-anchor', 'start');
    minLabel.setAttribute('font-size', '12px');
    minLabel.setAttribute('fill', '#666');
    minLabel.textContent = minValue.toString();
    g.appendChild(minLabel);
    
    const midLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    midLabel.setAttribute('x', `${legendX + legendWidth / 2}`);
    midLabel.setAttribute('y', `${legendY + legendHeight + 15}`);
    midLabel.setAttribute('text-anchor', 'middle');
    midLabel.setAttribute('font-size', '12px');
    midLabel.setAttribute('fill', '#666');
    midLabel.textContent = ((minValue + maxValue) / 2).toFixed(1);
    g.appendChild(midLabel);
    
    const maxLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    maxLabel.setAttribute('x', `${legendX + legendWidth}`);
    maxLabel.setAttribute('y', `${legendY + legendHeight + 15}`);
    maxLabel.setAttribute('text-anchor', 'end');
    maxLabel.setAttribute('font-size', '12px');
    maxLabel.setAttribute('fill', '#666');
    maxLabel.textContent = maxValue.toString();
    g.appendChild(maxLabel);
    
    svg.appendChild(g);
  }, [data, rowLabels, colLabels, width, height, colorScale, title]);
  
  // Helper function to blend two colors
  const blendColors = (color1: string, color2: string, ratio: number): string => {
    // Convert hex to RGB
    const hexToRgb = (hex: string): [number, number, number] => {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return [r, g, b];
    };
    
    // Convert RGB to hex
    const rgbToHex = (r: number, g: number, b: number): string => {
      return '#' + [r, g, b]
        .map(x => Math.round(x).toString(16).padStart(2, '0'))
        .join('');
    };
    
    const [r1, g1, b1] = hexToRgb(color1);
    const [r2, g2, b2] = hexToRgb(color2);
    
    const r = r1 + (r2 - r1) * ratio;
    const g = g1 + (g2 - g1) * ratio;
    const b = b1 + (b2 - b1) * ratio;
    
    return rgbToHex(r, g, b);
  };
  
  // Helper function to determine if a color is light or dark
  const isLightColor = (hexColor: string): boolean => {
    // Convert hex to RGB
    const r = parseInt(hexColor.slice(1, 3), 16);
    const g = parseInt(hexColor.slice(3, 5), 16);
    const b = parseInt(hexColor.slice(5, 7), 16);
    
    // Calculate perceived brightness using YIQ formula
    const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return yiq >= 128; // 128 is the threshold (0-255)
  };
  
  return (
    <div className="chart-container">
      <svg
        ref={svgRef}
        width={width}
        height={height}
        viewBox={`0 0 ${width} ${height}`}
        className="heat-map"
      />
    </div>
  );
};

export default HeatMap;


.chart-container {
  position: relative;
  margin: 20px 0;
  background-color: #fff;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  overflow: visible;
}

/* Chart-specific styles */
.line-chart .chart-point {
  cursor: pointer;
  transition: r 0.2s ease;
}

.line-chart .chart-point:hover {
  r: 6;
}

.bar-chart rect {
  cursor: pointer;
  transition: fill-opacity 0.2s ease;
}

.heat-map rect {
  cursor: pointer;
  transition: stroke-width 0.2s ease;
}

/* Tooltip styles */
.chart-tooltip {
  position: absolute;
  background-color: rgba(0, 0, 0, 0.8);
  color: #fff;
  padding: 5px 10px;
  border-radius: 4px;
  font-size: 12px;
  pointer-events: none;
  z-index: 1000;
  white-space: nowrap;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  max-width: 300px;
}

/* Loading and error states */
.loading, .error, .no-data {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
  background-color: #f8f9fa;
  border-radius: 4px;
  color: #6c757d;
  font-size: 14px;
}

.error {
  color: #dc3545;
}

.no-data {
  color: #6c757d;
  font-style: italic;
}


import React, { useState } from 'react';
import './Filters.css';

interface DateRangeFilterProps {
  startDate: string;
  endDate: string;
  onDateRangeChange: (startDate: string, endDate: string) => void;
}

type RangeOption = '7d' | '30d' | '90d' | 'custom';

const DateRangeFilter: React.FC<DateRangeFilterProps> = ({
  startDate,
  endDate,
  onDateRangeChange
}) => {
  const [selectedRange, setSelectedRange] = useState<RangeOption>('30d');
  const [customStartDate, setCustomStartDate] = useState<string>(startDate);
  const [customEndDate, setCustomEndDate] = useState<string>(endDate);
  const [isCustomRangeOpen, setIsCustomRangeOpen] = useState<boolean>(false);

  // Apply predefined range
  const applyPredefinedRange = (range: RangeOption) => {
    setSelectedRange(range);
    
    if (range === 'custom') {
      setIsCustomRangeOpen(true);
      return;
    }
    
    setIsCustomRangeOpen(false);
    
    const today = new Date();
    let start = new Date();
    
    // Calculate start date based on selected range
    switch (range) {
      case '7d':
        start.setDate(today.getDate() - 7);
        break;
      case '30d':
        start.setDate(today.getDate() - 30);
        break;
      case '90d':
        start.setDate(today.getDate() - 90);
        break;
    }
    
    // Format dates as YYYY-MM-DD
    const formatDate = (date: Date): string => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    };
    
    const formattedStartDate = formatDate(start);
    const formattedEndDate = formatDate(today);
    
    // Update state
    setCustomStartDate(formattedStartDate);
    setCustomEndDate(formattedEndDate);
    
    // Notify parent
    onDateRangeChange(formattedStartDate, formattedEndDate);
  };

  // Apply custom range
  const applyCustomRange = () => {
    setIsCustomRangeOpen(false);
    onDateRangeChange(customStartDate, customEndDate);
  };

  // Handle custom start date change
  const handleStartDateChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setCustomStartDate(e.target.value);
  };

  // Handle custom end date change
  const handleEndDateChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setCustomEndDate(e.target.value);
  };

  return (
    <div className="date-range-filter">
      <div className="range-buttons">
        <button
          className={`range-button ${selectedRange === '7d' ? 'active' : ''}`}
          onClick={() => applyPredefinedRange('7d')}
        >
          Last 7 Days
        </button>
        <button
          className={`range-button ${selectedRange === '30d' ? 'active' : ''}`}
          onClick={() => applyPredefinedRange('30d')}
        >
          Last 30 Days
        </button>
        <button
          className={`range-button ${selectedRange === '90d' ? 'active' : ''}`}
          onClick={() => applyPredefinedRange('90d')}
        >
          Last 90 Days
        </button>
        <button
          className={`range-button ${selectedRange === 'custom' ? 'active' : ''}`}
          onClick={() => applyPredefinedRange('custom')}
        >
          Custom Range
        </button>
      </div>
      
      {isCustomRangeOpen && (
        <div className="custom-range-panel">
          <div className="date-inputs">
            <div className="date-input-field">
              <label htmlFor="start-date">Start Date</label>
              <input
                type="date"
                id="start-date"
                value={customStartDate}
                onChange={handleStartDateChange}
                max={customEndDate}
              />
            </div>
            <div className="date-input-field">
              <label htmlFor="end-date">End Date</label>
              <input
                type="date"
                id="end-date"
                value={customEndDate}
                onChange={handleEndDateChange}
                min={customStartDate}
              />
            </div>
          </div>
          <div className="custom-range-actions">
            <button className="apply-button" onClick={applyCustomRange}>
              Apply
            </button>
            <button 
              className="cancel-button" 
              onClick={() => setIsCustomRangeOpen(false)}
            >
              Cancel
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default DateRangeFilter;


import React from 'react';
import './Filters.css';

interface Project {
  id: string;
  name: string;
}

interface ProjectSelectorProps {
  projects: Project[];
  selectedProject: string;
  onProjectChange: (projectId: string) => void;
}

const ProjectSelector: React.FC<ProjectSelectorProps> = ({
  projects,
  selectedProject,
  onProjectChange
}) => {
  // Handle project change
  const handleProjectChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    onProjectChange(e.target.value);
  };

  if (!projects || projects.length === 0) {
    return (
      <div className="project-selector empty">
        <span className="no-projects">No projects available</span>
      </div>
    );
  }

  return (
    <div className="project-selector">
      <label htmlFor="project-select">Project:</label>
      <select
        id="project-select"
        value={selectedProject}
        onChange={handleProjectChange}
      >
        {projects.map(project => (
          <option key={project.id} value={project.id}>
            {project.name}
          </option>
        ))}
      </select>
    </div>
  );
};

export default ProjectSelector;



Filters.css
-----------------
/* Common filter styles */
.date-range-filter,
.project-selector {
  margin: 10px 0;
  padding: 10px;
  background-color: #fff;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* Date Range Filter */
.date-range-filter .range-buttons {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.date-range-filter .range-button {
  padding: 6px 12px;
  background-color: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  color: #495057;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.date-range-filter .range-button:hover {
  background-color: #e9ecef;
}

.date-range-filter .range-button.active {
  background-color: #007bff;
  border-color: #007bff;
  color: #fff;
}

.date-range-filter .custom-range-panel {
  margin-top: 15px;
  padding: 15px;
  background-color: #f8f9fa;
  border-radius: 4px;
  border: 1px solid #dee2e6;
}

.date-range-filter .date-inputs {
  display: flex;
  gap: 15px;
  margin-bottom: 15px;
}

.date-range-filter .date-input-field {
  flex: 1;
}

.date-range-filter .date-input-field label {
  display: block;
  margin-bottom: 5px;
  font-size: 14px;
  color: #495057;
}

.date-range-filter .date-input-field input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ced4da;
  border-radius: 4px;
  font-size: 14px;
}

.date-range-filter .custom-range-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

.date-range-filter .apply-button {
  padding: 6px 12px;
  background-color: #28a745;
  border: 1px solid #28a745;
  border-radius: 4px;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
}

.date-range-filter .cancel-button {
  padding: 6px 12px;
  background-color: #6c757d;
  border: 1px solid #6c757d;
  border-radius: 4px;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
}

/* Project Selector */
.project-selector {
  display: flex;
  align-items: center;
  gap: 10px;
}

.project-selector label {
  font-size: 14px;
  color: #495057;
  margin-right: 5px;
}

.project-selector select {
  padding: 8px 12px;
  border: 1px solid #ced4da;
  border-radius: 4px;
  font-size: 14px;
  min-width: 200px;
}

.project-selector.empty {
  padding: 10px 15px;
  color: #6c757d;
  font-style: italic;
}


ReportingDashboard.css
-----------------------
.reporting-dashboard {
  padding: 20px;
  background-color: #f8f9fa;
  min-height: calc(100vh - 60px); /* Adjust based on header height */
}

.dashboard-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 20px;
}

.dashboard-header h1 {
  margin: 0;
  color: #212529;
  font-size: 24px;
}

.dashboard-filters {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
}

.dashboard-summary {
  margin-bottom: 30px;
}

.dashboard-trends,
.dashboard-reliability,
.dashboard-performance,
.dashboard-failures {
  margin-bottom: 30px;
  background-color: #fff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.dashboard-trends h2,
.dashboard-reliability h2,
.dashboard-performance h2,
.dashboard-failures h2 {
  margin-top: 0;
  margin-bottom: 20px;
  font-size: 18px;
  color: #343a40;
  border-bottom: 1px solid #dee2e6;
  padding-bottom: 10px;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .dashboard-header {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .dashboard-filters {
    width: 100%;
  }
}


ExecutionSummary.css
--------------------------
.execution-summary {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin-bottom: 20px;
}

.summary-card {
  background-color: #fff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.summary-card h3 {
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 16px;
  color: #495057;
  border-bottom: 1px solid #e9ecef;
  padding-bottom: 8px;
}

.status-indicator {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.status-value {
  font-size: 36px;
  font-weight: bold;
  margin-bottom: 5px;
}

.status-label {
  font-size: 14px;
  color: #6c757d;
}

.status-indicator.success .status-value {
  color: #28a745;
}

.status-indicator.warning .status-value {
  color: #ffc107;
}

.status-indicator.danger .status-value {
  color: #dc3545;
}

.metric {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
  align-items: center;
}

.metric-value {
  font-size: 18px;
  font-weight: bold;
  color: #212529;
}

.metric-label {
  font-size: 14px;
  color: #6c757d;
}

.metric.success .metric-value {
  color: #28a745;
}

.metric.danger .metric-value {
  color: #dc3545;
}

.active-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.active-item {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid #e9ecef;
  font-size: 14px;
}

.active-item:last-child {
  border-bottom: none;
}

.execution-name {
  font-weight: bold;
  color: #495057;
  flex: 2;
}

.execution-env, 
.execution-browser {
  color: #6c757d;
  flex: 1;
  text-align: center;
}

.execution-progress {
  color: #007bff;
  font-weight: bold;
  flex: 1;
  text-align: right;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .execution-summary {
    grid-template-columns: repeat(auto-fit, minmax(100%, 1fr));
  }
}


TrendAnalysis.css
--------------------

.trend-analysis {
  background-color: #fff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.chart-controls {
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 15px;
}

.date-range-display {
  font-size: 14px;
  color: #6c757d;
  padding: 8px 12px;
  background-color: #f8f9fa;
  border-radius: 4px;
  border: 1px solid #dee2e6;
}

.metric-selector {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.metric-button {
  padding: 8px 12px;
  background-color: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  color: #495057;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.metric-button:hover {
  background-color: #e9ecef;
}

.metric-button.active {
  background-color: #007bff;
  border-color: #007bff;
  color: #fff;
}

.chart-container {
  width: 100%;
  height: 400px;
  margin: 0 auto 20px;
  display: flex;
  justify-content: center;
}

.trend-summary {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  margin-top: 20px;
  border-top: 1px solid #dee2e6;
  padding-top: 20px;
}

.trend-metric {
  background-color: #f8f9fa;
  border-radius: 6px;
  padding: 15px;
  text-align: center;
}

.trend-label {
  display: block;
  font-size: 14px;
  color: #6c757d;
  margin-bottom: 5px;
}

.trend-value {
  display: block;
  font-size: 18px;
  font-weight: bold;
  color: #343a40;
}

.no-data {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
  background-color: #f8f9fa;
  border-radius: 4px;
  color: #6c757d;
  font-style: italic;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .chart-controls {
    flex-direction: column;
  }
  
  .trend-summary {
    grid-template-columns: repeat(auto-fit, minmax(100%, 1fr));
  }
}



TestPerfomanceChart.css
-------------------------
.test-performance-chart {
  background-color: #fff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.performance-controls {
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 15px;
}

.test-case-selector {
  display: flex;
  align-items: center;
  gap: 10px;
}

.test-case-selector label {
  font-size: 14px;
  color: #495057;
}

.test-case-selector select {
  padding: 8px 12px;
  border: 1px solid #ced4da;
  border-radius: 4px;
  font-size: 14px;
  min-width: 250px;
}

.chart-type-toggle {
  display: flex;
  align-items: center;
}

.toggle-button {
  padding: 8px 12px;
  background-color: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  color: #495057;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.toggle-button:hover {
  background-color: #e9ecef;
}

.toggle-button.active {
  background-color: #6f42c1;
  border-color: #6f42c1;
  color: #fff;
}

.performance-summary {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
  margin-bottom: 20px;
}

.metric {
  background-color: #f8f9fa;
  border-radius: 6px;
  padding: 15px;
  text-align: center;
}

.metric-label {
  display: block;
  font-size: 14px;
  color: #6c757d;
  margin-bottom: 5px;
}

.metric-value {
  display: block;
  font-size: 18px;
  font-weight: bold;
  color: #343a40;
}

.anomalies-section {
  margin-top: 30px;
  border-top: 1px solid #dee2e6;
  padding-top: 20px;
}

.anomalies-section h3 {
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 16px;
  color: #495057;
}

.anomalies-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
}

.anomalies-table th,
.anomalies-table td {
  padding: 10px;
  text-align: left;
  border-bottom: 1px solid #dee2e6;
}

.anomalies-table th {
  background-color: #f8f9fa;
  font-weight: bold;
  color: #495057;
}

.anomalies-table .negative {
  color: #dc3545;
}

.anomalies-table .positive {
  color: #28a745;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .performance-controls {
    flex-direction: column;
    align-items: stretch;
  }
  
  .performance-summary {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .anomalies-table {
    display: block;
    overflow-x: auto;
  }
}


TestReliabilityMatrix.css
----------------------------
.test-reliability-matrix {
  background-color: #fff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.reliability-controls {
  display: flex;
  justify-content: flex-end;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 15px;
}

.sort-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

.sort-controls span {
  font-size: 14px;
  color: #495057;
}

.sort-button {
  padding: 6px 12px;
  background-color: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  color: #495057;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.sort-button:hover {
  background-color: #e9ecef;
}

.sort-button.active {
  background-color: #007bff;
  border-color: #007bff;
  color: #fff;
}

.reliability-table-container {
  margin-bottom: 20px;
  overflow-x: auto;
}

.reliability-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
}

.reliability-table th,
.reliability-table td {
  padding: 10px;
  text-align: left;
  border-bottom: 1px solid #dee2e6;
}

.reliability-table th {
  background-color: #f8f9fa;
  font-weight: bold;
  color: #495057;
  position: sticky;
  top: 0;
  z-index: 10;
}

.reliability-table .test-name {
  font-weight: 500;
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.reliability-table .reliability-score {
  font-weight: bold;
}

.reliability-table .failure-count {
  color: #dc3545;
}

.reliability-status {
  display: flex;
  align-items: center;
  gap: 5px;
}

.status-indicator {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
}

.status-indicator.high-reliability {
  background-color: #28a745;
}

.status-indicator.medium-reliability {
  background-color: #ffc107;
}

.status-indicator.low-reliability {
  background-color: #dc3545;
}

.reliability-summary {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
  margin-bottom: 20px;
  border-top: 1px solid #dee2e6;
  padding-top: 20px;
}

.summary-metric {
  background-color: #f8f9fa;
  border-radius: 6px;
  padding: 15px;
  text-align: center;
}

.metric-value {
  display: block;
  font-size: 24px;
  font-weight: bold;
  color: #343a40;
  margin-bottom: 5px;
}

.metric-label {
  display: block;
  font-size: 14px;
  color: #6c757d;
}

.reliability-recommendations {
  background-color: #f8f9fa;
  border-radius: 6px;
  padding: 15px;
}

.reliability-recommendations h3 {
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 16px;
  color: #495057;
}

.recommendations-list {
  list-style-type: none;
  padding-left: 0;
  margin: 0;
}

.recommendation-item {
  margin-bottom: 10px;
  padding-left: 20px;
  position: relative;
  font-size: 14px;
  color: #495057;
}

.recommendation-item:before {
  content: "â€¢";
  position: absolute;
  left: 0;
  color: #007bff;
  font-weight: bold;
}

.recommendation-item .test-name {
  font-weight: bold;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .reliability-summary {
    grid-template-columns: repeat(2, 1fr);
  }
}



FailureAnalysis.css
----------------------

.failure-analysis {
  background-color: #fff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.category-tabs {
  display: flex;
  gap: 10px;
  overflow-x: auto;
  padding-bottom: 10px;
  margin-bottom: 20px;
  border-bottom: 1px solid #dee2e6;
}

.category-tab {
  background-color: #f8f9fa;
  border: 1px solid #dee2e6;
  border-left-width: 4px;
  border-radius: 4px;
  padding: 10px 15px;
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.category-tab:hover {
  background-color: #e9ecef;
}

.category-tab.active {
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.category-icon {
  font-size: 18px;
}

.category-name {
  font-size: 14px;
  font-weight: 500;
}

.failure-count {
  background-color: #dc3545;
  color: #fff;
  border-radius: 20px;
  padding: 2px 8px;
  font-size: 12px;
  font-weight: bold;
}

.category-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 15px;
}

.category-header h3 {
  margin: 0;
  font-size: 18px;
  color: #343a40;
}

.category-summary {
  font-size: 14px;
  color: #6c757d;
}

.failure-total {
  background-color: #f8f9fa;
  border-radius: 4px;
  padding: 5px 10px;
  font-weight: 500;
}

.category-details {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  margin-bottom: 20px;
}

.error-patterns, 
.recommendations {
  background-color: #f8f9fa;
  border-radius: 6px;
  padding: 15px;
}

.error-patterns h4, 
.recommendations h4 {
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 16px;
  color: #495057;
}

.pattern-list, 
.recommendation-list {
  list-style-type: none;
  padding-left: 0;
  margin: 0;
}

.pattern-item, 
.recommendation-item {
  margin-bottom: 10px;
  padding-left: 20px;
  position: relative;
  font-size: 14px;
  color: #495057;
}

.pattern-item:before, 
.recommendation-item:before {
  content: "â€¢";
  position: absolute;
  left: 0;
  color: #007bff;
  font-weight: bold;
}

.pattern-count {
  display: inline-block;
  min-width: 24px;
  height: 24px;
  line-height: 24px;
  text-align: center;
  background-color: #6c757d;
  color: #fff;
  border-radius: 12px;
  font-size: 12px;
  margin-right: 10px;
}

.pattern-text {
  font-family: monospace;
}

.failures-list-container {
  margin-top: 20px;
}

.failures-list-container h4 {
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 16px;
  color: #495057;
}

.failures-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
}

.failures-table th,
.failures-table td {
  padding: 10px;
  text-align: left;
  border-bottom: 1px solid #dee2e6;
}

.failures-table th {
  background-color: #f8f9fa;
  font-weight: bold;
  color: #495057;
}

.failures-table tr.selected {
  background-color: #f8f9fa;
}

.failures-table .message-cell {
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.view-details-button {
  padding: 4px 8px;
  background-color: #007bff;
  border: none;
  border-radius: 4px;
  color: #fff;
  font-size: 12px;
  cursor: pointer;
}

.more-failures {
  margin-top: 10px;
  text-align: center;
  font-size: 14px;
  color: #6c757d;
  font-style: italic;
}

.failure-details-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.failure-details-panel {
  background-color: #fff;
  border-radius: 8px;
  max-width: 800px;
  width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.details-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 20px;
  border-bottom: 1px solid #dee2e6;
}

.details-header h3 {
  margin: 0;
  font-size: 18px;
  color: #343a40;
}

.close-button {
  background: none;
  border: none;
  font-size: 24px;
  color: #6c757d;
  cursor: pointer;
}

.details-content {
  padding: 20px;
}

.details-section {
  margin-bottom: 20px;
}

.details-section:last-child {
  margin-bottom: 0;
}

.details-section h4 {
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 16px;
  color: #495057;
  border-bottom: 1px solid #e9ecef;
  padding-bottom: 5px;
}

.detail-item {
  margin-bottom: 10px;
  font-size: 14px;
}

.detail-label {
  font-weight: bold;
  color: #495057;
  margin-right: 10px;
}

.detail-value {
  color: #212529;
}

.stack-trace {
  background-color: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  padding: 10px;
  overflow: auto;
  font-family: monospace;
  font-size: 12px;
  max-height: 200px;
  white-space: pre-wrap;
}

.screenshot-container {
  text-align: center;
}

.failure-screenshot {
  max-width: 100%;
  border: 1px solid #dee2e6;
  border-radius: 4px;
}

.suggested-actions {
  padding-left: 20px;
  margin: 0;
}

.suggested-actions li {
  margin-bottom: 5px;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .category-details {
    grid-template-columns: 1fr;
  }
  
  .failures-table {
    display: block;
    overflow-x: auto;
  }
  
  .failure-details-panel {
    width: 95%;
    max-height: 95vh;
  }
}


