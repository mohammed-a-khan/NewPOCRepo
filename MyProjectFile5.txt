// src/components/reporting/DashboardComponent.tsx
import React, { useState, useEffect } from 'react';
import { useReportingContext } from '../../contexts/ReportingContext';
import { TestExecutionSummary } from './TestExecutionSummary';
import { MetricsSummary } from './MetricsSummary';
import { ExecutionTimeline } from './ExecutionTimeline';
import { FeatureBreakdown } from './FeatureBreakdown';
import { ErrorDistribution } from './ErrorDistribution';
import { FilterPanel } from './FilterPanel';
import { DateRangePicker } from '../core/DateRangePicker';
import { Spinner } from '../core/Spinner';
import { useProjectContext } from '../../contexts/ProjectContext';
import { reportingService } from '../../services/api/reportingService';

export const DashboardComponent: React.FC = () => {
  const { projectId } = useProjectContext();
  const { metrics, loadMetrics, isLoading, selectedDateRange, setSelectedDateRange } = useReportingContext();
  const [activeTab, setActiveTab] = useState<'summary' | 'features' | 'errors'>('summary');

  useEffect(() => {
    if (projectId) {
      loadMetrics(projectId, selectedDateRange.startDate, selectedDateRange.endDate);
    }
  }, [projectId, selectedDateRange, loadMetrics]);

  if (isLoading) {
    return <Spinner message="Loading reporting data..." />;
  }

  return (
    <div className="reporting-dashboard">
      <div className="dashboard-header">
        <h1>Test Execution Dashboard</h1>
        <div className="dashboard-controls">
          <DateRangePicker
            startDate={selectedDateRange.startDate}
            endDate={selectedDateRange.endDate}
            onChange={(startDate, endDate) => setSelectedDateRange({ startDate, endDate })}
          />
          <FilterPanel />
        </div>
      </div>

      <div className="metrics-overview">
        <MetricsSummary metrics={metrics} />
      </div>

      <div className="dashboard-tabs">
        <button 
          className={`tab ${activeTab === 'summary' ? 'active' : ''}`}
          onClick={() => setActiveTab('summary')}
        >
          Summary
        </button>
        <button 
          className={`tab ${activeTab === 'features' ? 'active' : ''}`}
          onClick={() => setActiveTab('features')}
        >
          Features
        </button>
        <button 
          className={`tab ${activeTab === 'errors' ? 'active' : ''}`}
          onClick={() => setActiveTab('errors')}
        >
          Errors
        </button>
      </div>

      <div className="dashboard-content">
        {activeTab === 'summary' && (
          <>
            <TestExecutionSummary />
            <ExecutionTimeline 
              data={metrics.dailyExecutions || []}
              height={300}
            />
          </>
        )}
        
        {activeTab === 'features' && (
          <FeatureBreakdown 
            featureData={metrics.featureDistribution || {}}
            tagData={metrics.tagDistribution || {}}
          />
        )}
        
        {activeTab === 'errors' && (
          <ErrorDistribution 
            errorData={metrics.errorDistribution || []}
            mostFrequentError={metrics.mostFrequentError}
          />
        )}
      </div>
    </div>
  );
};

// src/components/reporting/TestReportViewer.tsx
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { reportingService } from '../../services/api/reportingService';
import { TestExecution, TestCase, TestStep, Attachment } from '../../models/reporting';
import { StepDetails } from './StepDetails';
import { AttachmentViewer } from './AttachmentViewer';
import { Timeline } from '../core/Timeline';
import { Spinner } from '../core/Spinner';
import { ErrorPanel } from '../core/ErrorPanel';

export const TestReportViewer: React.FC = () => {
  const { executionId } = useParams<{ executionId: string }>();
  const navigate = useNavigate();
  const [execution, setExecution] = useState<TestExecution | null>(null);
  const [selectedTestCase, setSelectedTestCase] = useState<string | null>(null);
  const [selectedStep, setSelectedStep] = useState<string | null>(null);
  const [selectedAttachment, setSelectedAttachment] = useState<Attachment | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (executionId) {
      setLoading(true);
      reportingService.getTestExecution(executionId)
        .then(data => {
          setExecution(data);
          if (data.testCases.length > 0) {
            setSelectedTestCase(data.testCases[0].id);
          }
        })
        .catch(err => {
          setError(`Failed to load test execution: ${err.message}`);
        })
        .finally(() => {
          setLoading(false);
        });
    }
  }, [executionId]);

  const handleTestCaseSelect = (testCaseId: string) => {
    setSelectedTestCase(testCaseId);
    setSelectedStep(null);
    setSelectedAttachment(null);
  };

  const handleStepSelect = (stepId: string) => {
    setSelectedStep(stepId);
    setSelectedAttachment(null);
  };

  const handleAttachmentSelect = (attachment: Attachment) => {
    setSelectedAttachment(attachment);
  };

  if (loading) {
    return <Spinner message="Loading test report..." />;
  }

  if (error) {
    return <ErrorPanel message={error} />;
  }

  if (!execution) {
    return <div className="error-message">Test execution not found</div>;
  }

  const getSelectedTestCase = () => {
    return execution.testCases.find(tc => tc.id === selectedTestCase) || null;
  };

  const getSelectedStep = () => {
    const testCase = getSelectedTestCase();
    if (!testCase || !selectedStep) return null;
    return testCase.steps.find(s => s.id === selectedStep) || null;
  };

  const testCase = getSelectedTestCase();
  const step = getSelectedStep();

  return (
    <div className="test-report-viewer">
      <div className="report-header">
        <button className="back-button" onClick={() => navigate(-1)}>
          &larr; Back to Dashboard
        </button>
        <h1>Test Execution Report</h1>
        <div className="execution-meta">
          <div className="execution-id">ID: {execution.id}</div>
          <div className="execution-time">
            {new Date(execution.startTime).toLocaleString()} - 
            {new Date(execution.endTime).toLocaleString()}
          </div>
          <div className="execution-duration">
            Duration: {(execution.duration / 1000).toFixed(2)}s
          </div>
          <div className={`execution-status status-${execution.status.toLowerCase()}`}>
            {execution.status}
          </div>
        </div>
      </div>

      <div className="report-content">
        <div className="test-cases-panel">
          <h2>Test Cases</h2>
          <ul className="test-case-list">
            {execution.testCases.map(tc => (
              <li 
                key={tc.id}
                className={`test-case-item ${tc.id === selectedTestCase ? 'selected' : ''} status-${tc.status.toLowerCase()}`}
                onClick={() => handleTestCaseSelect(tc.id)}
              >
                <span className="test-case-name">{tc.name}</span>
                <span className="test-case-duration">{(tc.duration / 1000).toFixed(2)}s</span>
                <span className="test-case-status">{tc.status}</span>
              </li>
            ))}
          </ul>
        </div>

        {testCase && (
          <div className="test-case-details">
            <div className="test-case-header">
              <h2>{testCase.name}</h2>
              <div className="test-case-meta">
                <div className="feature-name">Feature: {testCase.feature}</div>
                <div className="tags">
                  {testCase.tags.map(tag => (
                    <span key={tag} className="tag">{tag}</span>
                  ))}
                </div>
              </div>
            </div>

            <div className="step-timeline">
              <Timeline 
                items={testCase.steps.map(s => ({
                  id: s.id,
                  label: s.name,
                  startTime: new Date(s.startTime),
                  endTime: new Date(s.endTime),
                  status: s.status.toLowerCase(),
                  onClick: () => handleStepSelect(s.id)
                }))}
                selectedItemId={selectedStep || undefined}
              />
            </div>

            <div className="steps-panel">
              <h3>Steps</h3>
              <ul className="steps-list">
                {testCase.steps.map(s => (
                  <li 
                    key={s.id}
                    className={`step-item ${s.id === selectedStep ? 'selected' : ''} status-${s.status.toLowerCase()}`}
                    onClick={() => handleStepSelect(s.id)}
                  >
                    <span className="step-type">[{s.type}]</span>
                    <span className="step-name">{s.name}</span>
                    <span className="step-duration">{(s.duration / 1000).toFixed(2)}s</span>
                    <span className="step-status">{s.status}</span>
                  </li>
                ))}
              </ul>
            </div>

            {step && (
              <StepDetails 
                step={step} 
                onAttachmentSelect={handleAttachmentSelect} 
              />
            )}
          </div>
        )}
      </div>

      {selectedAttachment && (
        <AttachmentViewer 
          attachment={selectedAttachment} 
          onClose={() => setSelectedAttachment(null)} 
        />
      )}
    </div>
  );
};

// src/components/reporting/AttachmentViewer.tsx
import React from 'react';
import { Attachment } from '../../models/reporting';

interface AttachmentViewerProps {
  attachment: Attachment;
  onClose: () => void;
}

export const AttachmentViewer: React.FC<AttachmentViewerProps> = ({ attachment, onClose }) => {
  const renderContent = () => {
    switch (attachment.type) {
      case 'SCREENSHOT':
        return (
          <div className="screenshot-viewer">
            <img src={attachment.path} alt={attachment.name} />
          </div>
        );
      case 'VIDEO':
        return (
          <div className="video-viewer">
            <video controls>
              <source src={attachment.path} type={attachment.contentType} />
              Your browser does not support the video tag.
            </video>
          </div>
        );
      case 'HTML':
        return (
          <div className="html-viewer">
            <iframe 
              src={attachment.path} 
              title={attachment.name}
              width="100%"
              height="100%"
            />
          </div>
        );
      case 'LOG':
        return (
          <div className="log-viewer">
            <pre>{attachment.content || 'Loading log content...'}</pre>
          </div>
        );
      default:
        return (
          <div className="unknown-attachment">
            <p>Preview not available for this attachment type.</p>
            <a href={attachment.path} download={attachment.name}>Download {attachment.name}</a>
          </div>
        );
    }
  };

  return (
    <div className="attachment-viewer-overlay">
      <div className="attachment-viewer-container">
        <div className="attachment-viewer-header">
          <h3>{attachment.name}</h3>
          <div className="attachment-meta">
            <span>Type: {attachment.type}</span>
            <span>Size: {formatFileSize(attachment.size)}</span>
            <span>Created: {new Date(attachment.timestamp).toLocaleString()}</span>
          </div>
          <button className="close-button" onClick={onClose}>√ó</button>
        </div>
        <div className="attachment-viewer-content">
          {renderContent()}
        </div>
      </div>
    </div>
  );
};

const formatFileSize = (bytes: number): string => {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
};

// src/components/reporting/TrendVisualizer.tsx
import React, { useEffect, useRef } from 'react';
import { Chart, ChartConfiguration } from 'chart.js/auto';

interface TrendVisualizerProps {
  data: {
    labels: string[];
    datasets: {
      label: string;
      data: number[];
      backgroundColor?: string;
      borderColor?: string;
      fill?: boolean;
    }[];
  };
  title?: string;
  type: 'line' | 'bar' | 'pie' | 'doughnut';
  height?: number;
  options?: any;
}

export const TrendVisualizer: React.FC<TrendVisualizerProps> = ({ 
  data, 
  title, 
  type, 
  height = 400,
  options = {}
}) => {
  const chartRef = useRef<HTMLCanvasElement>(null);
  const chartInstance = useRef<Chart | null>(null);

  useEffect(() => {
    if (chartRef.current) {
      // Destroy existing chart if it exists
      if (chartInstance.current) {
        chartInstance.current.destroy();
      }

      // Create new chart
      const ctx = chartRef.current.getContext('2d');
      if (ctx) {
        const config: ChartConfiguration = {
          type,
          data,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: !!title,
                text: title || '',
                font: {
                  size: 16
                }
              },
              legend: {
                position: 'top',
              },
              tooltip: {
                mode: 'index',
                intersect: false,
              }
            },
            ...options
          }
        };

        chartInstance.current = new Chart(ctx, config);
      }
    }

    // Cleanup
    return () => {
      if (chartInstance.current) {
        chartInstance.current.destroy();
      }
    };
  }, [data, title, type, options]);

  return (
    <div className="trend-visualizer" style={{ height: `${height}px` }}>
      <canvas ref={chartRef} />
    </div>
  );
};

// src/components/reporting/MetricsSummary.tsx
import React from 'react';
import { ExecutionMetrics } from '../../models/reporting';

interface MetricsSummaryProps {
  metrics: ExecutionMetrics;
}

export const MetricsSummary: React.FC<MetricsSummaryProps> = ({ metrics }) => {
  const renderMetricCard = (
    title: string,
    value: string | number,
    subtitle?: string,
    icon?: string,
    colorClass?: string
  ) => (
    <div className={`metric-card ${colorClass || ''}`}>
      {icon && <div className="metric-icon">{icon}</div>}
      <div className="metric-content">
        <div className="metric-title">{title}</div>
        <div className="metric-value">{value}</div>
        {subtitle && <div className="metric-subtitle">{subtitle}</div>}
      </div>
    </div>
  );

  return (
    <div className="metrics-summary">
      <div className="metrics-grid">
        {renderMetricCard(
          'Pass Rate',
          `${metrics.passRate.toFixed(1)}%`,
          `${metrics.passedTests} / ${metrics.totalTests}`,
          '‚úì',
          metrics.passRate > 90 ? 'success' : metrics.passRate > 70 ? 'warning' : 'danger'
        )}
        
        {renderMetricCard(
          'Total Tests',
          metrics.totalTests,
          `Across ${Object.keys(metrics.featureDistribution || {}).length} features`,
          'üìä'
        )}
        
        {renderMetricCard(
          'Avg. Duration',
          `${(metrics.averageDuration / 1000).toFixed(1)}s`,
          `Total: ${formatDuration(metrics.totalDuration)}`,
          '‚è±Ô∏è'
        )}
        
        {renderMetricCard(
          'Failed Tests',
          metrics.failedTests,
          `${((metrics.failedTests / metrics.totalTests) * 100).toFixed(1)}%`,
          '‚ùå',
          metrics.failedTests > 0 ? 'danger' : 'neutral'
        )}
        
        {renderMetricCard(
          'Broken Tests',
          metrics.brokenTests,
          `${((metrics.brokenTests / metrics.totalTests) * 100).toFixed(1)}%`,
          '‚ö†Ô∏è',
          metrics.brokenTests > 0 ? 'warning' : 'neutral'
        )}
        
        {renderMetricCard(
          'Skipped Tests',
          metrics.skippedTests,
          `${((metrics.skippedTests / metrics.totalTests) * 100).toFixed(1)}%`,
          '‚è≠Ô∏è'
        )}
      </div>
      
      {metrics.mostFrequentError && (
        <div className="most-frequent-error">
          <h3>Most Frequent Error</h3>
          <div className="error-message">{metrics.mostFrequentError}</div>
        </div>
      )}
    </div>
  );
};

const formatDuration = (ms: number): string => {
  const seconds = Math.floor((ms / 1000) % 60);
  const minutes = Math.floor((ms / (1000 * 60)) % 60);
  const hours = Math.floor(ms / (1000 * 60 * 60));

  if (hours > 0) {
    return `${hours}h ${minutes}m ${seconds}s`;
  }
  if (minutes > 0) {
    return `${minutes}m ${seconds}s`;
  }
  return `${seconds}.${Math.floor((ms % 1000) / 100)}s`;
};

// src/main/java/com/automation/api/services/reporting/ReportingService.java
package com.automation.api.services.reporting;

import com.automation.api.models.reporting.*;
import com.automation.api.services.core.FileSystemService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class ReportingService {

    private final FileSystemService fileSystemService;
    private final ObjectMapper objectMapper;
    private final Map<String, TestExecution> executionCache = new ConcurrentHashMap<>();
    private final Map<String, ExecutionMetrics> metricsCache = new ConcurrentHashMap<>();

    @Autowired
    public ReportingService(FileSystemService fileSystemService, ObjectMapper objectMapper) {
        this.fileSystemService = fileSystemService;
        this.objectMapper = objectMapper;
    }

    public void saveTestExecution(TestExecution execution) throws IOException {
        // Create directory structure if it doesn't exist
        String projectDir = fileSystemService.getProjectReportingPath(execution.getProjectId());
        Path executionDir = Paths.get(projectDir, "executions");
        Path indexPath = Paths.get(projectDir, "index.json");
        
        Files.createDirectories(executionDir);
        
        // Save the execution data
        Path executionPath = Paths.get(executionDir.toString(), execution.getId() + ".json");
        objectMapper.writeValue(executionPath.toFile(), execution);
        
        // Update the index
        List<ExecutionIndex> index;
        if (Files.exists(indexPath)) {
            index = Arrays.asList(objectMapper.readValue(indexPath.toFile(), ExecutionIndex[].class));
        } else {
            index = new ArrayList<>();
        }
        
        // Add to index if not already present
        if (index.stream().noneMatch(e -> e.getId().equals(execution.getId()))) {
            ExecutionIndex indexEntry = new ExecutionIndex(
                execution.getId(),
                execution.getStartTime(),
                execution.getEndTime(),
                execution.getDuration(),
                execution.getStatus(),
                execution.getEnvironment(),
                execution.getBrowser(),
                execution.getTestCases().size(),
                (int) execution.getTestCases().stream().filter(tc -> tc.getStatus().equals("PASSED")).count(),
                (int) execution.getTestCases().stream().filter(tc -> tc.getStatus().equals("FAILED")).count(),
                (int) execution.getTestCases().stream().filter(tc -> tc.getStatus().equals("BROKEN")).count(),
                (int) execution.getTestCases().stream().filter(tc -> tc.getStatus().equals("SKIPPED")).count()
            );
            
            List<ExecutionIndex> updatedIndex = new ArrayList<>(index);
            updatedIndex.add(indexEntry);
            objectMapper.writeValue(indexPath.toFile(), updatedIndex);
        }
        
        // Invalidate cache
        executionCache.remove(execution.getId());
        metricsCache.remove(execution.getProjectId());
    }

    public TestExecution getTestExecution(String executionId) throws IOException {
        // Check cache first
        if (executionCache.containsKey(executionId)) {
            return executionCache.get(executionId);
        }
        
        // Find the execution file
        TestExecution execution = null;
        for (String projectId : fileSystemService.listProjects()) {
            Path executionPath = Paths.get(
                fileSystemService.getProjectReportingPath(projectId),
                "executions",
                executionId + ".json"
            );
            
            if (Files.exists(executionPath)) {
                execution = objectMapper.readValue(executionPath.toFile(), TestExecution.class);
                break;
            }
        }
        
        if (execution == null) {
            throw new IOException("Test execution not found: " + executionId);
        }
        
        // Cache and return
        executionCache.put(executionId, execution);
        return execution;
    }

    public List<ExecutionIndex> getExecutions(
        String projectId, 
        LocalDate startDate, 
        LocalDate endDate
    ) throws IOException {
        Path indexPath = Paths.get(
            fileSystemService.getProjectReportingPath(projectId),
            "index.json"
        );
        
        if (!Files.exists(indexPath)) {
            return Collections.emptyList();
        }
        
        List<ExecutionIndex> allExecutions = Arrays.asList(
            objectMapper.readValue(indexPath.toFile(), ExecutionIndex[].class)
        );
        
        // Filter by date range
        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.plusDays(1).atStartOfDay();
        
        return allExecutions.stream()
            .filter(e -> {
                LocalDateTime executionTime = 
                    LocalDateTime.ofInstant(e.getStartTime().toInstant(), ZoneId.systemDefault());
                return (executionTime.isEqual(startDateTime) || executionTime.isAfter(startDateTime)) 
                    && executionTime.isBefore(endDateTime);
            })
            .sorted(Comparator.comparing(ExecutionIndex::getStartTime).reversed())
            .collect(Collectors.toList());
    }

    public ExecutionMetrics getMetrics(
        String projectId, 
        LocalDate startDate, 
        LocalDate endDate
    ) throws IOException {
        // Generate cache key
        String cacheKey = String.format(
            "%s_%s_%s", 
            projectId, 
            startDate.toString(), 
            endDate.toString()
        );
        
        // Check cache
        if (metricsCache.containsKey(cacheKey)) {
            return metricsCache.get(cacheKey);
        }
        
        List<ExecutionIndex> executions = getExecutions(projectId, startDate, endDate);
        
        if (executions.isEmpty()) {
            return new ExecutionMetrics();
        }
        
        // Calculate basic metrics
        int totalTests = executions.stream().mapToInt(ExecutionIndex::getTotalTests).sum();
        int passedTests = executions.stream().mapToInt(ExecutionIndex::getPassedTests).sum();
        int failedTests = executions.stream().mapToInt(ExecutionIndex::getFailedTests).sum();
        int brokenTests = executions.stream().mapToInt(ExecutionIndex::getBrokenTests).sum();
        int skippedTests = executions.stream().mapToInt(ExecutionIndex::getSkippedTests).sum();
        double passRate = totalTests > 0 ? (double) passedTests / totalTests * 100 : 0;
        long totalDuration = executions.stream().mapToLong(ExecutionIndex::getDuration).sum();
        double avgDuration = executions.stream().mapToDouble(ExecutionIndex::getDuration).average().orElse(0);
        
        // Calculate daily executions for trend
        List<DailyExecutionMetrics> dailyMetrics = calculateDailyMetrics(executions, startDate, endDate);
        
        // Get feature distribution
        Map<String, Integer> featureDistribution = calculateFeatureDistribution(projectId, executions);
        
        // Get browser distribution
        Map<String, Integer> browserDistribution = executions.stream()
            .collect(Collectors.groupingBy(
                ExecutionIndex::getBrowser,
                Collectors.summingInt(ExecutionIndex::getTotalTests)
            ));
        
        // Get environment distribution
        Map<String, Integer> environmentDistribution = executions.stream()
            .collect(Collectors.groupingBy(
                ExecutionIndex::getEnvironment,
                Collectors.summingInt(ExecutionIndex::getTotalTests)
            ));
        
        // Analyze errors to find most frequent
        String mostFrequentError = findMostFrequentError(projectId, executions);
        
        // Find slowest and fastest tests
        TestExecutionStats slowestTest = findSlowestTest(projectId, executions);
        TestExecutionStats fastestTest = findFastestTest(projectId, executions);
        
        // Gather tag distribution
        Map<String, Integer> tagDistribution = calculateTagDistribution(projectId, executions);
        
        // Analyze errors
        List<ErrorStats> errorDistribution = calculateErrorDistribution(projectId, executions);
        
        // Create metrics object
        ExecutionMetrics metrics = new ExecutionMetrics();
        metrics.setTotalTests(totalTests);
        metrics.setPassedTests(passedTests);
        metrics.setFailedTests(failedTests);
        metrics.setBrokenTests(brokenTests);
        metrics.setSkippedTests(skippedTests);
        metrics.setPassRate(passRate);
        metrics.setTotalDuration(totalDuration);
        metrics.setAverageDuration(avgDuration);
        metrics.setSlowestTest(slowestTest != null ? slowestTest.getName() : null);
        metrics.setFastestTest(fastestTest != null ? fastestTest.getName() : null);
        metrics.setMostFrequentError(mostFrequentError);
        metrics.setBrowserDistribution(browserDistribution);
        metrics.setEnvironmentDistribution(environmentDistribution);
        metrics.setFeatureDistribution(featureDistribution);
        metrics.setTagDistribution(tagDistribution);
        metrics.setDailyExecutions(dailyMetrics);
        metrics.setErrorDistribution(errorDistribution);
        
        // Cache and return
        metricsCache.put(cacheKey, metrics);
        return metrics;
    }

    private List<DailyExecutionMetrics> calculateDailyMetrics(
        List<ExecutionIndex> executions, 
        LocalDate startDate, 
        LocalDate endDate
    ) {
        Map<LocalDate, DailyExecutionMetrics> dailyMap = new HashMap<>();
        
        // Initialize all days in range
        LocalDate currentDate = startDate;
        while (!currentDate.isAfter(endDate)) {
            DailyExecutionMetrics metrics = new DailyExecutionMetrics();
            metrics.setDate(currentDate);
            metrics.setTotalExecutions(0);
            metrics.setTotalTests(0);
            metrics.setPassedTests(0);
            metrics.setFailedTests(0);
            metrics.setBrokenTests(0);
            metrics.setSkippedTests(0);
            metrics.setAverageDuration(0);
            
            dailyMap.put(currentDate, metrics);
            currentDate = currentDate.plusDays(1);
        }
        
        // Fill in data
        for (ExecutionIndex execution : executions) {
            LocalDate execDate = execution.getStartTime().toInstant()
                .atZone(ZoneId.systemDefault())
                .toLocalDate();
            
            if (dailyMap.containsKey(execDate)) {
                DailyExecutionMetrics dayMetrics = dailyMap.get(execDate);
                dayMetrics.setTotalExecutions(dayMetrics.getTotalExecutions() + 1);
                dayMetrics.setTotalTests(dayMetrics.getTotalTests() + execution.getTotalTests());
                dayMetrics.setPassedTests(dayMetrics.getPassedTests() + execution.getPassedTests());
                dayMetrics.setFailedTests(dayMetrics.getFailedTests() + execution.getFailedTests());
                dayMetrics.setBrokenTests(dayMetrics.getBrokenTests() + execution.getBrokenTests());
                dayMetrics.setSkippedTests(dayMetrics.getSkippedTests() + execution.getSkippedTests());
                
                // Recalculate average duration
                double totalDuration = dayMetrics.getAverageDuration() * (dayMetrics.getTotalExecutions() - 1);
                totalDuration += execution.getDuration();
                dayMetrics.setAverageDuration(totalDuration / dayMetrics.getTotalExecutions());
            }
        }
        
        // Convert to sorted list
        return dailyMap.values().stream()
            .sorted(Comparator.comparing(DailyExecutionMetrics::getDate))
            .collect(Collectors.toList());
    }

    private Map<String, Integer> calculateFeatureDistribution(
        String projectId, 
        List<ExecutionIndex> executions
    ) throws IOException {
        Map<String, Integer> distribution = new HashMap<>();
        
        // For each execution, load the full data and count features
        for (ExecutionIndex index : executions) {
            try {
                TestExecution execution = getTestExecution(index.getId());
                
                for (TestCase testCase : execution.getTestCases()) {
                    String feature = testCase.getFeature();
                    distribution.put(feature, distribution.getOrDefault(feature, 0) + 1);
                }
            } catch (IOException e) {
                // Log and continue
                System.err.println("Error loading execution " + index.getId() + ": " + e.getMessage());
            }
        }
        
        return distribution;
    }

    private Map<String, Integer> calculateTagDistribution(
        String projectId, 
        List<ExecutionIndex> executions
    ) throws IOException {
        Map<String, Integer> distribution = new HashMap<>();
        
        // For each execution, load the full data and count tags
        for (ExecutionIndex index : executions) {
            try {
                TestExecution execution = getTestExecution(index.getId());
                
                for (TestCase testCase : execution.getTestCases()) {
                    for (String tag : testCase.getTags()) {
                        distribution.put(tag, distribution.getOrDefault(tag, 0) + 1);
                    }
                }
            } catch (IOException e) {
                // Log and continue
                System.err.println("Error loading execution " + index.getId() + ": " + e.getMessage());
            }
        }
        
        return distribution;
    }

    private String findMostFrequentError(
        String projectId, 
        List<ExecutionIndex> executions
    ) throws IOException {
        Map<String, Integer> errorCounts = new HashMap<>();
        
        // For each execution, load the full data and count errors
        for (ExecutionIndex index : executions) {
            try {
                TestExecution execution = getTestExecution(index.getId());
                
                for (TestCase testCase : execution.getTestCases()) {
                    for (TestStep step : testCase.getSteps()) {
                        if (step.getError() != null) {
                            String errorMessage = step.getError().getMessage();
                            // Normalize error message (remove dynamic parts like timestamps, IDs)
                            errorMessage = normalizeErrorMessage(errorMessage);
                            errorCounts.put(errorMessage, errorCounts.getOrDefault(errorMessage, 0) + 1);
                        }
                    }
                }
            } catch (IOException e) {
                // Log and continue
                System.err.println("Error loading execution " + index.getId() + ": " + e.getMessage());
            }
        }
        
        // Find the most frequent error
        return errorCounts.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
    }

    private String normalizeErrorMessage(String errorMessage) {
        if (errorMessage == null) {
            return "";
        }
        
        // Remove timestamps
        errorMessage = errorMessage.replaceAll("\\d{2}:\\d{2}:\\d{2}\\.\\d+", "TIME");
        
        // Remove specific IDs (GUIDs, etc.)
        errorMessage = errorMessage.replaceAll("[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}", "ID");
        
        // Remove line numbers in stack traces
        errorMessage = errorMessage.replaceAll("line \\d+", "line NUM");
        
        // Remove file paths
        errorMessage = errorMessage.replaceAll("(/[^/]*)+\\.[a-z]+", "FILE");
        
        return errorMessage;
    }

    private TestExecutionStats findSlowestTest(
        String projectId, 
        List<ExecutionIndex> executions
    ) throws IOException {
        TestExecutionStats slowest = null;
        long maxDuration = 0;
        
        // For each execution, load the full data and find slow tests
        for (ExecutionIndex index : executions) {
            try {
                TestExecution execution = getTestExecution(index.getId());
                
                for (TestCase testCase : execution.getTestCases()) {
                    if (testCase.getDuration() > maxDuration) {
                        maxDuration = testCase.getDuration();
                        slowest = new TestExecutionStats(
                            testCase.getId(),
                            testCase.getName(),
                            testCase.getFeature(),
                            testCase.getDuration(),
                            testCase.getStatus()
                        );
                    }
                }
            } catch (IOException e) {
                // Log and continue
                System.err.println("Error loading execution " + index.getId() + ": " + e.getMessage());
            }
        }
        
        return slowest;
    }

    private TestExecutionStats findFastestTest(
        String projectId, 
        List<ExecutionIndex> executions
    ) throws IOException {
        TestExecutionStats fastest = null;
        long minDuration = Long.MAX_VALUE;
        
        // For each execution, load the full data and find fast tests
        for (ExecutionIndex index : executions) {
            try {
                TestExecution execution = getTestExecution(index.getId());
                
                for (TestCase testCase : execution.getTestCases()) {
                    // Only consider passing tests
                    if ("PASSED".equals(testCase.getStatus()) && testCase.getDuration() < minDuration) {
                        minDuration = testCase.getDuration();
                        fastest = new TestExecutionStats(
                            testCase.getId(),
                            testCase.getName(),
                            testCase.getFeature(),
                            testCase.getDuration(),
                            testCase.getStatus()
                        );
                    }
                }
            } catch (IOException e) {
                // Log and continue
                System.err.println("Error loading execution " + index.getId() + ": " + e.getMessage());
            }
        }
        
        return fastest;
    }

    private List<ErrorStats> calculateErrorDistribution(
        String projectId, 
        List<ExecutionIndex> executions
    ) throws IOException {
        Map<String, ErrorStats> errorStatsMap = new HashMap<>();
        
        // For each execution, load the full data and analyze errors
        for (ExecutionIndex index : executions) {
            try {
                TestExecution execution = getTestExecution(index.getId());
                
                for (TestCase testCase : execution.getTestCases()) {
                    for (TestStep step : testCase.getSteps()) {
                        if (step.getError() != null) {
                            String errorMessage = normalizeErrorMessage(step.getError().getMessage());
                            String errorType = step.getError().getType();
                            
                            // Create key from type and message
                            String key = errorType + ": " + errorMessage;
                            
                            ErrorStats stats = errorStatsMap.getOrDefault(key, new ErrorStats());
                            stats.setType(errorType);
                            stats.setMessage(errorMessage);
                            stats.setCount(stats.getCount() + 1);
                            
                            // Add to affected features
                            stats.getAffectedFeatures().add(testCase.getFeature());
                            
                            // Store example
                            if (stats.getExampleId() == null) {
                                stats.setExampleId(execution.getId());
                                stats.setExampleTestCase(testCase.getId());
                                stats.setExampleStep(step.getId());
                            }
                            
                            errorStatsMap.put(key, stats);
                        }
                    }
                }
            } catch (IOException e) {
                // Log and continue
                System.err.println("Error loading execution " + index.getId() + ": " + e.getMessage());
            }
        }
        
        // Convert to sorted list
        return errorStatsMap.values().stream()
            .sorted(Comparator.comparing(ErrorStats::getCount).reversed())
            .collect(Collectors.toList());
    }

    public void exportReport(
        String projectId, 
        LocalDate startDate, 
        LocalDate endDate, 
        String format, 
        String outputPath
    ) throws IOException {
        // Get metrics
        ExecutionMetrics metrics = getMetrics(projectId, startDate, endDate);
        
        // Get executions
        List<ExecutionIndex> executions = getExecutions(projectId, startDate, endDate);
        
        switch (format.toLowerCase()) {
            case "pdf":
                exportPdfReport(projectId, startDate, endDate, metrics, executions, outputPath);
                break;
            case "csv":
                exportCsvReport(projectId, startDate, endDate, metrics, executions, outputPath);
                break;
            case "junit":
                exportJUnitReport(projectId, startDate, endDate, metrics, executions, outputPath);
                break;
            default:
                throw new IllegalArgumentException("Unsupported export format: " + format);
        }
    }

    private void exportPdfReport(
        String projectId, 
        LocalDate startDate, 
        LocalDate endDate, 
        ExecutionMetrics metrics, 
        List<ExecutionIndex> executions,
        String outputPath
    ) throws IOException {
        // PDF generation logic
        // This would typically use a PDF library like iText or Apache PDFBox
        throw new UnsupportedOperationException("PDF export not implemented yet");
    }

    private void exportCsvReport(
        String projectId, 
        LocalDate startDate, 
        LocalDate endDate, 
        ExecutionMetrics metrics, 
        List<ExecutionIndex> executions,
        String outputPath
    ) throws IOException {
        // CSV export logic
        StringBuilder csvBuilder = new StringBuilder();
        
        // Header
        csvBuilder.append("Execution ID,Start Time,End Time,Duration (ms),Status,Environment,Browser,Total Tests,Passed,Failed,Broken,Skipped\n");
        
        // Data
        for (ExecutionIndex execution : executions) {
            csvBuilder.append(String.format("%s,%s,%s,%d,%s,%s,%s,%d,%d,%d,%d,%d\n",
                execution.getId(),
                execution.getStartTime(),
                execution.getEndTime(),
                execution.getDuration(),
                execution.getStatus(),
                execution.getEnvironment(),
                execution.getBrowser(),
                execution.getTotalTests(),
                execution.getPassedTests(),
                execution.getFailedTests(),
                execution.getBrokenTests(),
                execution.getSkippedTests()
            ));
        }
        
        // Write to file
        Files.write(Paths.get(outputPath), csvBuilder.toString().getBytes());
    }

    private void exportJUnitReport(
        String projectId, 
        LocalDate startDate, 
        LocalDate endDate, 
        ExecutionMetrics metrics, 
        List<ExecutionIndex> executions,
        String outputPath
    ) throws IOException {
        // JUnit XML export logic
        // This would create XML files in JUnit format for CI/CD integration
        throw new UnsupportedOperationException("JUnit export not implemented yet");
    }

    public List<Attachment> getTestStepAttachments(
        String executionId, 
        String testCaseId, 
        String stepId
    ) throws IOException {
        TestExecution execution = getTestExecution(executionId);
        
        for (TestCase testCase : execution.getTestCases()) {
            if (testCase.getId().equals(testCaseId)) {
                for (TestStep step : testCase.getSteps()) {
                    if (step.getId().equals(stepId)) {
                        return step.getAttachments();
                    }
                }
            }
        }
        
        return Collections.emptyList();
    }

    public byte[] getAttachmentContent(String executionId, String attachmentId) throws IOException {
        TestExecution execution = getTestExecution(executionId);
        
        // Find the attachment
        for (TestCase testCase : execution.getTestCases()) {
            for (TestStep step : testCase.getSteps()) {
                for (Attachment attachment : step.getAttachments()) {
                    if (attachment.getId().equals(attachmentId)) {
                        // Get the attachment file path
                        Path path = Paths.get(attachment.getPath());
                        if (Files.exists(path)) {
                            return Files.readAllBytes(path);
                        }
                    }
                }
            }
            // Also check test case level attachments
            for (Attachment attachment : testCase.getAttachments()) {
                if (attachment.getId().equals(attachmentId)) {
                    Path path = Paths.get(attachment.getPath());
                    if (Files.exists(path)) {
                        return Files.readAllBytes(path);
                    }
                }
            }
        }
        
        throw new IOException("Attachment not found: " + attachmentId);
    }
}

// src/main/java/com/automation/api/services/reporting/RealTimeReportingService.java
package com.automation.api.services.reporting;

import com.automation.api.models.reporting.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class RealTimeReportingService {

    private final SimpMessagingTemplate messagingTemplate;
    private final ReportingService reportingService;
    private final Map<String, TestExecution> activeExecutions = new ConcurrentHashMap<>();

    @Autowired
    public RealTimeReportingService(
        SimpMessagingTemplate messagingTemplate,
        ReportingService reportingService
    ) {
        this.messagingTemplate = messagingTemplate;
        this.reportingService = reportingService;
    }

    public TestExecution startExecution(
        String projectId,
        String environment,
        String browser
    ) {
        // Create a new test execution
        TestExecution execution = new TestExecution();
        execution.setId(UUID.randomUUID().toString());
        execution.setProjectId(projectId);
        execution.setStartTime(new Date());
        execution.setStatus("RUNNING");
        execution.setEnvironment(environment);
        execution.setBrowser(browser);
        execution.setMetadata(new HashMap<>());
        
        // Store in active executions
        activeExecutions.put(execution.getId(), execution);
        
        // Notify subscribers
        notifyExecutionUpdate(execution);
        
        return execution;
    }

    public TestCase startTestCase(
        String executionId,
        String name,
        String description,
        String feature,
        String[] tags
    ) {
        TestExecution execution = getActiveExecution(executionId);
        
        // Create test case
        TestCase testCase = new TestCase();
        testCase.setId(UUID.randomUUID().toString());
        testCase.setName(name);
        testCase.setDescription(description);
        testCase.setFeature(feature);
        testCase.setTags(tags);
        testCase.setStartTime(new Date());
        testCase.setStatus("RUNNING");
        
        // Add to execution
        execution.getTestCases().add(testCase);
        
        // Notify subscribers
        notifyTestCaseUpdate(execution.getId(), testCase);
        
        return testCase;
    }

    public TestStep startStep(
        String executionId,
        String testCaseId,
        String name,
        String type,
        Map<String, Object> parameters
    ) {
        TestExecution execution = getActiveExecution(executionId);
        TestCase testCase = findTestCase(execution, testCaseId);
        
        // Create step
        TestStep step = new TestStep();
        step.setId(UUID.randomUUID().toString());
        step.setName(name);
        step.setType(type);
        step.setParameters(parameters);
        step.setStartTime(new Date());
        step.setStatus("RUNNING");
        
        // Add to test case
        testCase.getSteps().add(step);
        
        // Notify subscribers
        notifyStepUpdate(execution.getId(), testCase.getId(), step);
        
        return step;
    }

    public void endStep(
        String executionId,
        String testCaseId,
        String stepId,
        String status,
        ErrorInfo error
    ) {
        TestExecution execution = getActiveExecution(executionId);
        TestCase testCase = findTestCase(execution, testCaseId);
        TestStep step = findStep(testCase, stepId);
        
        // Update step
        step.setEndTime(new Date());
        step.setDuration(step.getEndTime().getTime() - step.getStartTime().getTime());
        step.setStatus(status);
        step.setError(error);
        
        // Notify subscribers
        notifyStepUpdate(execution.getId(), testCase.getId(), step);
    }

    public void endTestCase(String executionId, String testCaseId, String status) {
        TestExecution execution = getActiveExecution(executionId);
        TestCase testCase = findTestCase(execution, testCaseId);
        
        // Update test case
        testCase.setEndTime(new Date());
        testCase.setDuration(testCase.getEndTime().getTime() - testCase.getStartTime().getTime());
        testCase.setStatus(status);
        
        // Notify subscribers
        notifyTestCaseUpdate(execution.getId(), testCase);
    }

    public void endExecution(String executionId, String status) {
        TestExecution execution = getActiveExecution(executionId);
        
        // Update execution
        execution.setEndTime(new Date());
        execution.setDuration(execution.getEndTime().getTime() - execution.getStartTime().getTime());
        execution.setStatus(status);
        
        // Save execution
        try {
            reportingService.saveTestExecution(execution);
        } catch (IOException e) {
            // Log error
            System.err.println("Error saving test execution: " + e.getMessage());
        }
        
        // Remove from active executions
        activeExecutions.remove(executionId);
        
        // Notify subscribers
        notifyExecutionUpdate(execution);
    }

    public Attachment addAttachment(
        String executionId,
        String testCaseId,
        String stepId,
        String name,
        String type,
        String contentType,
        String path,
        long size,
        Map<String, Object> metadata
    ) {
        TestExecution execution = getActiveExecution(executionId);
        TestCase testCase = findTestCase(execution, testCaseId);
        TestStep step = findStep(testCase, stepId);
        
        // Create attachment
        Attachment attachment = new Attachment();
        attachment.setId(UUID.randomUUID().toString());
        attachment.setName(name);
        attachment.setType(type);
        attachment.setContentType(contentType);
        attachment.setPath(path);
        attachment.setSize(size);
        attachment.setTimestamp(new Date());
        attachment.setMetadata(metadata);
        
        // Add to step
        step.getAttachments().add(attachment);
        
        // Notify subscribers
        notifyAttachmentUpdate(execution.getId(), testCase.getId(), step.getId(), attachment);
        
        return attachment;
    }

    private TestExecution getActiveExecution(String executionId) {
        TestExecution execution = activeExecutions.get(executionId);
        if (execution == null) {
            throw new IllegalArgumentException("No active execution found with ID: " + executionId);
        }
        return execution;
    }

    private TestCase findTestCase(TestExecution execution, String testCaseId) {
        return execution.getTestCases().stream()
            .filter(tc -> tc.getId().equals(testCaseId))
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("Test case not found: " + testCaseId));
    }

    private TestStep findStep(TestCase testCase, String stepId) {
        return testCase.getSteps().stream()
            .filter(s -> s.getId().equals(stepId))
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("Step not found: " + stepId));
    }

    private void notifyExecutionUpdate(TestExecution execution) {
        messagingTemplate.convertAndSend(
            "/topic/executions/" + execution.getId(),
            execution
        );
    }

    private void notifyTestCaseUpdate(String executionId, TestCase testCase) {
        messagingTemplate.convertAndSend(
            "/topic/executions/" + executionId + "/testcases/" + testCase.getId(),
            testCase
        );
    }

    private void notifyStepUpdate(String executionId, String testCaseId, TestStep step) {
        messagingTemplate.convertAndSend(
            "/topic/executions/" + executionId + "/testcases/" + testCaseId + "/steps/" + step.getId(),
            step
        );
    }

    private void notifyAttachmentUpdate(
        String executionId,
        String testCaseId,
        String stepId,
        Attachment attachment
    ) {
        messagingTemplate.convertAndSend(
            "/topic/executions/" + executionId + "/testcases/" + testCaseId + "/steps/" + stepId + "/attachments/" + attachment.getId(),
            attachment
        );
    }
}

// src/main/java/com/automation/api/services/integration/ado/ADOConnectionService.java
package com.automation.api.services.integration.ado;

import com.automation.api.models.integration.ado.ADOConnection;
import com.automation.api.services.core.EncryptionService;
import com.automation.api.services.core.FileSystemService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class ADOConnectionService {

    private final FileSystemService fileSystemService;
    private final EncryptionService encryptionService;
    private final ObjectMapper objectMapper;
    private final RestTemplate restTemplate;
    private final Map<String, ADOConnection> connections = new ConcurrentHashMap<>();

    @Autowired
    public ADOConnectionService(
        FileSystemService fileSystemService,
        EncryptionService encryptionService,
        ObjectMapper objectMapper
    ) {
        this.fileSystemService = fileSystemService;
        this.encryptionService = encryptionService;
        this.objectMapper = objectMapper;
        this.restTemplate = new RestTemplate();
        
        loadConnections();
    }

    private void loadConnections() {
        try {
            Path connectionsDir = Paths.get(fileSystemService.getApplicationDataPath(), "ado_connections");
            Files.createDirectories(connectionsDir);
            
            Files.list(connectionsDir)
                .filter(path -> path.toString().endsWith(".json"))
                .forEach(path -> {
                    try {
                        ADOConnection connection = objectMapper.readValue(path.toFile(), ADOConnection.class);
                        // Decrypt PAT
                        connection.setPat(encryptionService.decrypt(connection.getPat()));
                        connections.put(connection.getId(), connection);
                    } catch (IOException e) {
                        System.err.println("Error loading ADO connection: " + e.getMessage());
                    }
                });
        } catch (IOException e) {
            System.err.println("Error loading ADO connections: " + e.getMessage());
        }
    }

    private void saveConnection(ADOConnection connection) throws IOException {
        // Encrypt PAT before saving
        String encryptedPat = encryptionService.encrypt(connection.getPat());
        ADOConnection connectionToSave = new ADOConnection(connection);
        connectionToSave.setPat(encryptedPat);
        
        Path connectionsDir = Paths.get(fileSystemService.getApplicationDataPath(), "ado_connections");
        Files.createDirectories(connectionsDir);
        
        Path connectionFile = connectionsDir.resolve(connection.getId() + ".json");
        objectMapper.writeValue(connectionFile.toFile(), connectionToSave);
        
        // Update cache
        connections.put(connection.getId(), connection);
    }

    public List<ADOConnection> getConnections() {
        return new ArrayList<>(connections.values());
    }

    public ADOConnection getConnection(String connectionId) {
        return connections.get(connectionId);
    }

    public ADOConnection createConnection(ADOConnection connection) throws IOException {
        // Generate ID if not provided
        if (connection.getId() == null || connection.getId().isEmpty()) {
            connection.setId(UUID.randomUUID().toString());
        }
        
        // Test connection
        boolean isValid = testConnection(connection);
        connection.setStatus(isValid ? "Connected" : "Error");
        
        // Save connection
        saveConnection(connection);
        
        return connection;
    }

    public ADOConnection updateConnection(String connectionId, ADOConnection connection) throws IOException {
        if (!connections.containsKey(connectionId)) {
            throw new IllegalArgumentException("Connection not found: " + connectionId);
        }
        
        connection.setId(connectionId);
        
        // Test connection
        boolean isValid = testConnection(connection);
        connection.setStatus(isValid ? "Connected" : "Error");
        
        // Save connection
        saveConnection(connection);
        
        return connection;
    }

    public void deleteConnection(String connectionId) throws IOException {
        if (!connections.containsKey(connectionId)) {
            throw new IllegalArgumentException("Connection not found: " + connectionId);
        }
        
        // Delete file
        Path connectionsDir = Paths.get(fileSystemService.getApplicationDataPath(), "ado_connections");
        Path connectionFile = connectionsDir.resolve(connectionId + ".json");
        Files.deleteIfExists(connectionFile);
        
        // Remove from cache
        connections.remove(connectionId);
    }

    public boolean testConnection(ADOConnection connection) {
        try {
            // Make a simple API call to verify connection
            String url = String.format(
                "%s/%s/_apis/projects?api-version=7.0",
                connection.getUrl(),
                connection.getOrganization()
            );
            
            HttpHeaders headers = createHeaders(connection.getPat());
            headers.setContentType(MediaType.APPLICATION_JSON);
            
            HttpEntity<String> entity = new HttpEntity<>(headers);
            
            ResponseEntity<Map> response = restTemplate.exchange(
                url,
                HttpMethod.GET,
                entity,
                Map.class
            );
            
            return response.getStatusCode().is2xxSuccessful();
        } catch (RestClientException e) {
            connection.setErrorMessage(e.getMessage());
            return false;
        }
    }

    public List<Map<String, Object>> getProjects(String connectionId) {
        ADOConnection connection = getConnection(connectionId);
        if (connection == null) {
            throw new IllegalArgumentException("Connection not found: " + connectionId);
        }
        
        String url = String.format(
            "%s/%s/_apis/projects?api-version=7.0",
            connection.getUrl(),
            connection.getOrganization()
        );
        
        HttpHeaders headers = createHeaders(connection.getPat());
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<String> entity = new HttpEntity<>(headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            url,
            HttpMethod.GET,
            entity,
            Map.class
        );
        
        Map<String, Object> responseBody = response.getBody();
        if (responseBody != null && responseBody.containsKey("value")) {
            return (List<Map<String, Object>>) responseBody.get("value");
        }
        
        return Collections.emptyList();
    }

    public List<Map<String, Object>> getTeams(String connectionId, String projectName) {
        ADOConnection connection = getConnection(connectionId);
        if (connection == null) {
            throw new IllegalArgumentException("Connection not found: " + connectionId);
        }
        
        String url = String.format(
            "%s/%s/_apis/projects/%s/teams?api-version=7.0",
            connection.getUrl(),
            connection.getOrganization(),
            projectName
        );
        
        HttpHeaders headers = createHeaders(connection.getPat());
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<String> entity = new HttpEntity<>(headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            url,
            HttpMethod.GET,
            entity,
            Map.class
        );
        
        Map<String, Object> responseBody = response.getBody();
        if (responseBody != null && responseBody.containsKey("value")) {
            return (List<Map<String, Object>>) responseBody.get("value");
        }
        
        return Collections.emptyList();
    }

    public HttpHeaders createHeaders(String pat) {
        String auth = ":" + pat;
        byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes());
        String authHeader = "Basic " + new String(encodedAuth);
        
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", authHeader);
        return headers;
    }

    public ADORestClient createRestClient(String connectionId) {
        ADOConnection connection = getConnection(connectionId);
        if (connection == null) {
            throw new IllegalArgumentException("Connection not found: " + connectionId);
        }
        
        return new ADORestClient(
            connection.getUrl(),
            connection.getOrganization(),
            connection.getProject(),
            connection.getPat()
        );
    }
}

// src/main/java/com/automation/api/services/integration/ado/ADORestClient.java
package com.automation.api.services.integration.ado;

import org.springframework.http.*;
import org.springframework.web.client.RestTemplate;

import java.util.Base64;
import java.util.Map;

public class ADORestClient {

    private final String baseUrl;
    private final String organization;
    private final String project;
    private final String pat;
    private final RestTemplate restTemplate;

    public ADORestClient(String baseUrl, String organization, String project, String pat) {
        this.baseUrl = baseUrl;
        this.organization = organization;
        this.project = project;
        this.pat = pat;
        this.restTemplate = new RestTemplate();
    }

    public <T> ResponseEntity<T> get(String path, Class<T> responseType) {
        return exchange(path, HttpMethod.GET, null, responseType);
    }

    public <T> ResponseEntity<T> post(String path, Object body, Class<T> responseType) {
        return exchange(path, HttpMethod.POST, body, responseType);
    }

    public <T> ResponseEntity<T> put(String path, Object body, Class<T> responseType) {
        return exchange(path, HttpMethod.PUT, body, responseType);
    }

    public <T> ResponseEntity<T> patch(String path, Object body, Class<T> responseType) {
        return exchange(path, HttpMethod.PATCH, body, responseType);
    }

    public <T> ResponseEntity<T> delete(String path, Class<T> responseType) {
        return exchange(path, HttpMethod.DELETE, null, responseType);
    }

    private <T> ResponseEntity<T> exchange(
        String path, 
        HttpMethod method, 
        Object body, 
        Class<T> responseType
    ) {
        String url = buildUrl(path);
        
        HttpHeaders headers = createHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<?> entity = new HttpEntity<>(body, headers);
        
        return restTemplate.exchange(url, method, entity, responseType);
    }

    private String buildUrl(String path) {
        String apiBase = String.format("%s/%s", baseUrl, organization);
        
        if (path.startsWith("_apis")) {
            // Organization-level API
            return String.format("%s/%s", apiBase, path);
        } else {
            // Project-level API
            return String.format("%s/%s/%s", apiBase, project, path);
        }
    }

    private HttpHeaders createHeaders() {
        String auth = ":" + pat;
        byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes());
        String authHeader = "Basic " + new String(encodedAuth);
        
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", authHeader);
        return headers;
    }
}

// src/main/java/com/automation/api/services/integration/ado/ADOTestPlanService.java
package com.automation.api.services.integration.ado;

import com.automation.api.models.integration.ado.*;
import com.automation.api.models.project.TestCase;
import com.automation.api.models.project.TestStep;
import com.automation.api.services.core.FileSystemService;
import com.automation.api.services.project.TestCaseService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class ADOTestPlanService {

    private final ADOConnectionService connectionService;
    private final TestCaseService testCaseService;
    private final FileSystemService fileSystemService;
    private final Map<String, TestCaseMapping> testCaseMappings = new HashMap<>();

    @Autowired
    public ADOTestPlanService(
        ADOConnectionService connectionService,
        TestCaseService testCaseService,
        FileSystemService fileSystemService
    ) {
        this.connectionService = connectionService;
        this.testCaseService = testCaseService;
        this.fileSystemService = fileSystemService;
        
        loadTestCaseMappings();
    }

    private void loadTestCaseMappings() {
        // Load mappings from file system
        // Implementation details omitted for brevity
    }

    private void saveTestCaseMappings() {
        // Save mappings to file system
        // Implementation details omitted for brevity
    }

    public List<ADOTestPlan> getTestPlans(String connectionId) {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        ResponseEntity<Map> response = client.get(
            "_apis/test/plans?api-version=7.0",
            Map.class
        );
        
        List<ADOTestPlan> testPlans = new ArrayList<>();
        
        if (response.getBody() != null && response.getBody().containsKey("value")) {
            List<Map<String, Object>> plans = (List<Map<String, Object>>) response.getBody().get("value");
            
            for (Map<String, Object> plan : plans) {
                ADOTestPlan testPlan = new ADOTestPlan();
                testPlan.setId(((Number) plan.get("id")).intValue());
                testPlan.setName((String) plan.get("name"));
                testPlans.add(testPlan);
            }
        }
        
        return testPlans;
    }

    public ADOTestPlan getTestPlan(String connectionId, int planId) {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        ResponseEntity<Map> response = client.get(
            String.format("_apis/test/plans/%d?api-version=7.0", planId),
            Map.class
        );
        
        if (response.getBody() != null) {
            Map<String, Object> plan = response.getBody();
            
            ADOTestPlan testPlan = new ADOTestPlan();
            testPlan.setId(((Number) plan.get("id")).intValue());
            testPlan.setName((String) plan.get("name"));
            
            // Load suites
            testPlan.setSuites(getTestSuites(connectionId, planId));
            
            return testPlan;
        }
        
        return null;
    }

    public List<ADOTestSuite> getTestSuites(String connectionId, int planId) {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        ResponseEntity<Map> response = client.get(
            String.format("_apis/test/plans/%d/suites?api-version=7.0", planId),
            Map.class
        );
        
        List<ADOTestSuite> testSuites = new ArrayList<>();
        
        if (response.getBody() != null && response.getBody().containsKey("value")) {
            List<Map<String, Object>> suites = (List<Map<String, Object>>) response.getBody().get("value");
            
            for (Map<String, Object> suite : suites) {
                ADOTestSuite testSuite = new ADOTestSuite();
                testSuite.setId(((Number) suite.get("id")).intValue());
                testSuite.setName((String) suite.get("name"));
                
                if (suite.containsKey("parentSuite")) {
                    Map<String, Object> parentSuite = (Map<String, Object>) suite.get("parentSuite");
                    testSuite.setParentId(((Number) parentSuite.get("id")).intValue());
                }
                
                testSuites.add(testSuite);
            }
        }
        
        // Build hierarchy
        Map<Integer, ADOTestSuite> suiteMap = testSuites.stream()
            .collect(Collectors.toMap(ADOTestSuite::getId, suite -> suite));
        
        List<ADOTestSuite> rootSuites = new ArrayList<>();
        
        for (ADOTestSuite suite : testSuites) {
            if (suite.getParentId() == null) {
                rootSuites.add(suite);
            } else {
                ADOTestSuite parent = suiteMap.get(suite.getParentId());
                if (parent != null) {
                    if (parent.getChildSuites() == null) {
                        parent.setChildSuites(new ArrayList<>());
                    }
                    parent.getChildSuites().add(suite);
                }
            }
        }
        
        return rootSuites;
    }

    public List<ADOTestCase> getTestCases(String connectionId, int planId, int suiteId) {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        ResponseEntity<Map> response = client.get(
            String.format("_apis/test/plans/%d/suites/%d/testcases?api-version=7.0", planId, suiteId),
            Map.class
        );
        
        List<ADOTestCase> testCases = new ArrayList<>();
        
        if (response.getBody() != null && response.getBody().containsKey("value")) {
            List<Map<String, Object>> cases = (List<Map<String, Object>>) response.getBody().get("value");
            
            for (Map<String, Object> caseData : cases) {
                int testCaseId = ((Number) caseData.get("id")).intValue();
                
                // Get full test case details
                ADOTestCase testCase = getTestCase(connectionId, testCaseId);
                if (testCase != null) {
                    testCases.add(testCase);
                }
            }
        }
        
        return testCases;
    }

    public ADOTestCase getTestCase(String connectionId, int testCaseId) {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        // Get work item
        ResponseEntity<Map> response = client.get(
            String.format("_apis/wit/workitems/%d?api-version=7.0&$expand=all", testCaseId),
            Map.class
        );
        
        if (response.getBody() != null) {
            Map<String, Object> workItem = response.getBody();
            Map<String, Object> fields = (Map<String, Object>) workItem.get("fields");
            
            ADOTestCase testCase = new ADOTestCase();
            testCase.setId(testCaseId);
            testCase.setName((String) fields.getOrDefault("System.Title", ""));
            testCase.setState((String) fields.getOrDefault("System.State", ""));
            
            // Parse priority
            Object priorityObj = fields.get("Microsoft.VSTS.Common.Priority");
            if (priorityObj instanceof Number) {
                testCase.setPriority(((Number) priorityObj).intValue());
            }
            
            // Parse area path
            testCase.setAreaPath((String) fields.getOrDefault("System.AreaPath", ""));
            
            // Parse iteration path
            testCase.setIterationPath((String) fields.getOrDefault("System.IterationPath", ""));
            
            // Parse work item type
            testCase.setWorkItemType((String) fields.getOrDefault("System.WorkItemType", ""));
            
            // Parse tags
            String tagsString = (String) fields.getOrDefault("System.Tags", "");
            testCase.setTags(Arrays.asList(tagsString.split("\\s*;\\s*")));
            
            // Parse automation status
            String automationStatus = (String) fields.getOrDefault("Microsoft.VSTS.TCM.AutomationStatus", "Not Automated");
            testCase.setAutomationStatus(automationStatus);
            
            // Parse test steps
            String stepsHtml = (String) fields.getOrDefault("Microsoft.VSTS.TCM.Steps", "");
            List<ADOTestStep> steps = parseTestSteps(stepsHtml);
            testCase.setSteps(steps);
            
            // Parse attachments
            testCase.setAttachments(new ArrayList<>());
            
            return testCase;
        }
        
        return null;
    }

    private List<ADOTestStep> parseTestSteps(String stepsHtml) {
        List<ADOTestStep> steps = new ArrayList<>();
        
        // Simple parsing of steps HTML
        // In a real implementation, use a proper HTML parser
        
        // Example step HTML format:
        // <steps id="0">
        //   <step id="1" type="ActionStep">
        //     <parameterizedString isformatted="true">Action 1</parameterizedString>
        //     <parameterizedString isformatted="true">Expected 1</parameterizedString>
        //   </step>
        //   <step id="2" type="ActionStep">
        //     <parameterizedString isformatted="true">Action 2</parameterizedString>
        //     <parameterizedString isformatted="true">Expected 2</parameterizedString>
        //   </step>
        // </steps>
        
        if (stepsHtml == null || stepsHtml.isEmpty()) {
            return steps;
        }
        
        // Very basic parsing for demonstration
        String[] stepTags = stepsHtml.split("<step id=\"");
        
        for (int i = 1; i < stepTags.length; i++) {
            String stepContent = stepTags[i];
            
            int idEnd = stepContent.indexOf("\"");
            int stepId = Integer.parseInt(stepContent.substring(0, idEnd));
            
            String[] paramStrings = stepContent.split("<parameterizedString");
            
            String action = "";
            String expectedResult = "";
            
            if (paramStrings.length > 1) {
                int actionStart = paramStrings[1].indexOf(">") + 1;
                int actionEnd = paramStrings[1].indexOf("</parameterizedString>");
                action = paramStrings[1].substring(actionStart, actionEnd);
            }
            
            if (paramStrings.length > 2) {
                int resultStart = paramStrings[2].indexOf(">") + 1;
                int resultEnd = paramStrings[2].indexOf("</parameterizedString>");
                expectedResult = paramStrings[2].substring(resultStart, resultEnd);
            }
            
            ADOTestStep step = new ADOTestStep();
            step.setId(stepId);
            step.setAction(action);
            step.setExpectedResult(expectedResult);
            
            steps.add(step);
        }
        
        return steps;
    }

    public List<TestCase> importTestCases(
        String projectId,
        String connectionId,
        int planId,
        int suiteId
    ) throws IOException {
        // Get ADO test cases
        List<ADOTestCase> adoTestCases = getTestCases(connectionId, planId, suiteId);
        
        List<TestCase> importedTestCases = new ArrayList<>();
        
        for (ADOTestCase adoTestCase : adoTestCases) {
            // Convert ADO test case to local test case
            TestCase testCase = convertToLocalTestCase(adoTestCase);
            
            // Save test case
            testCase = testCaseService.saveTestCase(projectId, testCase);
            
            // Create mapping
            TestCaseMapping mapping = new TestCaseMapping();
            mapping.setLocalId(testCase.getId());
            mapping.setAdoId(adoTestCase.getId());
            mapping.setName(adoTestCase.getName());
            mapping.setLastSyncedLocal(new Date());
            mapping.setLastSyncedADO(new Date());
            mapping.setSyncStatus("InSync");
            
            testCaseMappings.put(testCase.getId(), mapping);
            
            importedTestCases.add(testCase);
        }
        
        // Save mappings
        saveTestCaseMappings();
        
        return importedTestCases;
    }

    private TestCase convertToLocalTestCase(ADOTestCase adoTestCase) {
        TestCase testCase = new TestCase();
        testCase.setId(UUID.randomUUID().toString());
        testCase.setName(adoTestCase.getName());
        testCase.setDescription("Imported from Azure DevOps");
        
        // Set tags
        testCase.setTags(new ArrayList<>(adoTestCase.getTags()));
        
        // Convert steps
        List<TestStep> steps = new ArrayList<>();
        
        for (ADOTestStep adoStep : adoTestCase.getSteps()) {
            TestStep step = new TestStep();
            step.setId(UUID.randomUUID().toString());
            step.setType("ACTION"); // Default type
            step.setName(adoStep.getAction());
            
            // Add step parameters based on ADO expected result
            Map<String, Object> params = new HashMap<>();
            params.put("expectedResult", adoStep.getExpectedResult());
            step.setParameters(params);
            
            steps.add(step);
        }
        
        testCase.setSteps(steps);
        
        return testCase;
    }

    public ADOTestCase createTestCase(String connectionId, ADOTestCase testCase) {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        // Create work item
        Map<String, Object> requestBody = new HashMap<>();
        List<Map<String, Object>> operations = new ArrayList<>();
        
        // Add fields
        operations.add(createJsonPatchOperation(
            "add", "/fields/System.Title", testCase.getName()));
        
        operations.add(createJsonPatchOperation(
            "add", "/fields/System.Description", "Created from test automation tool"));
        
        operations.add(createJsonPatchOperation(
            "add", "/fields/Microsoft.VSTS.TCM.AutomationStatus", testCase.getAutomationStatus()));
        
        if (testCase.getPriority() > 0) {
            operations.add(createJsonPatchOperation(
                "add", "/fields/Microsoft.VSTS.Common.Priority", testCase.getPriority()));
        }
        
        if (testCase.getTags() != null && !testCase.getTags().isEmpty()) {
            String tagsString = String.join("; ", testCase.getTags());
            operations.add(createJsonPatchOperation(
                "add", "/fields/System.Tags", tagsString));
        }
        
        // Add steps
        String stepsHtml = generateStepsHtml(testCase.getSteps());
        operations.add(createJsonPatchOperation(
            "add", "/fields/Microsoft.VSTS.TCM.Steps", stepsHtml));
        
        // Make API call
        ResponseEntity<Map> response = client.patch(
            "_apis/wit/workitems/$Test Case?api-version=7.0",
            operations,
            Map.class
        );
        
        // Parse response
        if (response.getBody() != null) {
            int id = ((Number) response.getBody().get("id")).intValue();
            testCase.setId(id);
            return testCase;
        }
        
        return null;
    }

    private Map<String, Object> createJsonPatchOperation(String op, String path, Object value) {
        Map<String, Object> operation = new HashMap<>();
        operation.put("op", op);
        operation.put("path", path);
        operation.put("value", value);
        return operation;
    }

    private String generateStepsHtml(List<ADOTestStep> steps) {
        StringBuilder html = new StringBuilder();
        html.append("<steps id=\"0\">");
        
        int stepId = 1;
        for (ADOTestStep step : steps) {
            html.append("<step id=\"").append(stepId).append("\" type=\"ActionStep\">");
            
            html.append("<parameterizedString isformatted=\"true\">");
            html.append(escapeHtml(step.getAction()));
            html.append("</parameterizedString>");
            
            html.append("<parameterizedString isformatted=\"true\">");
            html.append(escapeHtml(step.getExpectedResult()));
            html.append("</parameterizedString>");
            
            html.append("</step>");
            
            stepId++;
        }
        
        html.append("</steps>");
        return html.toString();
    }

    private String escapeHtml(String text) {
        if (text == null) {
            return "";
        }
        
        return text.replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&#39;");
    }

    public TestCaseMapping getTestCaseMapping(String localTestCaseId) {
        return testCaseMappings.get(localTestCaseId);
    }

    public void updateTestCaseMapping(TestCaseMapping mapping) {
        testCaseMappings.put(mapping.getLocalId(), mapping);
        saveTestCaseMappings();
    }
}

// src/main/java/com/automation/api/services/integration/ado/ADOTestResultService.java
package com.automation.api.services.integration.ado;

import com.automation.api.models.integration.ado.*;
import com.automation.api.models.reporting.TestExecution;
import com.automation.api.models.reporting.TestCase;
import com.automation.api.models.reporting.TestStep;
import com.automation.api.models.reporting.Attachment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;

@Service
public class ADOTestResultService {

    private final ADOConnectionService connectionService;
    private final ADOTestPlanService testPlanService;

    @Autowired
    public ADOTestResultService(
        ADOConnectionService connectionService,
        ADOTestPlanService testPlanService
    ) {
        this.connectionService = connectionService;
        this.testPlanService = testPlanService;
    }

    public ADOTestRun publishTestResults(
        String connectionId,
        TestExecution execution,
        Integer testPlanId
    ) throws IOException {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        // Create test run
        Map<String, Object> runRequest = new HashMap<>();
        runRequest.put("name", "Automated Test Run - " + execution.getId());
        runRequest.put("state", "InProgress");
        
        if (testPlanId != null) {
            runRequest.put("plan", new HashMap<String, Object>() {{
                put("id", testPlanId);
            }});
        }
        
        ResponseEntity<Map> runResponse = client.post(
            "_apis/test/runs?api-version=7.0",
            runRequest,
            Map.class
        );
        
        if (runResponse.getBody() == null) {
            throw new IOException("Failed to create test run");
        }
        
        int runId = ((Number) runResponse.getBody().get("id")).intValue();
        
        // Create test results
        List<Map<String, Object>> results = new ArrayList<>();
        
        for (TestCase testCase : execution.getTestCases()) {
            // Check if test case has ADO mapping
            TestCaseMapping mapping = testPlanService.getTestCaseMapping(testCase.getId());
            
            if (mapping != null) {
                results.add(createTestResult(testCase, mapping.getAdoId()));
            } else {
                // If no mapping exists, create result without test case reference
                results.add(createTestResult(testCase, null));
            }
        }
        
        // Submit results
        Map<String, Object> resultsRequest = new HashMap<>();
        resultsRequest.put("results", results);
        
        ResponseEntity<Map> resultsResponse = client.post(
            String.format("_apis/test/runs/%d/results?api-version=7.0", runId),
            resultsRequest,
            Map.class
        );
        
        // Upload attachments
        if (resultsResponse.getBody() != null && resultsResponse.getBody().containsKey("value")) {
            List<Map<String, Object>> resultsList = (List<Map<String, Object>>) resultsResponse.getBody().get("value");
            
            for (int i = 0; i < resultsList.size(); i++) {
                Map<String, Object> resultData = resultsList.get(i);
                int resultId = ((Number) resultData.get("id")).intValue();
                TestCase testCase = execution.getTestCases().get(i);
                
                uploadAttachments(client, runId, resultId, testCase);
            }
        }
        
        // Complete test run
        Map<String, Object> updateRequest = new HashMap<>();
        updateRequest.put("state", "Completed");
        
        ResponseEntity<Map> updateResponse = client.patch(
            String.format("_apis/test/runs/%d?api-version=7.0", runId),
            updateRequest,
            Map.class
        );
        
        // Return test run
        int testRunId = ((Number) updateResponse.getBody().get("id")).intValue();
        return getTestRun(connectionId, testRunId);
    }

    private Map<String, Object> createTestResult(TestCase testCase, Integer adoTestCaseId) {
        Map<String, Object> result = new HashMap<>();
        
        if (adoTestCaseId != null) {
            result.put("testCase", new HashMap<String, Object>() {{
                put("id", adoTestCaseId);
            }});
        }
        
        result.put("testCaseTitle", testCase.getName());
        result.put("outcome", mapTestStatus(testCase.getStatus()));
        result.put("state", "Completed");
        result.put("startedDate", testCase.getStartTime());
        result.put("completedDate", testCase.getEndTime());
        result.put("durationInMs", testCase.getDuration());
        
        // Add error message if test failed
        if ("Failed".equals(mapTestStatus(testCase.getStatus()))) {
            // Find first failed step
            for (TestStep step : testCase.getSteps()) {
                if ("FAILED".equals(step.getStatus()) && step.getError() != null) {
                    result.put("errorMessage", step.getError().getMessage());
                    if (step.getError().getStackTrace() != null) {
                        result.put("stackTrace", step.getError().getStackTrace());
                    }
                    break;
                }
            }
        }
        
        // Add step results
        List<Map<String, Object>> stepResults = new ArrayList<>();
        
        for (TestStep step : testCase.getSteps()) {
            Map<String, Object> stepResult = new HashMap<>();
            stepResult.put("outcome", mapTestStatus(step.getStatus()));
            stepResult.put("stepIdentifier", step.getId());
            stepResult.put("title", step.getName());
            
            if ("FAILED".equals(step.getStatus()) && step.getError() != null) {
                stepResult.put("errorMessage", step.getError().getMessage());
            }
            
            stepResults.add(stepResult);
        }
        
        result.put("actionResults", stepResults);
        
        return result;
    }

    private String mapTestStatus(String status) {
        switch (status) {
            case "PASSED":
                return "Passed";
            case "FAILED":
                return "Failed";
            case "BROKEN":
                return "Failed";
            case "SKIPPED":
                return "NotExecuted";
            default:
                return "NotExecuted";
        }
    }

    private void uploadAttachments(
        ADORestClient client,
        int runId,
        int resultId,
        TestCase testCase
    ) throws IOException {
        // Upload test case attachments
        for (Attachment attachment : testCase.getAttachments()) {
            uploadAttachment(client, runId, resultId, attachment);
        }
        
        // Upload step attachments
        for (TestStep step : testCase.getSteps()) {
            for (Attachment attachment : step.getAttachments()) {
                uploadAttachment(client, runId, resultId, attachment);
            }
        }
    }

    private void uploadAttachment(
        ADORestClient client,
        int runId,
        int resultId,
        Attachment attachment
    ) throws IOException {
        // Read attachment file
        File file = new File(attachment.getPath());
        if (!file.exists()) {
            return;
        }
        
        byte[] fileContent = Files.readAllBytes(file.toPath());
        
        // Create attachment
        Map<String, Object> attachmentRequest = new HashMap<>();
        attachmentRequest.put("fileName", attachment.getName());
        attachmentRequest.put("comment", "Test attachment");
        attachmentRequest.put("attachmentType", mapAttachmentType(attachment.getType()));
        
        ResponseEntity<Map> response = client.post(
            String.format("_apis/test/runs/%d/results/%d/attachments?api-version=7.0", runId, resultId),
            attachmentRequest,
            Map.class
        );
        
        if (response.getBody() != null && response.getBody().containsKey("url")) {
            String uploadUrl = (String) response.getBody().get("url");
            
            // Upload content
            // This is a simplified version - in a real implementation, you would need to
            // handle the file upload properly
            client.post(uploadUrl, fileContent, Map.class);
        }
    }

    private String mapAttachmentType(String type) {
        switch (type) {
            case "SCREENSHOT":
                return "ScreenShot";
            case "VIDEO":
                return "GeneralAttachment";
            case "LOG":
                return "TestLog";
            default:
                return "GeneralAttachment";
        }
    }

    public ADOTestRun getTestRun(String connectionId, int runId) {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        ResponseEntity<Map> response = client.get(
            String.format("_apis/test/runs/%d?api-version=7.0", runId),
            Map.class
        );
        
        if (response.getBody() != null) {
            Map<String, Object> runData = response.getBody();
            
            ADOTestRun testRun = new ADOTestRun();
            testRun.setId(runId);
            testRun.setName((String) runData.get("name"));
            testRun.setState((String) runData.get("state"));
            testRun.setStartedDate(parseDate(runData.get("startedDate")));
            testRun.setCompletedDate(parseDate(runData.get("completedDate")));
            
            if (runData.containsKey("plan")) {
                Map<String, Object> plan = (Map<String, Object>) runData.get("plan");
                testRun.setTestPlanId(((Number) plan.get("id")).intValue());
            }
            
            if (runData.containsKey("build")) {
                Map<String, Object> build = (Map<String, Object>) runData.get("build");
                testRun.setBuildId(((Number) build.get("id")).intValue());
            }
            
            if (runData.containsKey("release")) {
                Map<String, Object> release = (Map<String, Object>) runData.get("release");
                testRun.setReleaseId(((Number) release.get("id")).intValue());
            }
            
            // Get test results
            testRun.setResults(getTestResults(connectionId, runId));
            
            return testRun;
        }
        
        return null;
    }

    private List<ADOTestResult> getTestResults(String connectionId, int runId) {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        ResponseEntity<Map> response = client.get(
            String.format("_apis/test/runs/%d/results?api-version=7.0", runId),
            Map.class
        );
        
        List<ADOTestResult> results = new ArrayList<>();
        
        if (response.getBody() != null && response.getBody().containsKey("value")) {
            List<Map<String, Object>> resultsList = (List<Map<String, Object>>) response.getBody().get("value");
            
            for (Map<String, Object> resultData : resultsList) {
                ADOTestResult result = new ADOTestResult();
                result.setId(((Number) resultData.get("id")).intValue());
                
                if (resultData.containsKey("testCase")) {
                    Map<String, Object> testCase = (Map<String, Object>) resultData.get("testCase");
                    result.setTestCaseId(((Number) testCase.get("id")).intValue());
                }
                
                result.setOutcome((String) resultData.get("outcome"));
                result.setStartedDate(parseDate(resultData.get("startedDate")));
                result.setCompletedDate(parseDate(resultData.get("completedDate")));
                result.setDuration(((Number) resultData.getOrDefault("durationInMs", 0)).longValue());
                result.setErrorMessage((String) resultData.get("errorMessage"));
                result.setStackTrace((String) resultData.get("stackTrace"));
                
                // Get step results and attachments
                // Implementation details omitted for brevity
                
                results.add(result);
            }
        }
        
        return results;
    }

    private Date parseDate(Object dateObj) {
        if (dateObj == null) {
            return null;
        }
        
        if (dateObj instanceof String) {
            // Parse ISO date string
            try {
                return new Date(Date.parse((String) dateObj));
            } catch (Exception e) {
                return null;
            }
        }
        
        return null;
    }
}


// src/main/java/com/automation/api/services/integration/git/GitRepositoryService.java
package com.automation.api.services.integration.git;

import com.automation.api.models.integration.git.*;
import com.automation.api.services.core.EncryptionService;
import com.automation.api.services.core.FileSystemService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.eclipse.jgit.api.*;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.lib.*;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
import org.eclipse.jgit.transport.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Service
public class GitRepositoryService {

    private final FileSystemService fileSystemService;
    private final EncryptionService encryptionService;
    private final ObjectMapper objectMapper;
    private final Map<String, GitRepository> repositories = new ConcurrentHashMap<>();
    private final Map<String, Git> gitInstances = new ConcurrentHashMap<>();

    @Autowired
    public GitRepositoryService(
        FileSystemService fileSystemService,
        EncryptionService encryptionService,
        ObjectMapper objectMapper
    ) {
        this.fileSystemService = fileSystemService;
        this.encryptionService = encryptionService;
        this.objectMapper = objectMapper;
        
        loadRepositories();
    }

    private void loadRepositories() {
        try {
            Path reposDir = Paths.get(fileSystemService.getApplicationDataPath(), "git_repositories");
            Files.createDirectories(reposDir);
            
            Files.list(reposDir)
                .filter(path -> path.toString().endsWith(".json"))
                .forEach(path -> {
                    try {
                        GitRepository repository = objectMapper.readValue(path.toFile(), GitRepository.class);
                        repositories.put(repository.getId(), repository);
                        
                        // Initialize Git instance
                        try {
                            openRepository(repository.getId());
                        } catch (Exception e) {
                            repository.setStatus("Error");
                            repository.setErrorMessage("Failed to open repository: " + e.getMessage());
                        }
                    } catch (IOException e) {
                        System.err.println("Error loading Git repository: " + e.getMessage());
                    }
                });
        } catch (IOException e) {
            System.err.println("Error loading Git repositories: " + e.getMessage());
        }
    }

    private void saveRepository(GitRepository repository) throws IOException {
        Path reposDir = Paths.get(fileSystemService.getApplicationDataPath(), "git_repositories");
        Files.createDirectories(reposDir);
        
        Path repoFile = reposDir.resolve(repository.getId() + ".json");
        objectMapper.writeValue(repoFile.toFile(), repository);
        
        // Update cache
        repositories.put(repository.getId(), repository);
    }

    public List<GitRepository> getRepositories() {
        return new ArrayList<>(repositories.values());
    }

    public GitRepository getRepository(String repositoryId) {
        return repositories.get(repositoryId);
    }

    public GitRepository initRepository(String projectId, String name) throws IOException, GitAPIException {
        String projectPath = fileSystemService.getProjectPath(projectId);
        File projectDir = new File(projectPath);
        
        // Check if already a git repository
        if (new File(projectDir, ".git").exists()) {
            throw new IllegalStateException("Project directory is already a Git repository");
        }
        
        // Initialize repository
        Git git = Git.init().setDirectory(projectDir).call();
        
        // Create repository object
        GitRepository repository = new GitRepository();
        repository.setId(UUID.randomUUID().toString());
        repository.setName(name);
        repository.setPath(projectPath);
        repository.setDefaultBranch("master");
        repository.setCurrentBranch("master");
        repository.setStatus("Clean");
        repository.setRemotes(new ArrayList<>());
        
        // Set up .gitignore
        setupGitIgnore(projectDir);
        
        // Initial commit
        git.add().addFilepattern(".").call();
        git.commit().setMessage("Initial commit").call();
        
        // Save repository configuration
        saveRepository(repository);
        
        // Add to cache
        gitInstances.put(repository.getId(), git);
        
        return repository;
    }

    public GitRepository cloneRepository(
        String projectId,
        String name,
        String url,
        String username,
        String password,
        String branch
    ) throws IOException, GitAPIException {
        String projectPath = fileSystemService.getProjectPath(projectId);
        File projectDir = new File(projectPath);
        
        // Check if directory exists and is empty
        if (!projectDir.exists()) {
            Files.createDirectories(projectDir.toPath());
        } else if (projectDir.list().length > 0) {
            throw new IllegalStateException("Project directory is not empty");
        }
        
        // Clone repository
        CloneCommand cloneCommand = Git.cloneRepository()
            .setURI(url)
            .setDirectory(projectDir);
            
        if (branch != null && !branch.isEmpty()) {
            cloneCommand.setBranch(branch);
        }
        
        if (username != null && !username.isEmpty()) {
            UsernamePasswordCredentialsProvider credentialsProvider = 
                new UsernamePasswordCredentialsProvider(username, password);
            cloneCommand.setCredentialsProvider(credentialsProvider);
        }
        
        Git git = cloneCommand.call();
        
        // Get current branch
        String currentBranch = git.getRepository().getBranch();
        
        // Create repository object
        GitRepository repository = new GitRepository();
        repository.setId(UUID.randomUUID().toString());
        repository.setName(name);
        repository.setPath(projectPath);
        repository.setDefaultBranch(currentBranch);
        repository.setCurrentBranch(currentBranch);
        repository.setStatus("Clean");
        
        // Add remote
        List<GitRemote> remotes = new ArrayList<>();
        GitRemote remote = new GitRemote();
        remote.setName("origin");
        remote.setUrl(url);
        
        if (username != null && !username.isEmpty()) {
            remote.setUsername(username);
            remote.setAuthType("HTTPS");
        } else {
            remote.setAuthType("None");
        }
        
        remotes.add(remote);
        repository.setRemotes(remotes);
        
        // Save repository configuration
        saveRepository(repository);
        
        // Add to cache
        gitInstances.put(repository.getId(), git);
        
        return repository;
    }

    public GitRepository openRepository(String repositoryId) throws IOException, GitAPIException {
        GitRepository repository = repositories.get(repositoryId);
        if (repository == null) {
            throw new IllegalArgumentException("Repository not found: " + repositoryId);
        }
        
        // Check if already open
        if (gitInstances.containsKey(repositoryId)) {
            return repository;
        }
        
        // Open repository
        File repoDir = new File(repository.getPath());
        FileRepositoryBuilder builder = new FileRepositoryBuilder();
        Repository jgitRepo = builder.setGitDir(new File(repoDir, ".git"))
            .readEnvironment()
            .findGitDir()
            .build();
        
        Git git = new Git(jgitRepo);
        
        // Update current branch
        String currentBranch = jgitRepo.getBranch();
        repository.setCurrentBranch(currentBranch);
        
        // Update status
        updateRepositoryStatus(repository, git);
        
        // Save repository configuration
        saveRepository(repository);
        
        // Add to cache
        gitInstances.put(repositoryId, git);
        
        return repository;
    }

    public void closeRepository(String repositoryId) {
        Git git = gitInstances.get(repositoryId);
        if (git != null) {
            git.close();
            gitInstances.remove(repositoryId);
        }
    }

    public GitRepository addRemote(
        String repositoryId,
        String name,
        String url,
        String username,
        String authType
    ) throws IOException, GitAPIException {
        GitRepository repository = openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        // Check if remote already exists
        List<GitRemote> remotes = repository.getRemotes();
        for (GitRemote remote : remotes) {
            if (remote.getName().equals(name)) {
                throw new IllegalArgumentException("Remote already exists: " + name);
            }
        }
        
        // Add remote
        git.remoteAdd()
            .setName(name)
            .setUri(new URIish(url))
            .call();
        
        // Add to repository object
        GitRemote remote = new GitRemote();
        remote.setName(name);
        remote.setUrl(url);
        remote.setUsername(username);
        remote.setAuthType(authType);
        
        remotes.add(remote);
        
        // Save repository configuration
        saveRepository(repository);
        
        return repository;
    }

    public GitRepository removeRemote(String repositoryId, String remoteName) throws IOException, GitAPIException {
        GitRepository repository = openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        // Remove remote
        git.remoteRemove()
            .setRemoteName(remoteName)
            .call();
        
        // Remove from repository object
        List<GitRemote> remotes = repository.getRemotes();
        remotes.removeIf(remote -> remote.getName().equals(remoteName));
        
        // Save repository configuration
        saveRepository(repository);
        
        return repository;
    }

    public List<GitFileStatus> getStatus(String repositoryId) throws IOException, GitAPIException {
        openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        Status status = git.status().call();
        List<GitFileStatus> fileStatuses = new ArrayList<>();
        
        // Add untracked files
        for (String file : status.getUntracked()) {
            GitFileStatus fileStatus = new GitFileStatus();
            fileStatus.setPath(file);
            fileStatus.setStatus("Untracked");
            fileStatuses.add(fileStatus);
        }
        
        // Add modified files
        for (String file : status.getModified()) {
            GitFileStatus fileStatus = new GitFileStatus();
            fileStatus.setPath(file);
            fileStatus.setStatus("Modified");
            fileStatuses.add(fileStatus);
        }
        
        // Add added files
        for (String file : status.getAdded()) {
            GitFileStatus fileStatus = new GitFileStatus();
            fileStatus.setPath(file);
            fileStatus.setStatus("Added");
            fileStatus.setStagedStatus("Added");
            fileStatuses.add(fileStatus);
        }
        
        // Add changed files
        for (String file : status.getChanged()) {
            GitFileStatus fileStatus = new GitFileStatus();
            fileStatus.setPath(file);
            fileStatus.setStatus("Modified");
            fileStatus.setStagedStatus("Modified");
            fileStatuses.add(fileStatus);
        }
        
        // Add removed files
        for (String file : status.getRemoved()) {
            GitFileStatus fileStatus = new GitFileStatus();
            fileStatus.setPath(file);
            fileStatus.setStatus("Deleted");
            fileStatus.setStagedStatus("Deleted");
            fileStatuses.add(fileStatus);
        }
        
        // Add missing files
        for (String file : status.getMissing()) {
            GitFileStatus fileStatus = new GitFileStatus();
            fileStatus.setPath(file);
            fileStatus.setStatus("Deleted");
            fileStatuses.add(fileStatus);
        }
        
        // Add conflicting files
        for (String file : status.getConflicting()) {
            GitFileStatus fileStatus = new GitFileStatus();
            fileStatus.setPath(file);
            fileStatus.setStatus("Conflicted");
            fileStatuses.add(fileStatus);
        }
        
        return fileStatuses;
    }

    public void stageFiles(String repositoryId, List<String> filePaths) throws IOException, GitAPIException {
        openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        AddCommand addCommand = git.add();
        for (String path : filePaths) {
            addCommand.addFilepattern(path);
        }
        addCommand.call();
        
        // Update repository status
        GitRepository repository = repositories.get(repositoryId);
        updateRepositoryStatus(repository, git);
        saveRepository(repository);
    }

    public void unstageFiles(String repositoryId, List<String> filePaths) throws IOException, GitAPIException {
        openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        ResetCommand resetCommand = git.reset();
        for (String path : filePaths) {
            resetCommand.addPath(path);
        }
        resetCommand.call();
        
        // Update repository status
        GitRepository repository = repositories.get(repositoryId);
        updateRepositoryStatus(repository, git);
        saveRepository(repository);
    }

    public GitCommit commit(String repositoryId, String message, String authorName, String authorEmail) 
            throws IOException, GitAPIException {
        openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        // Commit
        RevCommit commit = git.commit()
            .setMessage(message)
            .setAuthor(authorName, authorEmail)
            .call();
        
        // Update repository status
        GitRepository repository = repositories.get(repositoryId);
        updateRepositoryStatus(repository, git);
        saveRepository(repository);
        
        // Return commit info
        return convertCommit(commit);
    }

    public List<GitBranch> getBranches(String repositoryId) throws IOException, GitAPIException {
        openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        List<GitBranch> branches = new ArrayList<>();
        
        // Get current branch
        String currentBranch = git.getRepository().getBranch();
        
        // Get local branches
        List<Ref> localBranchRefs = git.branchList().call();
        for (Ref ref : localBranchRefs) {
            String name = Repository.shortenRefName(ref.getName());
            
            GitBranch branch = new GitBranch();
            branch.setName(name);
            branch.setFullName(ref.getName());
            branch.setRemote(false);
            branch.setCurrent(name.equals(currentBranch));
            branch.setLatestCommit(ref.getObjectId().name());
            
            branches.add(branch);
        }
        
        // Get remote branches
        List<Ref> remoteBranchRefs = git.branchList().setListMode(ListBranchCommand.ListMode.REMOTE).call();
        for (Ref ref : remoteBranchRefs) {
            String fullName = ref.getName();
            String name = Repository.shortenRefName(fullName);
            
            // Extract remote name
            String remoteName = fullName.substring("refs/remotes/".length(), fullName.indexOf('/', "refs/remotes/".length()));
            
            GitBranch branch = new GitBranch();
            branch.setName(name);
            branch.setFullName(fullName);
            branch.setRemote(true);
            branch.setRemoteName(remoteName);
            branch.setCurrent(false);
            branch.setLatestCommit(ref.getObjectId().name());
            
            branches.add(branch);
        }
        
        // Calculate ahead/behind counts for local branches
        for (GitBranch branch : branches) {
            if (!branch.isRemote()) {
                // Find tracking branch
                for (GitBranch remoteBranch : branches) {
                    if (remoteBranch.isRemote() && remoteBranch.getName().equals(branch.getName())) {
                        branch.setTrackingBranch(remoteBranch.getFullName());
                        
                        // Calculate ahead/behind
                        BranchTrackingStatus trackingStatus = BranchTrackingStatus.of(
                            git.getRepository(), branch.getName());
                        
                        if (trackingStatus != null) {
                            branch.setAheadCount(trackingStatus.getAheadCount());
                            branch.setBehindCount(trackingStatus.getBehindCount());
                        }
                        
                        break;
                    }
                }
            }
        }
        
        return branches;
    }

    public GitBranch createBranch(String repositoryId, String branchName, boolean checkout) 
            throws IOException, GitAPIException {
        openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        // Create branch
        git.branchCreate()
            .setName(branchName)
            .call();
        
        // Checkout if requested
        if (checkout) {
            git.checkout()
                .setName(branchName)
                .call();
            
            // Update current branch
            GitRepository repository = repositories.get(repositoryId);
            repository.setCurrentBranch(branchName);
            saveRepository(repository);
        }
        
        // Get branch info
        List<GitBranch> branches = getBranches(repositoryId);
        return branches.stream()
            .filter(b -> b.getName().equals(branchName) && !b.isRemote())
            .findFirst()
            .orElse(null);
    }

    public GitBranch checkoutBranch(String repositoryId, String branchName) 
            throws IOException, GitAPIException {
        openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        // Checkout branch
        git.checkout()
            .setName(branchName)
            .call();
        
        // Update current branch
        GitRepository repository = repositories.get(repositoryId);
        repository.setCurrentBranch(branchName);
        updateRepositoryStatus(repository, git);
        saveRepository(repository);
        
        // Get branch info
        List<GitBranch> branches = getBranches(repositoryId);
        return branches.stream()
            .filter(b -> b.getName().equals(branchName) && !b.isRemote())
            .findFirst()
            .orElse(null);
    }

    public List<GitCommit> getCommitHistory(String repositoryId, int maxCount) 
            throws IOException, GitAPIException {
        openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        List<GitCommit> commits = new ArrayList<>();
        
        // Get commits
        Iterable<RevCommit> revCommits = git.log()
            .setMaxCount(maxCount)
            .call();
        
        for (RevCommit revCommit : revCommits) {
            GitCommit commit = convertCommit(revCommit);
            commits.add(commit);
        }
        
        return commits;
    }

    public PushResult push(
        String repositoryId,
        String remoteName,
        String branchName,
        String username,
        String password
    ) throws IOException, GitAPIException {
        openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        // Create push command
        PushCommand pushCommand = git.push()
            .setRemote(remoteName)
            .setRefSpecs(new RefSpec(branchName + ":" + branchName));
        
        // Set credentials if provided
        if (username != null && !username.isEmpty()) {
            pushCommand.setCredentialsProvider(
                new UsernamePasswordCredentialsProvider(username, password));
        }
        
        // Push
        Iterable<PushResult> results = pushCommand.call();
        PushResult result = results.iterator().next();
        
        // Update repository status
        GitRepository repository = repositories.get(repositoryId);
        updateRepositoryStatus(repository, git);
        saveRepository(repository);
        
        return result;
    }

    public PullResult pull(
        String repositoryId,
        String remoteName,
        String username,
        String password
    ) throws IOException, GitAPIException {
        openRepository(repositoryId);
        Git git = gitInstances.get(repositoryId);
        
        // Create pull command
        PullCommand pullCommand = git.pull()
            .setRemote(remoteName);
        
        // Set credentials if provided
        if (username != null && !username.isEmpty()) {
            pullCommand.setCredentialsProvider(
                new UsernamePasswordCredentialsProvider(username, password));
        }
        
        // Pull
        PullResult result = pullCommand.call();
        
        // Update repository status
        GitRepository repository = repositories.get(repositoryId);
        updateRepositoryStatus(repository, git);
        saveRepository(repository);
        
        return result;
    }

    private void setupGitIgnore(File projectDir) throws IOException {
        File gitignore = new File(projectDir, ".gitignore");
        
        if (!gitignore.exists()) {
            List<String> ignorePatterns = Arrays.asList(
                "# IDE files",
                ".idea/",
                "*.iml",
                ".vscode/",
                "*.suo",
                "*.ntvs*",
                "*.njsproj",
                "*.sln",
                "*.sw?",
                "",
                "# Build output",
                "target/",
                "build/",
                "dist/",
                "out/",
                "bin/",
                "",
                "# Dependencies",
                "node_modules/",
                ".npm/",
                "",
                "# Logs",
                "logs/",
                "*.log",
                "",
                "# OS files",
                ".DS_Store",
                "Thumbs.db",
                "",
                "# Test reports",
                "test-results/",
                "coverage/",
                "",
                "# Environment",
                ".env",
                ".env.local",
                "*.env.development.local",
                "*.env.test.local",
                "*.env.production.local"
            );
            
            Files.write(gitignore.toPath(), ignorePatterns);
        }
    }

    private void updateRepositoryStatus(GitRepository repository, Git git) throws GitAPIException {
        Status status = git.status().call();
        
        if (!status.isClean()) {
            if (status.getConflicting().isEmpty()) {
                repository.setStatus("Modified");
            } else {
                repository.setStatus("Conflicted");
            }
        } else {
            repository.setStatus("Clean");
        }
        
        repository.setLastSync(new Date());
        repository.setErrorMessage(null);
    }

    private GitCommit convertCommit(RevCommit revCommit) {
        GitCommit commit = new GitCommit();
        commit.setId(revCommit.getName());
        commit.setShortId(revCommit.getName().substring(0, 7));
        commit.setMessage(revCommit.getFullMessage());
        commit.setAuthor(revCommit.getAuthorIdent().getName());
        commit.setAuthorEmail(revCommit.getAuthorIdent().getEmailAddress());
        commit.setAuthorDate(new Date(revCommit.getAuthorIdent().getWhen().getTime()));
        commit.setCommitter(revCommit.getCommitterIdent().getName());
        commit.setCommitterEmail(revCommit.getCommitterIdent().getEmailAddress());
        commit.setCommitDate(new Date(revCommit.getCommitterIdent().getWhen().getTime()));
        
        // Set parents
        List<String> parents = new ArrayList<>();
        for (RevCommit parent : revCommit.getParents()) {
            parents.add(parent.getName());
        }
        commit.setParents(parents);
        
        return commit;
    }
}

// src/main/java/com/automation/api/services/integration/git/GitSynchronizationService.java
package com.automation.api.services.integration.git;

import com.automation.api.models.integration.git.*;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.MergeResult;
import org.eclipse.jgit.api.PullResult;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.transport.PushResult;
import org.eclipse.jgit.transport.RemoteRefUpdate;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

@Service
public class GitSynchronizationService {

    private final GitRepositoryService repositoryService;
    private final GitCredentialService credentialService;
    private final Executor executor = Executors.newFixedThreadPool(5);

    @Autowired
    public GitSynchronizationService(
        GitRepositoryService repositoryService,
        GitCredentialService credentialService
    ) {
        this.repositoryService = repositoryService;
        this.credentialService = credentialService;
    }

    public CompletableFuture<SyncResult> synchronize(String repositoryId) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Open repository
                GitRepository repository = repositoryService.openRepository(repositoryId);
                
                if (repository.getRemotes().isEmpty()) {
                    return new SyncResult(false, "No remotes configured", null, null);
                }
                
                // Get default remote
                GitRemote remote = repository.getRemotes().get(0);
                
                // Get credentials
                String username = null;
                String password = null;
                
                if (remote.getAuthType().equals("HTTPS") || remote.getAuthType().equals("PAT")) {
                    if (remote.getCredentialId() != null) {
                        GitCredential credential = credentialService.getCredential(remote.getCredentialId());
                        if (credential != null) {
                            username = credential.getUsername();
                            password = credential.getPassword();
                        }
                    } else if (remote.getUsername() != null) {
                        username = remote.getUsername();
                        // Password would need to be provided by the user
                    }
                }
                
                // Pull first
                PullResult pullResult = repositoryService.pull(
                    repositoryId, 
                    remote.getName(), 
                    username, 
                    password
                );
                
                // Check for conflicts
                if (pullResult.getMergeResult() != null && 
                    pullResult.getMergeResult().getMergeStatus() == MergeResult.MergeStatus.CONFLICTING) {
                    return new SyncResult(
                        false, 
                        "Merge conflicts detected", 
                        pullResult, 
                        null
                    );
                }
                
                // Push changes
                PushResult pushResult = repositoryService.push(
                    repositoryId, 
                    remote.getName(), 
                    repository.getCurrentBranch(), 
                    username, 
                    password
                );
                
                // Check push results
                boolean success = true;
                String message = "Synchronization completed";
                
                Collection<RemoteRefUpdate> updates = pushResult.getRemoteUpdates();
                for (RemoteRefUpdate update : updates) {
                    if (update.getStatus() != RemoteRefUpdate.Status.OK && 
                        update.getStatus() != RemoteRefUpdate.Status.UP_TO_DATE) {
                        success = false;
                        message = "Push failed: " + update.getStatus().name();
                        break;
                    }
                }
                
                return new SyncResult(success, message, pullResult, pushResult);
                
            } catch (IOException | GitAPIException e) {
                return new SyncResult(false, e.getMessage(), null, null);
            }
        }, executor);
    }

    public CompletableFuture<List<GitBranch>> fetchRemotes(String repositoryId) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Open repository
                GitRepository repository = repositoryService.openRepository(repositoryId);
                
                if (repository.getRemotes().isEmpty()) {
                    return repositoryService.getBranches(repositoryId);
                }
                
                // Get git instance
                Git git = repositoryService.getGitInstance(repositoryId);
                
                // Fetch from all remotes
                for (GitRemote remote : repository.getRemotes()) {
                    // Get credentials
                    String username = null;
                    String password = null;
                    
                    if (remote.getAuthType().equals("HTTPS") || remote.getAuthType().equals("PAT")) {
                        if (remote.getCredentialId() != null) {
                            GitCredential credential = credentialService.getCredential(remote.getCredentialId());
                            if (credential != null) {
                                username = credential.getUsername();
                                password = credential.getPassword();
                            }
                        } else if (remote.getUsername() != null) {
                            username = remote.getUsername();
                            // Password would need to be provided by the user
                        }
                    }
                    
                    // Fetch
                    git.fetch()
                        .setRemote(remote.getName())
                        .setCredentialsProvider(
                            username != null 
                                ? new UsernamePasswordCredentialsProvider(username, password) 
                                : null
                        )
                        .call();
                }
                
                // Return updated branches
                return repositoryService.getBranches(repositoryId);
                
            } catch (IOException | GitAPIException e) {
                throw new RuntimeException("Failed to fetch remotes: " + e.getMessage(), e);
            }
        }, executor);
    }

    public static class SyncResult {
        private final boolean success;
        private final String message;
        private final PullResult pullResult;
        private final PushResult pushResult;
        
        public SyncResult(boolean success, String message, PullResult pullResult, PushResult pushResult) {
            this.success = success;
            this.message = message;
            this.pullResult = pullResult;
            this.pushResult = pushResult;
        }
        
        public boolean isSuccess() {
            return success;
        }
        
        public String getMessage() {
            return message;
        }
        
        public PullResult getPullResult() {
            return pullResult;
        }
        
        public PushResult getPushResult() {
            return pushResult;
        }
    }
}

// src/main/java/com/automation/api/services/integration/git/GitCredentialService.java
package com.automation.api.services.integration.git;

import com.automation.api.models.integration.git.GitCredential;
import com.automation.api.services.core.EncryptionService;
import com.automation.api.services.core.FileSystemService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class GitCredentialService {

    private final FileSystemService fileSystemService;
    private final EncryptionService encryptionService;
    private final ObjectMapper objectMapper;
    private final Map<String, GitCredential> credentials = new ConcurrentHashMap<>();

    @Autowired
    public GitCredentialService(
        FileSystemService fileSystemService,
        EncryptionService encryptionService,
        ObjectMapper objectMapper
    ) {
        this.fileSystemService = fileSystemService;
        this.encryptionService = encryptionService;
        this.objectMapper = objectMapper;
        
        loadCredentials();
    }

    private void loadCredentials() {
        try {
            Path credsDir = Paths.get(fileSystemService.getApplicationDataPath(), "git_credentials");
            Files.createDirectories(credsDir);
            
            Files.list(credsDir)
                .filter(path -> path.toString().endsWith(".json"))
                .forEach(path -> {
                    try {
                        GitCredential credential = objectMapper.readValue(path.toFile(), GitCredential.class);
                        
                        // Decrypt sensitive data
                        if (credential.getPassword() != null) {
                            credential.setPassword(encryptionService.decrypt(credential.getPassword()));
                        }
                        
                        if (credential.getPrivateKey() != null) {
                            credential.setPrivateKey(encryptionService.decrypt(credential.getPrivateKey()));
                        }
                        
                        if (credential.getPassphrase() != null) {
                            credential.setPassphrase(encryptionService.decrypt(credential.getPassphrase()));
                        }
                        
                        credentials.put(credential.getId(), credential);
                    } catch (IOException e) {
                        System.err.println("Error loading Git credential: " + e.getMessage());
                    }
                });
        } catch (IOException e) {
            System.err.println("Error loading Git credentials: " + e.getMessage());
        }
    }

    private void saveCredential(GitCredential credential) throws IOException {
        // Create a copy for saving to encrypt sensitive data
        GitCredential credentialToSave = new GitCredential(credential);
        
        // Encrypt sensitive data
        if (credentialToSave.getPassword() != null) {
            credentialToSave.setPassword(encryptionService.encrypt(credentialToSave.getPassword()));
        }
        
        if (credentialToSave.getPrivateKey() != null) {
            credentialToSave.setPrivateKey(encryptionService.encrypt(credentialToSave.getPrivateKey()));
        }
        
        if (credentialToSave.getPassphrase() != null) {
            credentialToSave.setPassphrase(encryptionService.encrypt(credentialToSave.getPassphrase()));
        }
        
        Path credsDir = Paths.get(fileSystemService.getApplicationDataPath(), "git_credentials");
        Files.createDirectories(credsDir);
        
        Path credFile = credsDir.resolve(credential.getId() + ".json");
        objectMapper.writeValue(credFile.toFile(), credentialToSave);
        
        // Update cache
        credentials.put(credential.getId(), credential);
    }

    public List<GitCredential> getCredentials() {
        // Create copies without sensitive data
        List<GitCredential> result = new ArrayList<>();
        
        for (GitCredential credential : credentials.values()) {
            GitCredential copy = new GitCredential(credential);
            copy.setPassword(null);
            copy.setPrivateKey(null);
            copy.setPassphrase(null);
            result.add(copy);
        }
        
        return result;
    }

    public GitCredential getCredential(String credentialId) {
        return credentials.get(credentialId);
    }

    public GitCredential createCredential(GitCredential credential) throws IOException {
        // Generate ID if not provided
        if (credential.getId() == null || credential.getId().isEmpty()) {
            credential.setId(UUID.randomUUID().toString());
        }
        
        // Save credential
        saveCredential(credential);
        
        return credential;
    }

    public GitCredential updateCredential(String credentialId, GitCredential credential) throws IOException {
        if (!credentials.containsKey(credentialId)) {
            throw new IllegalArgumentException("Credential not found: " + credentialId);
        }
        
        credential.setId(credentialId);
        
        // Save credential
        saveCredential(credential);
        
        return credential;
    }

    public void deleteCredential(String credentialId) throws IOException {
        if (!credentials.containsKey(credentialId)) {
            throw new IllegalArgumentException("Credential not found: " + credentialId);
        }
        
        // Delete file
        Path credsDir = Paths.get(fileSystemService.getApplicationDataPath(), "git_credentials");
        Path credFile = credsDir.resolve(credentialId + ".json");
        Files.deleteIfExists(credFile);
        
        // Remove from cache
        credentials.remove(credentialId);
    }
}


// src/components/integration/git/GitRepositoryManager.tsx
import React, { useState, useEffect } from 'react';
import { useProjectContext } from '../../../contexts/ProjectContext';
import { gitService } from '../../../services/api/gitService';
import { GitRepository, GitBranch, GitFileStatus } from '../../../models/integration/git';
import { RepositoryList } from './RepositoryList';
import { RepositoryDetails } from './RepositoryDetails';
import { InitRepositoryModal } from './InitRepositoryModal';
import { CloneRepositoryModal } from './CloneRepositoryModal';
import { Button, Spinner, ErrorPanel } from '../../core';
import { toast } from 'react-toastify';

export const GitRepositoryManager: React.FC = () => {
  const { projectId } = useProjectContext();
  const [repositories, setRepositories] = useState<GitRepository[]>([]);
  const [selectedRepository, setSelectedRepository] = useState<GitRepository | null>(null);
  const [isInitModalOpen, setIsInitModalOpen] = useState(false);
  const [isCloneModalOpen, setIsCloneModalOpen] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const loadRepositories = async () => {
    try {
      setLoading(true);
      const repos = await gitService.getRepositories();
      setRepositories(repos);
      
      // Select the first repository if none is selected
      if (repos.length > 0 && !selectedRepository) {
        setSelectedRepository(repos[0]);
      }
      
      setError(null);
    } catch (err) {
      setError(`Failed to load repositories: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
    }
  };

  const handleSelectRepository = (repository: GitRepository) => {
    setSelectedRepository(repository);
  };

  const handleInitRepository = async (name: string) => {
    try {
      setLoading(true);
      await gitService.initRepository(projectId, name);
      toast.success('Repository initialized successfully');
      loadRepositories();
    } catch (err) {
      toast.error(`Failed to initialize repository: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
      setIsInitModalOpen(false);
    }
  };

  const handleCloneRepository = async (cloneData: {
    name: string;
    url: string;
    username?: string;
    password?: string;
    branch?: string;
  }) => {
    try {
      setLoading(true);
      await gitService.cloneRepository(
        projectId,
        cloneData.name,
        cloneData.url,
        cloneData.username || '',
        cloneData.password || '',
        cloneData.branch || ''
      );
      toast.success('Repository cloned successfully');
      loadRepositories();
    } catch (err) {
      toast.error(`Failed to clone repository: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
      setIsCloneModalOpen(false);
    }
  };

  useEffect(() => {
    if (projectId) {
      loadRepositories();
    }
  }, [projectId]);

  return (
    <div className="git-repository-manager">
      <div className="repository-manager-header">
        <h1>Git Repository Manager</h1>
        <div className="repository-actions">
          <Button 
            variant="primary" 
            onClick={() => setIsInitModalOpen(true)}
            disabled={loading}
          >
            Initialize Repository
          </Button>
          <Button 
            variant="secondary" 
            onClick={() => setIsCloneModalOpen(true)}
            disabled={loading}
          >
            Clone Repository
          </Button>
          <Button 
            variant="outline" 
            onClick={loadRepositories}
            disabled={loading}
          >
            Refresh
          </Button>
        </div>
      </div>

      {loading && <Spinner message="Loading repositories..." />}
      
      {error && <ErrorPanel message={error} />}

      {!loading && !error && (
        <div className="repository-manager-content">
          {repositories.length === 0 ? (
            <div className="empty-state">
              <h2>No Git repositories found</h2>
              <p>Initialize a new repository or clone an existing one to get started.</p>
            </div>
          ) : (
            <div className="repository-layout">
              <RepositoryList 
                repositories={repositories} 
                selectedRepository={selectedRepository} 
                onSelectRepository={handleSelectRepository}
              />
              
              {selectedRepository && (
                <RepositoryDetails 
                  repository={selectedRepository} 
                  onRefresh={loadRepositories}
                />
              )}
            </div>
          )}
        </div>
      )}

      <InitRepositoryModal 
        isOpen={isInitModalOpen}
        onClose={() => setIsInitModalOpen(false)}
        onInit={handleInitRepository}
      />

      <CloneRepositoryModal 
        isOpen={isCloneModalOpen}
        onClose={() => setIsCloneModalOpen(false)}
        onClone={handleCloneRepository}
      />
    </div>
  );
};

// src/components/integration/git/RepositoryDetails.tsx
import React, { useState, useEffect } from 'react';
import { GitRepository, GitBranch, GitFileStatus, GitCommit } from '../../../models/integration/git';
import { gitService } from '../../../services/api/gitService';
import { BranchSelector } from './BranchSelector';
import { FileStatusList } from './FileStatusList';
import { CommitHistory } from './CommitHistory';
import { CommitForm } from './CommitForm';
import { SyncStatus } from './SyncStatus';
import { RemoteManager } from './RemoteManager';
import { Tabs, Tab, Spinner, ErrorPanel, Button } from '../../core';
import { toast } from 'react-toastify';

interface RepositoryDetailsProps {
  repository: GitRepository;
  onRefresh: () => void;
}

export const RepositoryDetails: React.FC<RepositoryDetailsProps> = ({ repository, onRefresh }) => {
  const [activeTab, setActiveTab] = useState<'changes' | 'history' | 'branches' | 'remotes'>('changes');
  const [branches, setBranches] = useState<GitBranch[]>([]);
  const [fileStatuses, setFileStatuses] = useState<GitFileStatus[]>([]);
  const [commits, setCommits] = useState<GitCommit[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [selectedFiles, setSelectedFiles] = useState<string[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);

  const loadBranches = async () => {
    try {
      setLoading(true);
      const branchList = await gitService.getBranches(repository.id);
      setBranches(branchList);
    } catch (err) {
      setError(`Failed to load branches: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
    }
  };

  const loadFileStatus = async () => {
    try {
      setLoading(true);
      const status = await gitService.getStatus(repository.id);
      setFileStatuses(status);
    } catch (err) {
      setError(`Failed to load file status: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
    }
  };

  const loadCommitHistory = async () => {
    try {
      setLoading(true);
      const history = await gitService.getCommitHistory(repository.id, 50);
      setCommits(history);
    } catch (err) {
      setError(`Failed to load commit history: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
    }
  };

  const handleBranchChange = async (branchName: string) => {
    try {
      setLoading(true);
      await gitService.checkoutBranch(repository.id, branchName);
      toast.success(`Switched to branch: ${branchName}`);
      
      // Refresh data
      await loadBranches();
      await loadFileStatus();
      onRefresh();
    } catch (err) {
      toast.error(`Failed to switch branch: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
    }
  };

  const handleStageFile = async (filePath: string) => {
    try {
      await gitService.stageFiles(repository.id, [filePath]);
      toast.success(`Staged file: ${filePath}`);
      await loadFileStatus();
    } catch (err) {
      toast.error(`Failed to stage file: ${err instanceof Error ? err.message : String(err)}`);
    }
  };

  const handleUnstageFile = async (filePath: string) => {
    try {
      await gitService.unstageFiles(repository.id, [filePath]);
      toast.success(`Unstaged file: ${filePath}`);
      await loadFileStatus();
    } catch (err) {
      toast.error(`Failed to unstage file: ${err instanceof Error ? err.message : String(err)}`);
    }
  };

  const handleFileSelectionChange = (filePath: string, isSelected: boolean) => {
    if (isSelected) {
      setSelectedFiles([...selectedFiles, filePath]);
    } else {
      setSelectedFiles(selectedFiles.filter(path => path !== filePath));
    }
  };

  const handleStageSelected = async () => {
    if (selectedFiles.length === 0) return;
    
    try {
      await gitService.stageFiles(repository.id, selectedFiles);
      toast.success(`Staged ${selectedFiles.length} files`);
      setSelectedFiles([]);
      await loadFileStatus();
    } catch (err) {
      toast.error(`Failed to stage files: ${err instanceof Error ? err.message : String(err)}`);
    }
  };

  const handleStageAll = async () => {
    const unstaged = fileStatuses
      .filter(file => !file.stagedStatus)
      .map(file => file.path);
      
    if (unstaged.length === 0) return;
    
    try {
      await gitService.stageFiles(repository.id, unstaged);
      toast.success('Staged all files');
      await loadFileStatus();
    } catch (err) {
      toast.error(`Failed to stage files: ${err instanceof Error ? err.message : String(err)}`);
    }
  };

  const handleCommit = async (message: string, authorName: string, authorEmail: string) => {
    try {
      setLoading(true);
      const commit = await gitService.commit(repository.id, message, authorName, authorEmail);
      toast.success('Changes committed successfully');
      
      // Refresh data
      await loadFileStatus();
      await loadCommitHistory();
    } catch (err) {
      toast.error(`Failed to commit changes: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
    }
  };

  const handleSync = async () => {
    try {
      setIsSyncing(true);
      const result = await gitService.synchronize(repository.id);
      
      if (result.success) {
        toast.success('Synchronization completed successfully');
      } else {
        toast.warning(`Synchronization completed with issues: ${result.message}`);
      }
      
      // Refresh data
      await loadBranches();
      await loadFileStatus();
      await loadCommitHistory();
      onRefresh();
    } catch (err) {
      toast.error(`Synchronization failed: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setIsSyncing(false);
    }
  };

  useEffect(() => {
    if (repository) {
      loadBranches();
      loadFileStatus();
      loadCommitHistory();
    }
  }, [repository]);

  const refreshData = () => {
    loadBranches();
    loadFileStatus();
    loadCommitHistory();
  };

  const hasUncommittedChanges = fileStatuses.some(file => 
    file.status !== 'Unmodified' || file.stagedStatus
  );

  return (
    <div className="repository-details">
      <div className="repository-header">
        <div className="repository-info">
          <h2>{repository.name}</h2>
          <div className={`repository-status status-${repository.status.toLowerCase()}`}>
            {repository.status}
          </div>
        </div>
        
        <div className="repository-actions">
          <Button 
            variant="primary" 
            onClick={handleSync}
            disabled={isSyncing}
          >
            {isSyncing ? 'Syncing...' : 'Synchronize'}
          </Button>
          <Button 
            variant="outline" 
            onClick={refreshData}
            disabled={loading}
          >
            Refresh
          </Button>
        </div>
      </div>
      
      <div className="repository-branch-selector">
        <BranchSelector 
          branches={branches}
          currentBranch={repository.currentBranch}
          onBranchChange={handleBranchChange}
        />
        <SyncStatus branches={branches} />
      </div>
      
      {loading && <Spinner message="Loading repository data..." />}
      
      {error && <ErrorPanel message={error} />}
      
      {!loading && !error && (
        <>
          <Tabs
            activeTab={activeTab}
            onChange={(tab) => setActiveTab(tab as any)}
            tabs={[
              { id: 'changes', label: 'Changes' },
              { id: 'history', label: 'History' },
              { id: 'branches', label: 'Branches' },
              { id: 'remotes', label: 'Remotes' }
            ]}
          />
          
          <div className="tab-content">
            {activeTab === 'changes' && (
              <div className="changes-tab">
                {hasUncommittedChanges ? (
                  <>
                    <div className="file-actions">
                      {selectedFiles.length > 0 && (
                        <Button 
                          variant="secondary" 
                          onClick={handleStageSelected}
                        >
                          Stage Selected ({selectedFiles.length})
                        </Button>
                      )}
                      <Button 
                        variant="outline" 
                        onClick={handleStageAll}
                      >
                        Stage All
                      </Button>
                    </div>
                    
                    <FileStatusList 
                      fileStatuses={fileStatuses}
                      onStageFile={handleStageFile}
                      onUnstageFile={handleUnstageFile}
                      onSelectionChange={handleFileSelectionChange}
                      selectedFiles={selectedFiles}
                    />
                    
                    <CommitForm onCommit={handleCommit} />
                  </>
                ) : (
                  <div className="empty-state">
                    <h3>No changes</h3>
                    <p>Your working directory is clean.</p>
                  </div>
                )}
              </div>
            )}
            
            {activeTab === 'history' && (
              <CommitHistory commits={commits} />
            )}
            
            {activeTab === 'branches' && (
              <div className="branches-tab">
                <BranchManager 
                  repositoryId={repository.id}
                  branches={branches}
                  currentBranch={repository.currentBranch}
                  onBranchChange={handleBranchChange}
                  onRefresh={loadBranches}
                />
              </div>
            )}
            
            {activeTab === 'remotes' && (
              <RemoteManager 
                repositoryId={repository.id}
                remotes={repository.remotes}
                onRefresh={onRefresh}
              />
            )}
          </div>
        </>
      )}
    </div>
  );
};

// src/components/integration/git/BranchSelector.tsx
import React, { useState } from 'react';
import { GitBranch } from '../../../models/integration/git';
import { Dropdown, Button } from '../../core';

interface BranchSelectorProps {
  branches: GitBranch[];
  currentBranch: string;
  onBranchChange: (branchName: string) => void;
}

export const BranchSelector: React.FC<BranchSelectorProps> = ({ 
  branches, 
  currentBranch, 
  onBranchChange 
}) => {
  const [isOpen, setIsOpen] = useState(false);
  
  const localBranches = branches.filter(branch => !branch.isRemote);
  
  return (
    <div className="branch-selector">
      <Button 
        variant="outline"
        onClick={() => setIsOpen(!isOpen)}
      >
        <span className="branch-icon">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5 3.25C5 2.56 4.44 2 3.75 2C3.06 2 2.5 2.56 2.5 3.25C2.5 3.94 3.06 4.5 3.75 4.5C4.44 4.5 5 3.94 5 3.25ZM5 5.5C5.54 5.5 6.04 5.35 6.5 5.09V10.9C6.04 10.65 5.54 10.5 5 10.5V5.5ZM10.5 5.5C10.5 6.88 9.38 8 8 8V10.5C9.38 10.5 10.5 11.62 10.5 13C10.5 14.38 9.38 15.5 8 15.5C6.62 15.5 5.5 14.38 5.5 13C5.5 12.46 5.65 11.96 5.91 11.5H2.5V3.5C2.5 2.12 3.62 1 5 1C6.38 1 7.5 2.12 7.5 3.5V9.5H8C8.83 9.5 9.5 8.83 9.5 8C9.5 7.17 8.83 6.5 8 6.5V5.5C9.38 5.5 10.5 6.62 10.5 5.5Z" fill="currentColor"/>
          </svg>
        </span>
        <span className="current-branch">{currentBranch}</span>
        <span className="dropdown-arrow">‚ñº</span>
      </Button>
      
      {isOpen && (
        <div className="branch-dropdown">
          <div className="dropdown-header">
            <h3>Switch Branch</h3>
            <button className="close-button" onClick={() => setIsOpen(false)}>√ó</button>
          </div>
          
          <div className="branch-list">
            {localBranches.length === 0 ? (
              <div className="empty-branch-list">No branches found</div>
            ) : (
              localBranches.map(branch => (
                <div 
                  key={branch.name}
                  className={`branch-item ${branch.isCurrent ? 'current' : ''}`}
                  onClick={() => {
                    if (!branch.isCurrent) {
                      onBranchChange(branch.name);
                    }
                    setIsOpen(false);
                  }}
                >
                  <span className="branch-name">{branch.name}</span>
                  {branch.isCurrent && <span className="current-marker">‚úì</span>}
                </div>
              ))
            )}
          </div>
        </div>
      )}
    </div>
  );
};

// src/components/integration/git/FileStatusList.tsx
import React from 'react';
import { GitFileStatus } from '../../../models/integration/git';
import { Checkbox, Button } from '../../core';

interface FileStatusListProps {
  fileStatuses: GitFileStatus[];
  selectedFiles: string[];
  onStageFile: (filePath: string) => void;
  onUnstageFile: (filePath: string) => void;
  onSelectionChange: (filePath: string, isSelected: boolean) => void;
}

export const FileStatusList: React.FC<FileStatusListProps> = ({
  fileStatuses,
  selectedFiles,
  onStageFile,
  onUnstageFile,
  onSelectionChange
}) => {
  // Group files by status
  const stagedFiles = fileStatuses.filter(file => file.stagedStatus);
  const unstagedFiles = fileStatuses.filter(file => !file.stagedStatus && file.status !== 'Untracked');
  const untrackedFiles = fileStatuses.filter(file => file.status === 'Untracked');
  
  return (
    <div className="file-status-list">
      {stagedFiles.length > 0 && (
        <div className="file-group">
          <h3>Staged Changes</h3>
          {stagedFiles.map(file => (
            <div key={file.path} className="file-item">
              <div className="file-info">
                <span className={`file-status status-${file.stagedStatus?.toLowerCase()}`}>
                  {file.stagedStatus}
                </span>
                <span className="file-path">{file.path}</span>
              </div>
              <div className="file-actions">
                <Button 
                  variant="outline"
                  size="small"
                  onClick={() => onUnstageFile(file.path)}
                >
                  Unstage
                </Button>
              </div>
            </div>
          ))}
        </div>
      )}
      
      {unstagedFiles.length > 0 && (
        <div className="file-group">
          <h3>Unstaged Changes</h3>
          {unstagedFiles.map(file => (
            <div key={file.path} className="file-item">
              <div className="file-info">
                <Checkbox
                  checked={selectedFiles.includes(file.path)}
                  onChange={(e) => onSelectionChange(file.path, e.target.checked)}
                />
                <span className={`file-status status-${file.status.toLowerCase()}`}>
                  {file.status}
                </span>
                <span className="file-path">{file.path}</span>
              </div>
              <div className="file-actions">
                <Button 
                  variant="outline"
                  size="small"
                  onClick={() => onStageFile(file.path)}
                >
                  Stage
                </Button>
              </div>
            </div>
          ))}
        </div>
      )}
      
      {untrackedFiles.length > 0 && (
        <div className="file-group">
          <h3>Untracked Files</h3>
          {untrackedFiles.map(file => (
            <div key={file.path} className="file-item">
              <div className="file-info">
                <Checkbox
                  checked={selectedFiles.includes(file.path)}
                  onChange={(e) => onSelectionChange(file.path, e.target.checked)}
                />
                <span className="file-status status-untracked">Untracked</span>
                <span className="file-path">{file.path}</span>
              </div>
              <div className="file-actions">
                <Button 
                  variant="outline"
                  size="small"
                  onClick={() => onStageFile(file.path)}
                >
                  Stage
                </Button>
              </div>
            </div>
          ))}
        </div>
      )}
      
      {fileStatuses.length === 0 && (
        <div className="empty-file-list">
          <p>No changes detected</p>
        </div>
      )}
    </div>
  );
};

// src/components/integration/git/CommitHistory.tsx
import React, { useState } from 'react';
import { GitCommit } from '../../../models/integration/git';
import { formatDistanceToNow } from 'date-fns';

interface CommitHistoryProps {
  commits: GitCommit[];
}

export const CommitHistory: React.FC<CommitHistoryProps> = ({ commits }) => {
  const [selectedCommit, setSelectedCommit] = useState<GitCommit | null>(null);
  
  if (commits.length === 0) {
    return (
      <div className="empty-commit-history">
        <p>No commits found</p>
      </div>
    );
  }
  
  return (
    <div className="commit-history">
      <div className="commit-list">
        {commits.map(commit => (
          <div 
            key={commit.id}
            className={`commit-item ${selectedCommit?.id === commit.id ? 'selected' : ''}`}
            onClick={() => setSelectedCommit(commit)}
          >
            <div className="commit-header">
              <span className="commit-id">{commit.shortId}</span>
              <span className="commit-author">{commit.author}</span>
              <span className="commit-date">
                {formatDistanceToNow(new Date(commit.authorDate), { addSuffix: true })}
              </span>
            </div>
            <div className="commit-message">{commit.message}</div>
          </div>
        ))}
      </div>
      
      {selectedCommit && (
        <div className="commit-details">
          <div className="details-header">
            <h3>Commit Details</h3>
            <button className="close-button" onClick={() => setSelectedCommit(null)}>√ó</button>
          </div>
          
          <div className="details-content">
            <div className="details-item">
              <span className="label">ID:</span>
              <span className="value">{selectedCommit.id}</span>
            </div>
            
            <div className="details-item">
              <span className="label">Author:</span>
              <span className="value">{selectedCommit.author} &lt;{selectedCommit.authorEmail}&gt;</span>
            </div>
            
            <div className="details-item">
              <span className="label">Date:</span>
              <span className="value">{new Date(selectedCommit.authorDate).toLocaleString()}</span>
            </div>
            
            <div className="details-item">
              <span className="label">Committer:</span>
              <span className="value">{selectedCommit.committer} &lt;{selectedCommit.committerEmail}&gt;</span>
            </div>
            
            <div className="details-item">
              <span className="label">Message:</span>
              <pre className="value commit-message-full">{selectedCommit.message}</pre>
            </div>
            
            <div className="details-item">
              <span className="label">Parents:</span>
              <div className="value">
                {selectedCommit.parents.map(parent => (
                  <div key={parent} className="parent-id">{parent}</div>
                ))}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

// src/components/integration/git/CommitForm.tsx
import React, { useState } from 'react';
import { Button, TextArea, Input } from '../../core';
import { gitService } from '../../../services/api/gitService';

interface CommitFormProps {
  onCommit: (message: string, authorName: string, authorEmail: string) => void;
}

export const CommitForm: React.FC<CommitFormProps> = ({ onCommit }) => {
  const [message, setMessage] = useState('');
  const [authorName, setAuthorName] = useState('');
  const [authorEmail, setAuthorEmail] = useState('');
  const [showAuthorFields, setShowAuthorFields] = useState(false);
  const [loading, setLoading] = useState(false);
  
  // Load user info from Git config on first render
  React.useEffect(() => {
    const loadUserInfo = async () => {
      try {
        const userInfo = await gitService.getUserInfo();
        if (userInfo.name) setAuthorName(userInfo.name);
        if (userInfo.email) setAuthorEmail(userInfo.email);
      } catch (error) {
        // Silently fail and let the user input manually
      }
    };
    
    loadUserInfo();
  }, []);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!message.trim()) return;
    
    setLoading(true);
    await onCommit(
      message, 
      authorName || 'Unknown', 
      authorEmail || 'unknown@example.com'
    );
    setLoading(false);
    
    // Reset form
    setMessage('');
  };
  
  return (
    <form className="commit-form" onSubmit={handleSubmit}>
      <TextArea
        label="Commit Message"
        value={message}
        onChange={(e) => setMessage(e.target.value)}
        placeholder="Enter a commit message"
        rows={4}
        required
      />
      
      <div className="form-footer">
        <div className="author-toggle">
          <button 
            type="button" 
            className="toggle-button" 
            onClick={() => setShowAuthorFields(!showAuthorFields)}
          >
            {showAuthorFields ? 'Hide Author Info' : 'Edit Author Info'}
          </button>
        </div>
        
        <Button 
          type="submit" 
          variant="primary" 
          disabled={!message.trim() || loading}
        >
          {loading ? 'Committing...' : 'Commit Changes'}
        </Button>
      </div>
      
      {showAuthorFields && (
        <div className="author-fields">
          <Input
            label="Author Name"
            value={authorName}
            onChange={(e) => setAuthorName(e.target.value)}
            placeholder="Your Name"
          />
          
          <Input
            label="Author Email"
            value={authorEmail}
            onChange={(e) => setAuthorEmail(e.target.value)}
            placeholder="your.email@example.com"
            type="email"
          />
        </div>
      )}
    </form>
  );
};

// src/components/integration/git/SyncStatus.tsx
import React from 'react';
import { GitBranch } from '../../../models/integration/git';

interface SyncStatusProps {
  branches: GitBranch[];
}

export const SyncStatus: React.FC<SyncStatusProps> = ({ branches }) => {
  // Find current branch
  const currentBranch = branches.find(branch => branch.isCurrent);
  
  if (!currentBranch || currentBranch.trackingBranch === undefined) {
    return null;
  }
  
  const aheadCount = currentBranch.aheadCount || 0;
  const behindCount = currentBranch.behindCount || 0;
  
  if (aheadCount === 0 && behindCount === 0) {
    return (
      <div className="sync-status">
        <span className="sync-icon sync-uptodate">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M8 15C11.866 15 15 11.866 15 8C15 4.13401 11.866 1 8 1C4.13401 1 1 4.13401 1 8C1 11.866 4.13401 15 8 15Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M5 8L7 10L11 6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </span>
        <span className="sync-text">Up to date</span>
      </div>
    );
  }
  
  return (
    <div className="sync-status">
      {aheadCount > 0 && (
        <div className="sync-ahead">
          <span className="sync-icon">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M8 12V4M8 4L4 8M8 4L12 8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </span>
          <span className="sync-count">{aheadCount}</span>
        </div>
      )}
      
      {behindCount > 0 && (
        <div className="sync-behind">
          <span className="sync-icon">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M8 4V12M8 12L4 8M8 12L12 8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </span>
          <span className="sync-count">{behindCount}</span>
        </div>
      )}
    </div>
  );
};

// src/components/integration/git/BranchManager.tsx
import React, { useState } from 'react';
import { GitBranch } from '../../../models/integration/git';
import { gitService } from '../../../services/api/gitService';
import { Button, Input, Modal } from '../../core';
import { toast } from 'react-toastify';

interface BranchManagerProps {
  repositoryId: string;
  branches: GitBranch[];
  currentBranch: string;
  onBranchChange: (branchName: string) => void;
  onRefresh: () => void;
}

export const BranchManager: React.FC<BranchManagerProps> = ({
  repositoryId,
  branches,
  currentBranch,
  onBranchChange,
  onRefresh
}) => {
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const [newBranchName, setNewBranchName] = useState('');
  const [shouldCheckout, setShouldCheckout] = useState(true);
  const [loading, setLoading] = useState(false);
  
  const localBranches = branches.filter(branch => !branch.isRemote);
  const remoteBranches = branches.filter(branch => branch.isRemote);
  
  const handleCreateBranch = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!newBranchName.trim()) return;
    
    try {
      setLoading(true);
      await gitService.createBranch(repositoryId, newBranchName, shouldCheckout);
      toast.success(`Branch "${newBranchName}" created successfully`);
      
      // Refresh branch list
      onRefresh();
      
      // Reset form
      setNewBranchName('');
      setIsCreateModalOpen(false);
    } catch (err) {
      toast.error(`Failed to create branch: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="branch-manager">
      <div className="branch-manager-header">
        <h3>Branches</h3>
        <Button 
          variant="primary"
          onClick={() => setIsCreateModalOpen(true)}
        >
          Create Branch
        </Button>
      </div>
      
      <div className="branch-lists">
        <div className="branch-section">
          <h4>Local Branches</h4>
          <div className="branch-list">
            {localBranches.length === 0 ? (
              <div className="empty-branch-list">No local branches found</div>
            ) : (
              localBranches.map(branch => (
                <div 
                  key={branch.name}
                  className={`branch-item ${branch.isCurrent ? 'current' : ''}`}
                >
                  <div className="branch-info">
                    <span className="branch-name">{branch.name}</span>
                    {branch.isCurrent && <span className="current-marker">‚úì</span>}
                  </div>
                  
                  {!branch.isCurrent && (
                    <div className="branch-actions">
                      <Button 
                        variant="outline"
                        size="small"
                        onClick={() => onBranchChange(branch.name)}
                      >
                        Checkout
                      </Button>
                    </div>
                  )}
                  
                  {branch.trackingBranch && (
                    <div className="branch-tracking">
                      <span className="tracking-label">tracks</span>
                      <span className="tracking-branch">{branch.trackingBranch.replace('refs/remotes/', '')}</span>
                      
                      <div className="tracking-status">
                        {branch.aheadCount > 0 && (
                          <span className="ahead">{branch.aheadCount} ahead</span>
                        )}
                        {branch.behindCount > 0 && (
                          <span className="behind">{branch.behindCount} behind</span>
                        )}
                        {branch.aheadCount === 0 && branch.behindCount === 0 && (
                          <span className="up-to-date">up to date</span>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              ))
            )}
          </div>
        </div>
        
        <div className="branch-section">
          <h4>Remote Branches</h4>
          <div className="branch-list">
            {remoteBranches.length === 0 ? (
              <div className="empty-branch-list">No remote branches found</div>
            ) : (
              remoteBranches.map(branch => (
                <div 
                  key={branch.fullName}
                  className="branch-item remote"
                >
                  <div className="branch-info">
                    <span className="remote-name">{branch.remoteName}/</span>
                    <span className="branch-name">{branch.name}</span>
                  </div>
                  
                  <div className="branch-actions">
                    <Button 
                      variant="outline"
                      size="small"
                      onClick={() => onBranchChange(branch.name)}
                    >
                      Checkout
                    </Button>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      </div>
      
      <Modal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
        title="Create Branch"
      >
        <form onSubmit={handleCreateBranch}>
          <Input
            label="Branch Name"
            value={newBranchName}
            onChange={(e) => setNewBranchName(e.target.value)}
            placeholder="Enter branch name"
            required
          />
          
          <div className="form-group">
            <label className="checkbox-label">
              <input
                type="checkbox"
                checked={shouldCheckout}
                onChange={(e) => setShouldCheckout(e.target.checked)}
              />
              Checkout branch after creation
            </label>
          </div>
          
          <div className="modal-actions">
            <Button 
              type="button" 
              variant="outline"
              onClick={() => setIsCreateModalOpen(false)}
            >
              Cancel
            </Button>
            <Button 
              type="submit" 
              variant="primary"
              disabled={!newBranchName.trim() || loading}
            >
              {loading ? 'Creating...' : 'Create Branch'}
            </Button>
          </div>
        </form>
      </Modal>
    </div>
  );
};

// src/components/integration/git/RemoteManager.tsx
import React, { useState } from 'react';
import { GitRemote } from '../../../models/integration/git';
import { gitService } from '../../../services/api/gitService';
import { Button, Input, Modal } from '../../core';
import { toast } from 'react-toastify';

interface RemoteManagerProps {
  repositoryId: string;
  remotes: GitRemote[];
  onRefresh: () => void;
}

export const RemoteManager: React.FC<RemoteManagerProps> = ({
  repositoryId,
  remotes,
  onRefresh
}) => {
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [remoteName, setRemoteName] = useState('');
  const [remoteUrl, setRemoteUrl] = useState('');
  const [username, setUsername] = useState('');
  const [authType, setAuthType] = useState<'None' | 'HTTPS' | 'SSH' | 'PAT'>('HTTPS');
  const [loading, setLoading] = useState(false);
  
  const handleAddRemote = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!remoteName.trim() || !remoteUrl.trim()) return;
    
    try {
      setLoading(true);
      await gitService.addRemote(repositoryId, remoteName, remoteUrl, username, authType);
      toast.success(`Remote "${remoteName}" added successfully`);
      
      // Refresh remote list
      onRefresh();
      
      // Reset form
      setRemoteName('');
      setRemoteUrl('');
      setUsername('');
      setAuthType('HTTPS');
      setIsAddModalOpen(false);
    } catch (err) {
      toast.error(`Failed to add remote: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
    }
  };
  
  const handleRemoveRemote = async (remoteName: string) => {
    if (!confirm(`Are you sure you want to remove the remote "${remoteName}"?`)) {
      return;
    }
    
    try {
      await gitService.removeRemote(repositoryId, remoteName);
      toast.success(`Remote "${remoteName}" removed successfully`);
      
      // Refresh remote list
      onRefresh();
    } catch (err) {
      toast.error(`Failed to remove remote: ${err instanceof Error ? err.message : String(err)}`);
    }
  };
  
  return (
    <div className="remote-manager">
      <div className="remote-manager-header">
        <h3>Remotes</h3>
        <Button 
          variant="primary"
          onClick={() => setIsAddModalOpen(true)}
        >
          Add Remote
        </Button>
      </div>
      
      <div className="remotes-list">
        {remotes.length === 0 ? (
          <div className="empty-remotes-list">
            <p>No remotes configured</p>
            <p>Add a remote to synchronize your repository with a remote server</p>
          </div>
        ) : (
          remotes.map(remote => (
            <div key={remote.name} className="remote-item">
              <div className="remote-info">
                <div className="remote-name-url">
                  <span className="remote-name">{remote.name}</span>
                  <span className="remote-url">{remote.url}</span>
                </div>
                
                <div className="remote-auth">
                  <span className="auth-type">{remote.authType}</span>
                  {remote.username && <span className="username">{remote.username}</span>}
                </div>
              </div>
              
              <div className="remote-actions">
                <Button 
                  variant="outline"
                  size="small"
                  onClick={() => handleRemoveRemote(remote.name)}
                >
                  Remove
                </Button>
              </div>
            </div>
          ))
        )}
      </div>
      
      <Modal
        isOpen={isAddModalOpen}
        onClose={() => setIsAddModalOpen(false)}
        title="Add Remote"
      >
        <form onSubmit={handleAddRemote}>
          <Input
            label="Remote Name"
            value={remoteName}
            onChange={(e) => setRemoteName(e.target.value)}
            placeholder="e.g., origin"
            required
          />
          
          <Input
            label="Remote URL"
            value={remoteUrl}
            onChange={(e) => setRemoteUrl(e.target.value)}
            placeholder="e.g., https://github.com/username/repository.git"
            required
          />
          
          <div className="form-group">
            <label>Authentication Type</label>
            <select 
              value={authType}
              onChange={(e) => setAuthType(e.target.value as any)}
              className="form-control"
            >
              <option value="None">None</option>
              <option value="HTTPS">HTTPS</option>
              <option value="SSH">SSH</option>
              <option value="PAT">Personal Access Token</option>
            </select>
          </div>
          
          {(authType === 'HTTPS' || authType === 'PAT') && (
            <Input
              label="Username"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              placeholder="Your username"
            />
          )}
          
          <div className="modal-actions">
            <Button 
              type="button" 
              variant="outline"
              onClick={() => setIsAddModalOpen(false)}
            >
              Cancel
            </Button>
            <Button 
              type="submit" 
              variant="primary"
              disabled={!remoteName.trim() || !remoteUrl.trim() || loading}
            >
              {loading ? 'Adding...' : 'Add Remote'}
            </Button>
          </div>
        </form>
      </Modal>
    </div>
  );
};

// src/components/integration/git/InitRepositoryModal.tsx
import React, { useState } from 'react';
import { Modal, Input, Button } from '../../core';

interface InitRepositoryModalProps {
  isOpen: boolean;
  onClose: () => void;
  onInit: (name: string) => void;
}

export const InitRepositoryModal: React.FC<InitRepositoryModalProps> = ({
  isOpen,
  onClose,
  onInit
}) => {
  const [name, setName] = useState('');
  const [loading, setLoading] = useState(false);
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!name.trim()) return;
    
    setLoading(true);
    onInit(name);
    // onInit will close the modal
  };
  
  const handleClose = () => {
    if (!loading) {
      setName('');
      onClose();
    }
  };
  
  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title="Initialize Repository"
    >
      <form onSubmit={handleSubmit}>
        <Input
          label="Repository Name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Enter repository name"
          required
          disabled={loading}
        />
        
        <div className="modal-info">
          <p>
            This will initialize a Git repository in the current project directory.
            A .gitignore file will be created with common patterns.
          </p>
        </div>
        
        <div className="modal-actions">
          <Button 
            type="button" 
            variant="outline"
            onClick={handleClose}
            disabled={loading}
          >
            Cancel
          </Button>
          <Button 
            type="submit" 
            variant="primary"
            disabled={!name.trim() || loading}
          >
            {loading ? 'Initializing...' : 'Initialize Repository'}
          </Button>
        </div>
      </form>
    </Modal>
  );
};

// src/components/integration/git/CloneRepositoryModal.tsx
import React, { useState } from 'react';
import { Modal, Input, Button } from '../../core';

interface CloneRepositoryModalProps {
  isOpen: boolean;
  onClose: () => void;
  onClone: (data: {
    name: string;
    url: string;
    username?: string;
    password?: string;
    branch?: string;
  }) => void;
}

export const CloneRepositoryModal: React.FC<CloneRepositoryModalProps> = ({
  isOpen,
  onClose,
  onClone
}) => {
  const [name, setName] = useState('');
  const [url, setUrl] = useState('');
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [branch, setBranch] = useState('');
  const [hasCredentials, setHasCredentials] = useState(false);
  const [loading, setLoading] = useState(false);
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!name.trim() || !url.trim()) return;
    
    setLoading(true);
    onClone({
      name,
      url,
      username: hasCredentials ? username : undefined,
      password: hasCredentials ? password : undefined,
      branch: branch || undefined
    });
    // onClone will close the modal
  };
  
  const handleClose = () => {
    if (!loading) {
      // Reset form
      setName('');
      setUrl('');
      setUsername('');
      setPassword('');
      setBranch('');
      setHasCredentials(false);
      
      onClose();
    }
  };
  
  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title="Clone Repository"
    >
      <form onSubmit={handleSubmit}>
        <Input
          label="Repository URL"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          placeholder="e.g., https://github.com/username/repository.git"
          required
          disabled={loading}
        />
        
        <Input
          label="Repository Name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Enter repository name"
          required
          disabled={loading}
        />
        
        <div className="form-group">
          <label className="checkbox-label">
            <input
              type="checkbox"
              checked={hasCredentials}
              onChange={(e) => setHasCredentials(e.target.checked)}
              disabled={loading}
            />
            Authentication Required
          </label>
        </div>
        
        {hasCredentials && (
          <>
            <Input
              label="Username"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              placeholder="Your username"
              disabled={loading}
            />
            
            <Input
              label="Password / Token"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Your password or token"
              disabled={loading}
            />
          </>
        )}
        
        <Input
          label="Branch (optional)"
          value={branch}
          onChange={(e) => setBranch(e.target.value)}
          placeholder="Leave empty for default branch"
          disabled={loading}
        />
        
        <div className="modal-info">
          <p>
            This will clone the repository into the current project directory.
            The directory must be empty.
          </p>
        </div>
        
        <div className="modal-actions">
          <Button 
            type="button" 
            variant="outline"
            onClick={handleClose}
            disabled={loading}
          >
            Cancel
          </Button>
          <Button 
            type="submit" 
            variant="primary"
            disabled={!name.trim() || !url.trim() || loading}
          >
            {loading ? 'Cloning...' : 'Clone Repository'}
          </Button>
        </div>
      </form>
    </Modal>
  );
};

// src/main/java/com/automation/api/services/integration/git/GitCollaborationService.java
package com.automation.api.services.integration.git;

import com.automation.api.models.integration.git.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

/**
 * Service for handling collaborative Git operations like pull requests
 * and code reviews with different Git providers (GitHub, GitLab, Azure DevOps)
 */
@Service
public class GitCollaborationService {

    private final GitRepositoryService repositoryService;
    private final GitCredentialService credentialService;
    private final RestTemplate restTemplate;
    private final Executor executor = Executors.newFixedThreadPool(3);

    @Autowired
    public GitCollaborationService(
        GitRepositoryService repositoryService,
        GitCredentialService credentialService
    ) {
        this.repositoryService = repositoryService;
        this.credentialService = credentialService;
        this.restTemplate = new RestTemplate();
    }
    
    /* 
     * Helper methods to detect Git provider and extract repository information
     */
    
    private enum GitProvider {
        GITHUB,
        GITLAB,
        AZURE_DEVOPS,
        UNKNOWN
    }
    
    private GitProvider detectGitProvider(String url) {
        url = url.toLowerCase();
        
        if (url.contains("github.com")) {
            return GitProvider.GITHUB;
        } else if (url.contains("gitlab.com") || url.contains("gitlab")) {
            return GitProvider.GITLAB;
        } else if (url.contains("dev.azure.com") || url.contains("visualstudio.com")) {
            return GitProvider.AZURE_DEVOPS;
        }
        
        return GitProvider.UNKNOWN;
    }
    
    private String extractOwnerAndRepo(String url, GitProvider provider) {
        // This is a simplified implementation - in a real app, use proper URL parsing
        switch (provider) {
            case GITHUB:
                // Extract owner/repo from GitHub URL
                // e.g., https://github.com/owner/repo.git -> owner/repo
                String githubPath = url.replace("https://github.com/", "")
                    .replace("http://github.com/", "")
                    .replace("git@github.com:", "");
                
                if (githubPath.endsWith(".git")) {
                    githubPath = githubPath.substring(0, githubPath.length() - 4);
                }
                
                return githubPath;
                
            case GITLAB:
                // Extract group/project from GitLab URL
                // This is simplified and may not handle nested groups correctly
                String gitlabPath = url;
                if (url.contains("gitlab.com")) {
                    gitlabPath = url.replace("https://gitlab.com/", "")
                        .replace("http://gitlab.com/", "")
                        .replace("git@gitlab.com:", "");
                } else {
                    // Custom GitLab instance - just get the path part
                    gitlabPath = url.substring(url.indexOf("://") + 3);
                    gitlabPath = gitlabPath.substring(gitlabPath.indexOf("/") + 1);
                }
                
                if (gitlabPath.endsWith(".git")) {
                    gitlabPath = gitlabPath.substring(0, gitlabPath.length() - 4);
                }
                
                return gitlabPath;
                
            case AZURE_DEVOPS:
                // Azure DevOps URLs are more complex and vary between formats
                // This is a very simplified approach
                if (url.contains("dev.azure.com")) {
                    // New format: https://dev.azure.com/{organization}/{project}/_git/{repository}
                    String[] parts = url.split("dev\\.azure\\.com/")[1].split("/");
                    if (parts.length >= 3) {
                        return parts[0] + "/" + parts[1] + "/" + parts[parts.length - 1].replace(".git", "");
                    }
                } else if (url.contains("visualstudio.com")) {
                    // Old format: https://{organization}.visualstudio.com/{project}/_git/{repository}
                    String org = url.split("\\.visualstudio\\.com")[0].split("://")[1];
                    String[] parts = url.split("\\.visualstudio\\.com/")[1].split("/_git/");
                    if (parts.length >= 2) {
                        return org + "/" + parts[0] + "/" + parts[1].replace(".git", "");
                    }
                }
                return "";
                
            default:
                return "";
        }
    }
    
    private HttpHeaders createAuthHeaders(GitRemote remote) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        // Add auth based on remote type
        if ("PAT".equals(remote.getAuthType()) && remote.getCredentialId() != null) {
            GitCredential credential = credentialService.getCredential(remote.getCredentialId());
            if (credential != null) {
                String token = credential.getPassword();
                headers.set("Authorization", "Bearer " + token);
            }
        } else if ("HTTPS".equals(remote.getAuthType()) && remote.getUsername() != null) {
            // For GitHub and others that support Basic Auth
            // Note: Many providers are deprecating Basic Auth
            // In a real implementation, this would need more robust credential handling
            GitCredential credential = credentialService.getCredential(remote.getCredentialId());
            if (credential != null) {
                String auth = remote.getUsername() + ":" + credential.getPassword();
                byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes());
                headers.set("Authorization", "Basic " + new String(encodedAuth));
            }
        }
        
        return headers;
    }
    
    /*
     * GitHub API implementation
     */
    
    private GitPullRequest createGitHubPullRequest(
        GitRepository repository,
        GitRemote remote,
        String title,
        String description,
        String sourceBranch,
        String targetBranch,
        List<String> reviewers
    ) {
        String repoPath = extractOwnerAndRepo(remote.getUrl(), GitProvider.GITHUB);
        String apiUrl = "https://api.github.com/repos/" + repoPath + "/pulls";
        
        // Create request body
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("title", title);
        requestBody.put("body", description);
        requestBody.put("head", sourceBranch);
        requestBody.put("base", targetBranch);
        
        // Send request
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(requestBody, headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            apiUrl,
            HttpMethod.POST,
            requestEntity,
            Map.class
        );
        
        // Parse response
        Map<String, Object> responseBody = response.getBody();
        int pullRequestId = ((Number) responseBody.get("number")).intValue();
        
        // Add reviewers if specified
        if (reviewers != null && !reviewers.isEmpty()) {
            addGitHubReviewers(repoPath, pullRequestId, reviewers, headers);
        }
        
        // Return created pull request
        return getGitHubPullRequest(repository, remote, pullRequestId);
    }
    
    private void addGitHubReviewers(
        String repoPath,
        int pullRequestId,
        List<String> reviewers,
        HttpHeaders headers
    ) {
        String apiUrl = "https://api.github.com/repos/" + repoPath + "/pulls/" + pullRequestId + "/requested_reviewers";
        
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("reviewers", reviewers);
        
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(requestBody, headers);
        
        restTemplate.exchange(
            apiUrl,
            HttpMethod.POST,
            requestEntity,
            Map.class
        );
    }
    
    private List<GitPullRequest> getGitHubPullRequests(GitRepository repository, GitRemote remote) {
        String repoPath = extractOwnerAndRepo(remote.getUrl(), GitProvider.GITHUB);
        String apiUrl = "https://api.github.com/repos/" + repoPath + "/pulls";
        
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<String> requestEntity = new HttpEntity<>(headers);
        
        ResponseEntity<List> response = restTemplate.exchange(
            apiUrl,
            HttpMethod.GET,
            requestEntity,
            List.class
        );
        
        List<Map<String, Object>> pullRequests = response.getBody();
        List<GitPullRequest> result = new ArrayList<>();
        
        for (Map<String, Object> pr : pullRequests) {
            GitPullRequest pullRequest = parseGitHubPullRequest(pr);
            result.add(pullRequest);
        }
        
        return result;
    }
    
    private GitPullRequest getGitHubPullRequest(
        GitRepository repository, 
        GitRemote remote, 
        int pullRequestId
    ) {
        String repoPath = extractOwnerAndRepo(remote.getUrl(), GitProvider.GITHUB);
        String apiUrl = "https://api.github.com/repos/" + repoPath + "/pulls/" + pullRequestId;
        
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<String> requestEntity = new HttpEntity<>(headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            apiUrl,
            HttpMethod.GET,
            requestEntity,
            Map.class
        );
        
        Map<String, Object> pullRequestData = response.getBody();
        return parseGitHubPullRequest(pullRequestData);
    }
    
    private GitPullRequest parseGitHubPullRequest(Map<String, Object> pullRequestData) {
        GitPullRequest pullRequest = new GitPullRequest();
        
        pullRequest.setId(((Number) pullRequestData.get("number")).intValue());
        pullRequest.setTitle((String) pullRequestData.get("title"));
        pullRequest.setDescription((String) pullRequestData.get("body"));
        
        Map<String, Object> head = (Map<String, Object>) pullRequestData.get("head");
        Map<String, Object> base = (Map<String, Object>) pullRequestData.get("base");
        
        pullRequest.setSourceBranch((String) head.get("ref"));
        pullRequest.setTargetBranch((String) base.get("ref"));
        
        String state = (String) pullRequestData.get("state");
        boolean merged = pullRequestData.get("merged") != null && 
                        (boolean) pullRequestData.get("merged");
        
        if ("open".equals(state)) {
            pullRequest.setState("Open");
        } else if (merged) {
            pullRequest.setState("Merged");
        } else {
            pullRequest.setState("Closed");
        }
        
        Map<String, Object> user = (Map<String, Object>) pullRequestData.get("user");
        pullRequest.setAuthor((String) user.get("login"));
        
        pullRequest.setCreatedDate(parseGitHubDate((String) pullRequestData.get("created_at")));
        pullRequest.setUpdatedDate(parseGitHubDate((String) pullRequestData.get("updated_at")));
        
        if (pullRequestData.get("merged_at") != null) {
            pullRequest.setMergedDate(parseGitHubDate((String) pullRequestData.get("merged_at")));
        }
        
        // Get PR commits and comments
        String commitsUrl = (String) pullRequestData.get("commits_url");
        String commentsUrl = (String) pullRequestData.get("comments_url");
        
        // These would be implemented in a real app
        // pullRequest.setCommitIds(getGitHubPullRequestCommits(commitsUrl, headers));
        // pullRequest.setComments(getGitHubPullRequestComments(commentsUrl, headers));
        
        return pullRequest;
    }
    
    private Date parseGitHubDate(String dateString) {
        try {
            // Convert ISO-8601 date to java.util.Date
            return new Date(Date.parse(dateString));
        } catch (Exception e) {
            return new Date();
        }
    }
    
    private GitComment addGitHubPullRequestComment(
        GitRepository repository, 
        GitRemote remote, 
        int pullRequestId, 
        String content
    ) {
        String repoPath = extractOwnerAndRepo(remote.getUrl(), GitProvider.GITHUB);
        String apiUrl = "https://api.github.com/repos/" + repoPath + "/issues/" + pullRequestId + "/comments";
        
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("body", content);
        
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(requestBody, headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            apiUrl,
            HttpMethod.POST,
            requestEntity,
            Map.class
        );
        
        Map<String, Object> commentData = response.getBody();
        
        GitComment comment = new GitComment();
        comment.setId(String.valueOf(commentData.get("id")));
        comment.setContent((String) commentData.get("body"));
        
        Map<String, Object> user = (Map<String, Object>) commentData.get("user");
        comment.setAuthor((String) user.get("login"));
        
        comment.setCreatedDate(parseGitHubDate((String) commentData.get("created_at")));
        
        if (commentData.get("updated_at") != null) {
            comment.setUpdatedDate(parseGitHubDate((String) commentData.get("updated_at")));
        }
        
        return comment;
    }
    
    private boolean mergeGitHubPullRequest(
        GitRepository repository, 
        GitRemote remote, 
        int pullRequestId, 
        String commitMessage
    ) {
        String repoPath = extractOwnerAndRepo(remote.getUrl(), GitProvider.GITHUB);
        String apiUrl = "https://api.github.com/repos/" + repoPath + "/pulls/" + pullRequestId + "/merge";
        
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("commit_message", commitMessage);
        
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(requestBody, headers);
        
        try {
            ResponseEntity<Map> response = restTemplate.exchange(
                apiUrl,
                HttpMethod.PUT,
                requestEntity,
                Map.class
            );
            
            return response.getStatusCode().is2xxSuccessful();
        } catch (Exception e) {
            return false;
        }
    }
    
    /*
     * GitLab API implementation
     */
    
    private GitPullRequest createGitLabMergeRequest(
        GitRepository repository,
        GitRemote remote,
        String title,
        String description,
        String sourceBranch,
        String targetBranch,
        List<String> reviewers
    ) {
        String repoPath = extractOwnerAndRepo(remote.getUrl(), GitProvider.GITLAB);
        // URL encode the path
        String encodedPath = repoPath.replace("/", "%2F");
        String apiUrl = "https://gitlab.com/api/v4/projects/" + encodedPath + "/merge_requests";
        
        // Create request body
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("title", title);
        requestBody.put("description", description);
        requestBody.put("source_branch", sourceBranch);
        requestBody.put("target_branch", targetBranch);
        
        // Send request
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(requestBody, headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            apiUrl,
            HttpMethod.POST,
            requestEntity,
            Map.class
        );
        
        // Parse response
        Map<String, Object> responseBody = response.getBody();
        int mergeRequestId = ((Number) responseBody.get("iid")).intValue();
        
        // Add reviewers if specified
        if (reviewers != null && !reviewers.isEmpty()) {
            addGitLabReviewers(encodedPath, mergeRequestId, reviewers, headers);
        }
        
        // Return created merge request
        return getGitLabMergeRequest(repository, remote, mergeRequestId);
    }
    
    private void addGitLabReviewers(
        String encodedPath,
        int mergeRequestId,
        List<String> reviewers,
        HttpHeaders headers
    ) {
        // In GitLab, you need to get user IDs from usernames
        List<Integer> reviewerIds = new ArrayList<>();
        
        for (String reviewer : reviewers) {
            String userUrl = "https://gitlab.com/api/v4/users?username=" + reviewer;
            
            ResponseEntity<List> response = restTemplate.exchange(
                userUrl,
                HttpMethod.GET,
                new HttpEntity<>(headers),
                List.class
            );
            
            if (response.getBody() != null && !response.getBody().isEmpty()) {
                Map<String, Object> userData = (Map<String, Object>) response.getBody().get(0);
                reviewerIds.add(((Number) userData.get("id")).intValue());
            }
        }
        
        if (!reviewerIds.isEmpty()) {
            String apiUrl = "https://gitlab.com/api/v4/projects/" + encodedPath + 
                            "/merge_requests/" + mergeRequestId;
            
            Map<String, Object> requestBody = new HashMap<>();
            requestBody.put("reviewer_ids", reviewerIds);
            
            HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(requestBody, headers);
            
            restTemplate.exchange(
                apiUrl,
                HttpMethod.PUT,
                requestEntity,
                Map.class
            );
        }
    }
    
    private List<GitPullRequest> getGitLabMergeRequests(GitRepository repository, GitRemote remote) {
        String repoPath = extractOwnerAndRepo(remote.getUrl(), GitProvider.GITLAB);
        String encodedPath = repoPath.replace("/", "%2F");
        String apiUrl = "https://gitlab.com/api/v4/projects/" + encodedPath + "/merge_requests";
        
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<String> requestEntity = new HttpEntity<>(headers);
        
        ResponseEntity<List> response = restTemplate.exchange(
            apiUrl,
            HttpMethod.GET,
            requestEntity,
            List.class
        );
        
        List<Map<String, Object>> mergeRequests = response.getBody();
        List<GitPullRequest> result = new ArrayList<>();
        
        for (Map<String, Object> mr : mergeRequests) {
            GitPullRequest pullRequest = parseGitLabMergeRequest(mr);
            result.add(pullRequest);
        }
        
        return result;
    }
    
    private GitPullRequest getGitLabMergeRequest(
        GitRepository repository, 
        GitRemote remote, 
        int mergeRequestId
    ) {
        String repoPath = extractOwnerAndRepo(remote.getUrl(), GitProvider.GITLAB);
        String encodedPath = repoPath.replace("/", "%2F");
        String apiUrl = "https://gitlab.com/api/v4/projects/" + encodedPath + 
                        "/merge_requests/" + mergeRequestId;
        
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<String> requestEntity = new HttpEntity<>(headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            apiUrl,
            HttpMethod.GET,
            requestEntity,
            Map.class
        );
        
        Map<String, Object> mergeRequestData = response.getBody();
        return parseGitLabMergeRequest(mergeRequestData);
    }
    
    private GitPullRequest parseGitLabMergeRequest(Map<String, Object> mergeRequestData) {
        GitPullRequest pullRequest = new GitPullRequest();
        
        pullRequest.setId(((Number) mergeRequestData.get("iid")).intValue());
        pullRequest.setTitle((String) mergeRequestData.get("title"));
        pullRequest.setDescription((String) mergeRequestData.get("description"));
        pullRequest.setSourceBranch((String) mergeRequestData.get("source_branch"));
        pullRequest.setTargetBranch((String) mergeRequestData.get("target_branch"));
        
        String state = (String) mergeRequestData.get("state");
        switch (state) {
            case "opened":
                pullRequest.setState("Open");
                break;
            case "merged":
                pullRequest.setState("Merged");
                break;
            case "closed":
                pullRequest.setState("Closed");
                break;
            default:
                pullRequest.setState(state);
        }
        
        Map<String, Object> author = (Map<String, Object>) mergeRequestData.get("author");
        pullRequest.setAuthor((String) author.get("username"));
        
        pullRequest.setCreatedDate(parseGitLabDate((String) mergeRequestData.get("created_at")));
        pullRequest.setUpdatedDate(parseGitLabDate((String) mergeRequestData.get("updated_at")));
        
        if (mergeRequestData.get("merged_at") != null) {
            pullRequest.setMergedDate(parseGitLabDate((String) mergeRequestData.get("merged_at")));
        }
        
        return pullRequest;
    }
    
    private Date parseGitLabDate(String dateString) {
        try {
            return new Date(Date.parse(dateString));
        } catch (Exception e) {
            return new Date();
        }
    }
    
    private GitComment addGitLabMergeRequestComment(
        GitRepository repository, 
        GitRemote remote, 
        int mergeRequestId, 
        String content
    ) {
        String repoPath = extractOwnerAndRepo(remote.getUrl(), GitProvider.GITLAB);
        String encodedPath = repoPath.replace("/", "%2F");
        String apiUrl = "https://gitlab.com/api/v4/projects/" + encodedPath + 
                        "/merge_requests/" + mergeRequestId + "/notes";
        
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("body", content);
        
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(requestBody, headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            apiUrl,
            HttpMethod.POST,
            requestEntity,
            Map.class
        );
        
        Map<String, Object> commentData = response.getBody();
        
        GitComment comment = new GitComment();
        comment.setId(String.valueOf(commentData.get("id")));
        comment.setContent((String) commentData.get("body"));
        
        Map<String, Object> author = (Map<String, Object>) commentData.get("author");
        comment.setAuthor((String) author.get("username"));
        
        comment.setCreatedDate(parseGitLabDate((String) commentData.get("created_at")));
        comment.setUpdatedDate(parseGitLabDate((String) commentData.get("updated_at")));
        
        return comment;
    }
    
    private boolean mergeGitLabMergeRequest(
        GitRepository repository, 
        GitRemote remote, 
        int mergeRequestId, 
        String commitMessage
    ) {
        String repoPath = extractOwnerAndRepo(remote.getUrl(), GitProvider.GITLAB);
        String encodedPath = repoPath.replace("/", "%2F");
        String apiUrl = "https://gitlab.com/api/v4/projects/" + encodedPath + 
                        "/merge_requests/" + mergeRequestId + "/merge";
        
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("merge_commit_message", commitMessage);
        
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(requestBody, headers);
        
        try {
            ResponseEntity<Map> response = restTemplate.exchange(
                apiUrl,
                HttpMethod.PUT,
                requestEntity,
                Map.class
            );
            
            return response.getStatusCode().is2xxSuccessful();
        } catch (Exception e) {
            return false;
        }
    }
    
    /*
     * Azure DevOps API implementation 
     */
    
    private GitPullRequest createAzureDevOpsPullRequest(
        GitRepository repository,
        GitRemote remote,
        String title,
        String description,
        String sourceBranch,
        String targetBranch,
        List<String> reviewers
    ) {
        // Extract org/project/repo from URL
        String[] adoParts = extractOwnerAndRepo(remote.getUrl(), GitProvider.AZURE_DEVOPS).split("/");
        if (adoParts.length < 3) {
            throw new IllegalArgumentException("Invalid Azure DevOps repository URL");
        }
        
        String organization = adoParts[0];
        String project = adoParts[1];
        String repoName = adoParts[2];
        
        // Format branches as refs
        if (!sourceBranch.startsWith("refs/heads/")) {
            sourceBranch = "refs/heads/" + sourceBranch;
        }
        
        if (!targetBranch.startsWith("refs/heads/")) {
            targetBranch = "refs/heads/" + targetBranch;
        }
        
        String apiUrl = "https://dev.azure.com/" + organization + "/" + project + 
                        "/_apis/git/repositories/" + repoName + "/pullrequests?api-version=7.0";
        
        // Create request body
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("sourceRefName", sourceBranch);
        requestBody.put("targetRefName", targetBranch);
        requestBody.put("title", title);
        requestBody.put("description", description);
        
        // Add reviewers if specified
        if (reviewers != null && !reviewers.isEmpty()) {
            List<Map<String, Object>> reviewersList = new ArrayList<>();
            
            for (String reviewer : reviewers) {
                // In a real implementation, you'd need to get the reviewer's
                // descriptor from their name/email using a separate API call
                Map<String, Object> reviewerObj = new HashMap<>();
                reviewerObj.put("id", reviewer); // Simplified - this should be a UUID
                reviewersList.add(reviewerObj);
            }
            
            requestBody.put("reviewers", reviewersList);
        }
        
        // Send request
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(requestBody, headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            apiUrl,
            HttpMethod.POST,
            requestEntity,
            Map.class
        );
        
        // Parse response
        Map<String, Object> responseBody = response.getBody();
        int pullRequestId = ((Number) responseBody.get("pullRequestId")).intValue();
        
        // Return created pull request
        return getAzureDevOpsPullRequest(repository, remote, pullRequestId);
    }
    
    private List<GitPullRequest> getAzureDevOpsPullRequests(GitRepository repository, GitRemote remote) {
        // Extract org/project/repo from URL
        String[] adoParts = extractOwnerAndRepo(remote.getUrl(), GitProvider.AZURE_DEVOPS).split("/");
        if (adoParts.length < 3) {
            throw new IllegalArgumentException("Invalid Azure DevOps repository URL");
        }
        
        String organization = adoParts[0];
        String project = adoParts[1];
        String repoName = adoParts[2];
        
        String apiUrl = "https://dev.azure.com/" + organization + "/" + project + 
                        "/_apis/git/repositories/" + repoName + "/pullrequests?api-version=7.0";
        
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<String> requestEntity = new HttpEntity<>(headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            apiUrl,
            HttpMethod.GET,
            requestEntity,
            Map.class
        );
        
        Map<String, Object> responseBody = response.getBody();
        List<Map<String, Object>> pullRequests = (List<Map<String, Object>>) responseBody.get("value");
        List<GitPullRequest> result = new ArrayList<>();
        
        for (Map<String, Object> pr : pullRequests) {
            GitPullRequest pullRequest = parseAzureDevOpsPullRequest(pr);
            result.add(pullRequest);
        }
        
        return result;
    }
    
    private GitPullRequest getAzureDevOpsPullRequest(
        GitRepository repository, 
        GitRemote remote, 
        int pullRequestId
    ) {
        // Extract org/project/repo from URL
        String[] adoParts = extractOwnerAndRepo(remote.getUrl(), GitProvider.AZURE_DEVOPS).split("/");
        if (adoParts.length < 3) {
            throw new IllegalArgumentException("Invalid Azure DevOps repository URL");
        }
        
        String organization = adoParts[0];
        String project = adoParts[1];
        String repoName = adoParts[2];
        
        String apiUrl = "https://dev.azure.com/" + organization + "/" + project + 
                        "/_apis/git/repositories/" + repoName + "/pullrequests/" + 
                        pullRequestId + "?api-version=7.0";
        
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<String> requestEntity = new HttpEntity<>(headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            apiUrl,
            HttpMethod.GET,
            requestEntity,
            Map.class
        );
        
        Map<String, Object> pullRequestData = response.getBody();
        return parseAzureDevOpsPullRequest(pullRequestData);
    }
    
    private GitPullRequest parseAzureDevOpsPullRequest(Map<String, Object> pullRequestData) {
        GitPullRequest pullRequest = new GitPullRequest();
        
        pullRequest.setId(((Number) pullRequestData.get("pullRequestId")).intValue());
        pullRequest.setTitle((String) pullRequestData.get("title"));
        pullRequest.setDescription((String) pullRequestData.get("description"));
        
        pullRequest.setSourceBranch((String) pullRequestData.get("sourceRefName"));
        pullRequest.setTargetBranch((String) pullRequestData.get("targetRefName"));
        
        // Strip "refs/heads/" prefix for display
        if (pullRequest.getSourceBranch().startsWith("refs/heads/")) {
            pullRequest.setSourceBranch(pullRequest.getSourceBranch().substring("refs/heads/".length()));
        }
        
        if (pullRequest.getTargetBranch().startsWith("refs/heads/")) {
            pullRequest.setTargetBranch(pullRequest.getTargetBranch().substring("refs/heads/".length()));
        }
        
        String status = (String) pullRequestData.get("status");
        switch (status) {
            case "active":
                pullRequest.setState("Open");
                break;
            case "completed":
                // Check if merged or abandoned (closed)
                boolean abandoned = pullRequestData.containsKey("closedDate") && 
                                   !pullRequestData.containsKey("mergeCommitId");
                pullRequest.setState(abandoned ? "Closed" : "Merged");
                break;
            case "abandoned":
                pullRequest.setState("Closed");
                break;
            default:
                pullRequest.setState(status);
        }
        
        Map<String, Object> createdBy = (Map<String, Object>) pullRequestData.get("createdBy");
        pullRequest.setAuthor((String) createdBy.get("displayName"));
        
        // Parse dates
        pullRequest.setCreatedDate(new Date(Date.parse((String) pullRequestData.get("creationDate"))));
        
        if (pullRequestData.containsKey("closedDate")) {
            Date closedDate = new Date(Date.parse((String) pullRequestData.get("closedDate")));
            pullRequest.setUpdatedDate(closedDate);
            
            // If merged, set merged date
            if (pullRequestData.containsKey("mergeCommitId")) {
                pullRequest.setMergedDate(closedDate);
            }
        }
        
        return pullRequest;
    }
    
    private GitComment addAzureDevOpsPullRequestComment(
        GitRepository repository, 
        GitRemote remote, 
        int pullRequestId, 
        String content
    ) {
        // Extract org/project/repo from URL
        String[] adoParts = extractOwnerAndRepo(remote.getUrl(), GitProvider.AZURE_DEVOPS).split("/");
        if (adoParts.length < 3) {
            throw new IllegalArgumentException("Invalid Azure DevOps repository URL");
        }
        
        String organization = adoParts[0];
        String project = adoParts[1];
        String repoName = adoParts[2];
        
        // In Azure DevOps, we need to first get the thread ID or create a new thread
        String threadsUrl = "https://dev.azure.com/" + organization + "/" + project + 
                          "/_apis/git/repositories/" + repoName + "/pullRequests/" + 
                          pullRequestId + "/threads?api-version=7.0";
        
        // Create a new thread
        Map<String, Object> threadBody = new HashMap<>();
        threadBody.put("comments", Collections.singletonList(
            Collections.singletonMap("content", content)
        ));
        
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(threadBody, headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            threadsUrl,
            HttpMethod.POST,
            requestEntity,
            Map.class
        );
        
        Map<String, Object> responseBody = response.getBody();
        List<Map<String, Object>> comments = (List<Map<String, Object>>) responseBody.get("comments");
        Map<String, Object> commentData = comments.get(0);
        
        GitComment comment = new GitComment();
        comment.setId(String.valueOf(commentData.get("id")));
        comment.setContent((String) commentData.get("content"));
        
        Map<String, Object> author = (Map<String, Object>) commentData.get("author");
        comment.setAuthor((String) author.get("displayName"));
        
        comment.setCreatedDate(new Date(Date.parse((String) commentData.get("publishedDate"))));
        comment.setUpdatedDate(new Date(Date.parse((String) commentData.get("lastUpdatedDate"))));
        
        return comment;
    }
    
    private boolean mergeAzureDevOpsPullRequest(
        GitRepository repository, 
        GitRemote remote, 
        int pullRequestId, 
        String commitMessage
    ) {
        // Extract org/project/repo from URL
        String[] adoParts = extractOwnerAndRepo(remote.getUrl(), GitProvider.AZURE_DEVOPS).split("/");
        if (adoParts.length < 3) {
            throw new IllegalArgumentException("Invalid Azure DevOps repository URL");
        }
        
        String organization = adoParts[0];
        String project = adoParts[1];
        String repoName = adoParts[2];
        
        String apiUrl = "https://dev.azure.com/" + organization + "/" + project + 
                        "/_apis/git/repositories/" + repoName + "/pullrequests/" + 
                        pullRequestId + "?api-version=7.0";
        
        // First get the PR to get its current state
        HttpHeaders headers = createAuthHeaders(remote);
        HttpEntity<String> getEntity = new HttpEntity<>(headers);
        
        ResponseEntity<Map> getResponse = restTemplate.exchange(
            apiUrl,
            HttpMethod.GET,
            getEntity,
            Map.class
        );
        
        Map<String, Object> prData = getResponse.getBody();
        
        // Create the update request
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("status", "completed");
        
        // Add completion options
        Map<String, Object> completionOptions = new HashMap<>();
        completionOptions.put("deleteSourceBranch", false); // Don't delete source branch
        completionOptions.put("mergeCommitMessage", commitMessage);
        completionOptions.put("squash", false); // Don't squash commits
        
        requestBody.put("completionOptions", completionOptions);
        
        // Update the last merge source commit
        requestBody.put("lastMergeSourceCommit", prData.get("lastMergeSourceCommit"));
        
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(requestBody, headers);
        
        try {
            ResponseEntity<Map> response = restTemplate.exchange(
                apiUrl,
                HttpMethod.PATCH,
                requestEntity,
                Map.class
            );
            
            return response.getStatusCode().is2xxSuccessful();
        } catch (Exception e) {
            return false;
        }
    }
}

    /**
     * Create a pull request on the remote Git provider
     */
    public CompletableFuture<GitPullRequest> createPullRequest(
        String repositoryId,
        String title,
        String description,
        String sourceBranch,
        String targetBranch,
        List<String> reviewers
    ) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Get repository info
                GitRepository repository = repositoryService.getRepository(repositoryId);
                if (repository == null) {
                    throw new IllegalArgumentException("Repository not found: " + repositoryId);
                }
                
                // Ensure we have at least one remote
                if (repository.getRemotes().isEmpty()) {
                    throw new IllegalStateException("Repository has no remotes configured");
                }
                
                // Get the remote (assuming first one is the primary)
                GitRemote remote = repository.getRemotes().get(0);
                
                // Detect Git provider from URL
                GitProvider provider = detectGitProvider(remote.getUrl());
                
                // Create pull request based on provider
                switch (provider) {
                    case GITHUB:
                        return createGitHubPullRequest(
                            repository, remote, title, description, sourceBranch, targetBranch, reviewers);
                    case GITLAB:
                        return createGitLabMergeRequest(
                            repository, remote, title, description, sourceBranch, targetBranch, reviewers);
                    case AZURE_DEVOPS:
                        return createAzureDevOpsPullRequest(
                            repository, remote, title, description, sourceBranch, targetBranch, reviewers);
                    default:
                        throw new UnsupportedOperationException(
                            "Pull request creation not supported for this Git provider");
                }
            } catch (Exception e) {
                throw new RuntimeException("Failed to create pull request: " + e.getMessage(), e);
            }
        }, executor);
    }
    
    /**
     * Get pull requests for the repository
     */
    public CompletableFuture<List<GitPullRequest>> getPullRequests(String repositoryId) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Get repository info
                GitRepository repository = repositoryService.getRepository(repositoryId);
                if (repository == null) {
                    throw new IllegalArgumentException("Repository not found: " + repositoryId);
                }
                
                // Ensure we have at least one remote
                if (repository.getRemotes().isEmpty()) {
                    return Collections.emptyList();
                }
                
                // Get the remote (assuming first one is the primary)
                GitRemote remote = repository.getRemotes().get(0);
                
                // Detect Git provider from URL
                GitProvider provider = detectGitProvider(remote.getUrl());
                
                // Get pull requests based on provider
                switch (provider) {
                    case GITHUB:
                        return getGitHubPullRequests(repository, remote);
                    case GITLAB:
                        return getGitLabMergeRequests(repository, remote);
                    case AZURE_DEVOPS:
                        return getAzureDevOpsPullRequests(repository, remote);
                    default:
                        return Collections.emptyList();
                }
            } catch (Exception e) {
                throw new RuntimeException("Failed to get pull requests: " + e.getMessage(), e);
            }
        }, executor);
    }
    
    /**
     * Get a specific pull request by ID
     */
    public CompletableFuture<GitPullRequest> getPullRequest(String repositoryId, int pullRequestId) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Get repository info
                GitRepository repository = repositoryService.getRepository(repositoryId);
                if (repository == null) {
                    throw new IllegalArgumentException("Repository not found: " + repositoryId);
                }
                
                // Ensure we have at least one remote
                if (repository.getRemotes().isEmpty()) {
                    throw new IllegalStateException("Repository has no remotes configured");
                }
                
                // Get the remote (assuming first one is the primary)
                GitRemote remote = repository.getRemotes().get(0);
                
                // Detect Git provider from URL
                GitProvider provider = detectGitProvider(remote.getUrl());
                
                // Get pull request based on provider
                switch (provider) {
                    case GITHUB:
                        return getGitHubPullRequest(repository, remote, pullRequestId);
                    case GITLAB:
                        return getGitLabMergeRequest(repository, remote, pullRequestId);
                    case AZURE_DEVOPS:
                        return getAzureDevOpsPullRequest(repository, remote, pullRequestId);
                    default:
                        throw new UnsupportedOperationException(
                            "Pull request retrieval not supported for this Git provider");
                }
            } catch (Exception e) {
                throw new RuntimeException("Failed to get pull request: " + e.getMessage(), e);
            }
        }, executor);
    }
    
    /**
     * Add a comment to a pull request
     */
    public CompletableFuture<GitComment> addPullRequestComment(
        String repositoryId,
        int pullRequestId,
        String content
    ) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Get repository info
                GitRepository repository = repositoryService.getRepository(repositoryId);
                if (repository == null) {
                    throw new IllegalArgumentException("Repository not found: " + repositoryId);
                }
                
                // Ensure we have at least one remote
                if (repository.getRemotes().isEmpty()) {
                    throw new IllegalStateException("Repository has no remotes configured");
                }
                
                // Get the remote (assuming first one is the primary)
                GitRemote remote = repository.getRemotes().get(0);
                
                // Detect Git provider from URL
                GitProvider provider = detectGitProvider(remote.getUrl());
                
                // Add comment based on provider
                switch (provider) {
                    case GITHUB:
                        return addGitHubPullRequestComment(repository, remote, pullRequestId, content);
                    case GITLAB:
                        return addGitLabMergeRequestComment(repository, remote, pullRequestId, content);
                    case AZURE_DEVOPS:
                        return addAzureDevOpsPullRequestComment(repository, remote, pullRequestId, content);
                    default:
                        throw new UnsupportedOperationException(
                            "Pull request commenting not supported for this Git provider");
                }
            } catch (Exception e) {
                throw new RuntimeException("Failed to add comment: " + e.getMessage(), e);
            }
        }, executor);
    }
    
    /**
     * Merge a pull request
     */
    public CompletableFuture<Boolean> mergePullRequest(
        String repositoryId,
        int pullRequestId,
        String commitMessage
    ) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Get repository info
                GitRepository repository = repositoryService.getRepository(repositoryId);
                if (repository == null) {
                    throw new IllegalArgumentException("Repository not found: " + repositoryId);
                }
                
                // Ensure we have at least one remote
                if (repository.getRemotes().isEmpty()) {
                    throw new IllegalStateException("Repository has no remotes configured");
                }
                
                // Get the remote (assuming first one is the primary)
                GitRemote remote = repository.getRemotes().get(0);
                
                // Detect Git provider from URL
                GitProvider provider = detectGitProvider(remote.getUrl());
                
                // Merge pull request based on provider
                switch (provider) {
                    case GITHUB:
                        return mergeGitHubPullRequest(repository, remote, pullRequestId, commitMessage);
                    case GITLAB:
                        return mergeGitLabMergeRequest(repository, remote, pullRequestId, commitMessage);
                    case AZURE_DEVOPS:
                        return mergeAzureDevOpsPullRequest(repository, remote, pullRequestId, commitMessage);
                    default:
                        throw new UnsupportedOperationException(
                            "Pull request merging not supported for this Git provider");
                }
            } catch (Exception e) {
                throw new RuntimeException("Failed to merge pull request: " + e.getMessage(), e);
            }
        }, executor);

// src/main/java/com/automation/api/models/integration/git/GitRepository.java
package com.automation.api.models.integration.git;

import java.util.Date;
import java.util.List;

/**
 * Represents a Git repository configuration
 */
public class GitRepository {
    private String id;
    private String name;
    private String path;
    private boolean isActive;
    private Date lastSync;
    private String status;
    private String errorMessage;
    private String defaultBranch;
    private String currentBranch;
    private List<GitRemote> remotes;
    
    // Getters and Setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getPath() {
        return path;
    }
    
    public void setPath(String path) {
        this.path = path;
    }
    
    public boolean isActive() {
        return isActive;
    }
    
    public void setActive(boolean active) {
        isActive = active;
    }
    
    public Date getLastSync() {
        return lastSync;
    }
    
    public void setLastSync(Date lastSync) {
        this.lastSync = lastSync;
    }
    
    public String getStatus() {
        return status;
    }
    
    public void setStatus(String status) {
        this.status = status;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
    
    public String getDefaultBranch() {
        return defaultBranch;
    }
    
    public void setDefaultBranch(String defaultBranch) {
        this.defaultBranch = defaultBranch;
    }
    
    public String getCurrentBranch() {
        return currentBranch;
    }
    
    public void setCurrentBranch(String currentBranch) {
        this.currentBranch = currentBranch;
    }
    
    public List<GitRemote> getRemotes() {
        return remotes;
    }
    
    public void setRemotes(List<GitRemote> remotes) {
        this.remotes = remotes;
    }
}

// src/main/java/com/automation/api/models/integration/git/GitRemote.java
package com.automation.api.models.integration.git;

/**
 * Represents a Git remote repository configuration
 */
public class GitRemote {
    private String name;
    private String url;
    private String username;
    private String authType;
    private String credentialId;
    
    // Getters and Setters
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getAuthType() {
        return authType;
    }
    
    public void setAuthType(String authType) {
        this.authType = authType;
    }
    
    public String getCredentialId() {
        return credentialId;
    }
    
    public void setCredentialId(String credentialId) {
        this.credentialId = credentialId;
    }
}

// src/main/java/com/automation/api/models/integration/git/GitCredential.java
package com.automation.api.models.integration.git;

/**
 * Represents a Git credential for authentication
 */
public class GitCredential {
    private String id;
    private String name;
    private String type;
    private String username;
    private String password;
    private String privateKey;
    private String passphrase;
    
    public GitCredential() {
    }
    
    public GitCredential(GitCredential other) {
        this.id = other.id;
        this.name = other.name;
        this.type = other.type;
        this.username = other.username;
        this.password = other.password;
        this.privateKey = other.privateKey;
        this.passphrase = other.passphrase;
    }
    
    // Getters and Setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getType() {
        return type;
    }
    
    public void setType(String type) {
        this.type = type;
    }
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(String password) {
        this.password = password;
    }
    
    public String getPrivateKey() {
        return privateKey;
    }
    
    public void setPrivateKey(String privateKey) {
        this.privateKey = privateKey;
    }
    
    public String getPassphrase() {
        return passphrase;
    }
    
    public void setPassphrase(String passphrase) {
        this.passphrase = passphrase;
    }
}

// src/main/java/com/automation/api/models/integration/git/GitFileStatus.java
package com.automation.api.models.integration.git;

/**
 * Represents the status of a file in a Git repository
 */
public class GitFileStatus {
    private String path;
    private String status;
    private String stagedStatus;
    private String oldPath;
    
    // Getters and Setters
    public String getPath() {
        return path;
    }
    
    public void setPath(String path) {
        this.path = path;
    }
    
    public String getStatus() {
        return status;
    }
    
    public void setStatus(String status) {
        this.status = status;
    }
    
    public String getStagedStatus() {
        return stagedStatus;
    }
    
    public void setStagedStatus(String stagedStatus) {
        this.stagedStatus = stagedStatus;
    }
    
    public String getOldPath() {
        return oldPath;
    }
    
    public void setOldPath(String oldPath) {
        this.oldPath = oldPath;
    }
}

// src/main/java/com/automation/api/models/integration/git/GitCommit.java
package com.automation.api.models.integration.git;

import java.util.Date;
import java.util.List;

/**
 * Represents a Git commit
 */
public class GitCommit {
    private String id;
    private String shortId;
    private String message;
    private String author;
    private String authorEmail;
    private Date authorDate;
    private String committer;
    private String committerEmail;
    private Date commitDate;
    private List<String> parents;
    private List<String> branches;
    private List<String> tags;
    
    // Getters and Setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getShortId() {
        return shortId;
    }
    
    public void setShortId(String shortId) {
        this.shortId = shortId;
    }
    
    public String getMessage() {
        return message;
    }
    
    public void setMessage(String message) {
        this.message = message;
    }
    
    public String getAuthor() {
        return author;
    }
    
    public void setAuthor(String author) {
        this.author = author;
    }
    
    public String getAuthorEmail() {
        return authorEmail;
    }
    
    public void setAuthorEmail(String authorEmail) {
        this.authorEmail = authorEmail;
    }
    
    public Date getAuthorDate() {
        return authorDate;
    }
    
    public void setAuthorDate(Date authorDate) {
        this.authorDate = authorDate;
    }
    
    public String getCommitter() {
        return committer;
    }
    
    public void setCommitter(String committer) {
        this.committer = committer;
    }
    
    public String getCommitterEmail() {
        return committerEmail;
    }
    
    public void setCommitterEmail(String committerEmail) {
        this.committerEmail = committerEmail;
    }
    
    public Date getCommitDate() {
        return commitDate;
    }
    
    public void setCommitDate(Date commitDate) {
        this.commitDate = commitDate;
    }
    
    public List<String> getParents() {
        return parents;
    }
    
    public void setParents(List<String> parents) {
        this.parents = parents;
    }
    
    public List<String> getBranches() {
        return branches;
    }
    
    public void setBranches(List<String> branches) {
        this.branches = branches;
    }
    
    public List<String> getTags() {
        return tags;
    }
    
    public void setTags(List<String> tags) {
        this.tags = tags;
    }
}

// src/main/java/com/automation/api/models/integration/git/GitBranch.java
package com.automation.api.models.integration.git;

/**
 * Represents a Git branch
 */
public class GitBranch {
    private String name;
    private String fullName;
    private boolean isRemote;
    private String remoteName;
    private String trackingBranch;
    private boolean isCurrent;
    private String latestCommit;
    private int aheadCount;
    private int behindCount;
    
    // Getters and Setters
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getFullName() {
        return fullName;
    }
    
    public void setFullName(String fullName) {
        this.fullName = fullName;
    }
    
    public boolean isRemote() {
        return isRemote;
    }
    
    public void setRemote(boolean remote) {
        isRemote = remote;
    }
    
    public String getRemoteName() {
        return remoteName;
    }
    
    public void setRemoteName(String remoteName) {
        this.remoteName = remoteName;
    }
    
    public String getTrackingBranch() {
        return trackingBranch;
    }
    
    public void setTrackingBranch(String trackingBranch) {
        this.trackingBranch = trackingBranch;
    }
    
    public boolean isCurrent() {
        return isCurrent;
    }
    
    public void setCurrent(boolean current) {
        isCurrent = current;
    }
    
    public String getLatestCommit() {
        return latestCommit;
    }
    
    public void setLatestCommit(String latestCommit) {
        this.latestCommit = latestCommit;
    }
    
    public int getAheadCount() {
        return aheadCount;
    }
    
    public void setAheadCount(int aheadCount) {
        this.aheadCount = aheadCount;
    }
    
    public int getBehindCount() {
        return behindCount;
    }
    
    public void setBehindCount(int behindCount) {
        this.behindCount = behindCount;
    }
}

// src/main/java/com/automation/api/models/integration/git/GitPullRequest.java
package com.automation.api.models.integration.git;

import java.util.Date;
import java.util.List;

/**
 * Represents a Git pull request
 */
public class GitPullRequest {
    private int id;
    private String title;
    private String description;
    private String sourceBranch;
    private String targetBranch;
    private String state;
    private String author;
    private Date createdDate;
    private Date updatedDate;
    private Date mergedDate;
    private List<GitComment> comments;
    private List<GitReviewer> reviewers;
    private List<String> commitIds;
    
    // Getters and Setters
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getTitle() {
        return title;
    }
    
    public void setTitle(String title) {
        this.title = title;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public String getSourceBranch() {
        return sourceBranch;
    }
    
    public void setSourceBranch(String sourceBranch) {
        this.sourceBranch = sourceBranch;
    }
    
    public String getTargetBranch() {
        return targetBranch;
    }
    
    public void setTargetBranch(String targetBranch) {
        this.targetBranch = targetBranch;
    }
    
    public String getState() {
        return state;
    }
    
    public void setState(String state) {
        this.state = state;
    }
    
    public String getAuthor() {
        return author;
    }
    
    public void setAuthor(String author) {
        this.author = author;
    }
    
    public Date getCreatedDate() {
        return createdDate;
    }
    
    public void setCreatedDate(Date createdDate) {
        this.createdDate = createdDate;
    }
    
    public Date getUpdatedDate() {
        return updatedDate;
    }
    
    public void setUpdatedDate(Date updatedDate) {
        this.updatedDate = updatedDate;
    }
    
    public Date getMergedDate() {
        return mergedDate;
    }
    
    public void setMergedDate(Date mergedDate) {
        this.mergedDate = mergedDate;
    }
    
    public List<GitComment> getComments() {
        return comments;
    }
    
    public void setComments(List<GitComment> comments) {
        this.comments = comments;
    }
    
    public List<GitReviewer> getReviewers() {
        return reviewers;
    }
    
    public void setReviewers(List<GitReviewer> reviewers) {
        this.reviewers = reviewers;
    }
    
    public List<String> getCommitIds() {
        return commitIds;
    }
    
    public void setCommitIds(List<String> commitIds) {
        this.commitIds = commitIds;
    }
}

// src/main/java/com/automation/api/models/integration/git/GitComment.java
package com.automation.api.models.integration.git;

import java.util.Date;

/**
 * Represents a comment on a Git pull request
 */
public class GitComment {
    private String id;
    private String content;
    private String author;
    private Date createdDate;
    private Date updatedDate;
    private String path;
    private Integer line;
    private Integer position;
    
    // Getters and Setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getContent() {
        return content;
    }
    
    public void setContent(String content) {
        this.content = content;
    }
    
    public String getAuthor() {
        return author;
    }
    
    public void setAuthor(String author) {
        this.author = author;
    }
    
    public Date getCreatedDate() {
        return createdDate;
    }
    
    public void setCreatedDate(Date createdDate) {
        this.createdDate = createdDate;
    }
    
    public Date getUpdatedDate() {
        return updatedDate;
    }
    
    public void setUpdatedDate(Date updatedDate) {
        this.updatedDate = updatedDate;
    }
    
    public String getPath() {
        return path;
    }
    
    public void setPath(String path) {
        this.path = path;
    }
    
    public Integer getLine() {
        return line;
    }
    
    public void setLine(Integer line) {
        this.line = line;
    }
    
    public Integer getPosition() {
        return position;
    }
    
    public void setPosition(Integer position) {
        this.position = position;
    }
}

// src/main/java/com/automation/api/models/integration/git/GitReviewer.java
package com.automation.api.models.integration.git;

import java.util.Date;

/**
 * Represents a reviewer on a Git pull request
 */
public class GitReviewer {
    private String username;
    private String state;
    private Date date;
    private String comments;
    
    // Getters and Setters
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getState() {
        return state;
    }
    
    public void setState(String state) {
        this.state = state;
    }
    
    public Date getDate() {
        return date;
    }
    
    public void setDate(Date date) {
        this.date = date;
    }
    
    public String getComments() {
        return comments;
    }
    
    public void setComments(String comments) {
        this.comments = comments;
    }
}

// src/main/java/com/automation/api/services/integration/git/GitSynchronizationService.java
package com.automation.api.services.integration.git;

import com.automation.api.models.integration.git.*;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.MergeResult;
import org.eclipse.jgit.api.PullResult;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.transport.FetchResult;
import org.eclipse.jgit.transport.PushResult;
import org.eclipse.jgit.transport.RemoteRefUpdate;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

/**
 * Service for handling Git synchronization operations
 */
@Service
public class GitSynchronizationService {

    private final GitRepositoryService repositoryService;
    private final GitCredentialService credentialService;
    private final Executor executor = Executors.newFixedThreadPool(5);

    @Autowired
    public GitSynchronizationService(
        GitRepositoryService repositoryService,
        GitCredentialService credentialService
    ) {
        this.repositoryService = repositoryService;
        this.credentialService = credentialService;
    }

    /**
     * Synchronize the repository with the remote
     * This involves pulling changes from the remote and then pushing local changes
     */
    public CompletableFuture<SyncResult> synchronize(String repositoryId) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Open repository
                GitRepository repository = repositoryService.openRepository(repositoryId);
                
                if (repository.getRemotes().isEmpty()) {
                    return new SyncResult(false, "No remotes configured", null, null);
                }
                
                // Get default remote
                GitRemote remote = repository.getRemotes().get(0);
                
                // Get credentials
                String username = null;
                String password = null;
                
                if (remote.getAuthType().equals("HTTPS") || remote.getAuthType().equals("PAT")) {
                    if (remote.getCredentialId() != null) {
                        GitCredential credential = credentialService.getCredential(remote.getCredentialId());
                        if (credential != null) {
                            username = credential.getUsername();
                            password = credential.getPassword();
                        }
                    } else if (remote.getUsername() != null) {
                        username = remote.getUsername();
                        // Password would need to be provided by the user
                    }
                }
                
                // Pull first
                PullResult pullResult = pull(repositoryId, remote.getName(), username, password);
                
                // Check for conflicts
                if (pullResult.getMergeResult() != null && 
                    pullResult.getMergeResult().getMergeStatus() == MergeResult.MergeStatus.CONFLICTING) {
                    return new SyncResult(
                        false, 
                        "Merge conflicts detected", 
                        pullResult, 
                        null
                    );
                }
                
                // Push changes
                PushResult pushResult = push(
                    repositoryId, 
                    remote.getName(), 
                    repository.getCurrentBranch(), 
                    username, 
                    password
                );
                
                // Check push results
                boolean success = true;
                String message = "Synchronization completed";
                
                Collection<RemoteRefUpdate> updates = pushResult.getRemoteUpdates();
                for (RemoteRefUpdate update : updates) {
                    if (update.getStatus() != RemoteRefUpdate.Status.OK && 
                        update.getStatus() != RemoteRefUpdate.Status.UP_TO_DATE) {
                        success = false;
                        message = "Push failed: " + update.getStatus().name();
                        break;
                    }
                }
                
                return new SyncResult(success, message, pullResult, pushResult);
                
            } catch (IOException | GitAPIException e) {
                return new SyncResult(false, e.getMessage(), null, null);
            }
        }, executor);
    }

    /**
     * Pull changes from the remote repository
     */
    public PullResult pull(
        String repositoryId,
        String remoteName,
        String username,
        String password
    ) throws IOException, GitAPIException {
        // Get Git instance
        Git git = repositoryService.getGitInstance(repositoryId);
        
        // Create pull command
        org.eclipse.jgit.api.PullCommand pullCommand = git.pull()
            .setRemote(remoteName);
        
        // Set credentials if provided
        if (username != null && !username.isEmpty()) {
            pullCommand.setCredentialsProvider(
                new UsernamePasswordCredentialsProvider(username, password));
        }
        
        // Pull
        PullResult result = pullCommand.call();
        
        // Update repository status
        GitRepository repository = repositoryService.getRepository(repositoryId);
        repository.setLastSync(new Date());
        repositoryService.updateRepository(repository);
        
        return result;
    }

    /**
     * Push changes to the remote repository
     */
    public PushResult push(
        String repositoryId,
        String remoteName,
        String branchName,
        String username,
        String password
    ) throws IOException, GitAPIException {
        // Get Git instance
        Git git = repositoryService.getGitInstance(repositoryId);
        
        // Create push command
        org.eclipse.jgit.api.PushCommand pushCommand = git.push()
            .setRemote(remoteName)
            .setRefSpecs(new org.eclipse.jgit.transport.RefSpec(branchName + ":" + branchName));
        
        // Set credentials if provided
        if (username != null && !username.isEmpty()) {
            pushCommand.setCredentialsProvider(
                new UsernamePasswordCredentialsProvider(username, password));
        }
        
        // Push
        Iterable<PushResult> results = pushCommand.call();
        PushResult result = results.iterator().next();
        
        // Update repository status
        GitRepository repository = repositoryService.getRepository(repositoryId);
        repository.setLastSync(new Date());
        repositoryService.updateRepository(repository);
        
        return result;
    }

    /**
     * Fetch changes from all remotes
     */
    public CompletableFuture<List<GitBranch>> fetchRemotes(String repositoryId) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Open repository
                GitRepository repository = repositoryService.openRepository(repositoryId);
                
                if (repository.getRemotes().isEmpty()) {
                    return repositoryService.getBranches(repositoryId);
                }
                
                // Get git instance
                Git git = repositoryService.getGitInstance(repositoryId);
                
                // Fetch from all remotes
                for (GitRemote remote : repository.getRemotes()) {
                    // Get credentials
                    String username = null;
                    String password = null;
                    
                    if (remote.getAuthType().equals("HTTPS") || remote.getAuthType().equals("PAT")) {
                        if (remote.getCredentialId() != null) {
                            GitCredential credential = credentialService.getCredential(remote.getCredentialId());
                            if (credential != null) {
                                username = credential.getUsername();
                                password = credential.getPassword();
                            }
                        } else if (remote.getUsername() != null) {
                            username = remote.getUsername();
                            // Password would need to be provided by the user
                        }
                    }
                    
                    // Fetch
                    org.eclipse.jgit.api.FetchCommand fetchCommand = git.fetch()
                        .setRemote(remote.getName());
                    
                    if (username != null && !username.isEmpty()) {
                        fetchCommand.setCredentialsProvider(
                            new UsernamePasswordCredentialsProvider(username, password));
                    }
                    
                    fetchCommand.call();
                }
                
                // Return updated branches
                return repositoryService.getBranches(repositoryId);
                
            } catch (IOException | GitAPIException e) {
                throw new RuntimeException("Failed to fetch remotes: " + e.getMessage(), e);
            }
        }, executor);
    }

    /**
     * Result of a synchronization operation
     */
    public static class SyncResult {
        private final boolean success;
        private final String message;
        private final PullResult pullResult;
        private final PushResult pushResult;
        
        public SyncResult(boolean success, String message, PullResult pullResult, PushResult pushResult) {
            this.success = success;
            this.message = message;
            this.pullResult = pullResult;
            this.pushResult = pushResult;
        }
        
        public boolean isSuccess() {
            return success;
        }
        
        public String getMessage() {
            return message;
        }
        
        public PullResult getPullResult() {
            return pullResult;
        }
        
        public PushResult getPushResult() {
            return pushResult;
        }
    }
}


// src/main/java/com/automation/api/services/integration/git/GitCredentialService.java
package com.automation.api.services.integration.git;

import com.automation.api.models.integration.git.GitCredential;
import com.automation.api.services.core.EncryptionService;
import com.automation.api.services.core.FileSystemService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Service for managing Git credentials securely
 */
@Service
public class GitCredentialService {

    private final FileSystemService fileSystemService;
    private final EncryptionService encryptionService;
    private final ObjectMapper objectMapper;
    private final Map<String, GitCredential> credentials = new ConcurrentHashMap<>();

    @Autowired
    public GitCredentialService(
        FileSystemService fileSystemService,
        EncryptionService encryptionService,
        ObjectMapper objectMapper
    ) {
        this.fileSystemService = fileSystemService;
        this.encryptionService = encryptionService;
        this.objectMapper = objectMapper;
        
        loadCredentials();
    }

    /**
     * Load all credentials from storage
     */
    private void loadCredentials() {
        try {
            Path credsDir = Paths.get(fileSystemService.getApplicationDataPath(), "git_credentials");
            Files.createDirectories(credsDir);
            
            Files.list(credsDir)
                .filter(path -> path.toString().endsWith(".json"))
                .forEach(path -> {
                    try {
                        GitCredential credential = objectMapper.readValue(path.toFile(), GitCredential.class);
                        
                        // Decrypt sensitive data
                        if (credential.getPassword() != null) {
                            credential.setPassword(encryptionService.decrypt(credential.getPassword()));
                        }
                        
                        if (credential.getPrivateKey() != null) {
                            credential.setPrivateKey(encryptionService.decrypt(credential.getPrivateKey()));
                        }
                        
                        if (credential.getPassphrase() != null) {
                            credential.setPassphrase(encryptionService.decrypt(credential.getPassphrase()));
                        }
                        
                        credentials.put(credential.getId(), credential);
                    } catch (IOException e) {
                        System.err.println("Error loading Git credential: " + e.getMessage());
                    }
                });
        } catch (IOException e) {
            System.err.println("Error loading Git credentials: " + e.getMessage());
        }
    }

    /**
     * Save a credential to storage
     */
    private void saveCredential(GitCredential credential) throws IOException {
        // Create a copy for saving to encrypt sensitive data
        GitCredential credentialToSave = new GitCredential(credential);
        
        // Encrypt sensitive data
        if (credentialToSave.getPassword() != null) {
            credentialToSave.setPassword(encryptionService.encrypt(credentialToSave.getPassword()));
        }
        
        if (credentialToSave.getPrivateKey() != null) {
            credentialToSave.setPrivateKey(encryptionService.encrypt(credentialToSave.getPrivateKey()));
        }
        
        if (credentialToSave.getPassphrase() != null) {
            credentialToSave.setPassphrase(encryptionService.encrypt(credentialToSave.getPassphrase()));
        }
        
        Path credsDir = Paths.get(fileSystemService.getApplicationDataPath(), "git_credentials");
        Files.createDirectories(credsDir);
        
        Path credFile = credsDir.resolve(credential.getId() + ".json");
        objectMapper.writeValue(credFile.toFile(), credentialToSave);
        
        // Update cache
        credentials.put(credential.getId(), credential);
    }

    /**
     * Get all credentials (without sensitive data)
     */
    public List<GitCredential> getCredentials() {
        // Create copies without sensitive data
        List<GitCredential> result = new ArrayList<>();
        
        for (GitCredential credential : credentials.values()) {
            GitCredential copy = new GitCredential(credential);
            copy.setPassword(null);
            copy.setPrivateKey(null);
            copy.setPassphrase(null);
            result.add(copy);
        }
        
        return result;
    }

    /**
     * Get a credential by ID (with sensitive data)
     */
    public GitCredential getCredential(String credentialId) {
        return credentials.get(credentialId);
    }

    /**
     * Create a new credential
     */
    public GitCredential createCredential(GitCredential credential) throws IOException {
        // Generate ID if not provided
        if (credential.getId() == null || credential.getId().isEmpty()) {
            credential.setId(UUID.randomUUID().toString());
        }
        
        // Save credential
        saveCredential(credential);
        
        return credential;
    }

    /**
     * Update an existing credential
     */
    public GitCredential updateCredential(String credentialId, GitCredential credential) throws IOException {
        if (!credentials.containsKey(credentialId)) {
            throw new IllegalArgumentException("Credential not found: " + credentialId);
        }
        
        credential.setId(credentialId);
        
        // Save credential
        saveCredential(credential);
        
        return credential;
    }

    /**
     * Delete a credential
     */
    public void deleteCredential(String credentialId) throws IOException {
        if (!credentials.containsKey(credentialId)) {
            throw new IllegalArgumentException("Credential not found: " + credentialId);
        }
        
        // Delete file
        Path credsDir = Paths.get(fileSystemService.getApplicationDataPath(), "git_credentials");
        Path credFile = credsDir.resolve(credentialId + ".json");
        Files.deleteIfExists(credFile);
        
        // Remove from cache
        credentials.remove(credentialId);
    }

    /**
     * Test if a credential is valid
     */
    public boolean testCredential(GitCredential credential) {
        // This would typically test the credential with a Git server
        // For now, just return true if the credential has required fields based on type
        switch (credential.getType()) {
            case "HTTPS":
            case "PAT":
                return credential.getUsername() != null && credential.getPassword() != null;
            case "SSH":
                return credential.getPrivateKey() != null;
            default:
                return false;
        }
    }

    /**
     * Get a credential provider for JGit operations
     */
    public org.eclipse.jgit.transport.CredentialsProvider getCredentialProvider(String credentialId) {
        GitCredential credential = getCredential(credentialId);
        if (credential == null) {
            return null;
        }
        
        switch (credential.getType()) {
            case "HTTPS":
            case "PAT":
                return new org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider(
                    credential.getUsername(),
                    credential.getPassword()
                );
            case "SSH":
                // JGit doesn't have a built-in SSH credential provider that works with in-memory keys
                // In a real implementation, this would need to be handled using a custom provider
                return null;
            default:
                return null;
        }
    }

    /**
     * Get a credential provider for a remote
     */
    public org.eclipse.jgit.transport.CredentialsProvider getCredentialProviderForRemote(GitRemote remote) {
        if (remote.getCredentialId() != null) {
            return getCredentialProvider(remote.getCredentialId());
        } else if (remote.getUsername() != null && remote.getAuthType().equals("HTTPS")) {
            // This is a simplified case where username is provided but password would be prompted
            // In a real implementation, you'd need to handle password prompting
            return null;
        }
        
        return null;
    }
}


// src/main/java/com/automation/api/controllers/integration/GitController.java
package com.automation.api.controllers.integration;

import com.automation.api.models.integration.git.*;
import com.automation.api.services.integration.git.*;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * REST API controller for Git integration operations
 */
@RestController
@RequestMapping("/api/git")
public class GitController {

    private final GitRepositoryService repositoryService;
    private final GitSynchronizationService synchronizationService;
    private final GitCredentialService credentialService;
    private final GitCollaborationService collaborationService;

    @Autowired
    public GitController(
        GitRepositoryService repositoryService,
        GitSynchronizationService synchronizationService,
        GitCredentialService credentialService,
        GitCollaborationService collaborationService
    ) {
        this.repositoryService = repositoryService;
        this.synchronizationService = synchronizationService;
        this.credentialService = credentialService;
        this.collaborationService = collaborationService;
    }

    //
    // Repository management endpoints
    //

    @GetMapping("/repositories")
    public List<GitRepository> getRepositories() {
        return repositoryService.getRepositories();
    }

    @GetMapping("/repositories/{id}")
    public GitRepository getRepository(@PathVariable String id) {
        return repositoryService.getRepository(id);
    }

    @PostMapping("/repositories/init")
    public ResponseEntity<GitRepository> initRepository(
        @RequestParam String projectId,
        @RequestParam String name
    ) {
        try {
            GitRepository repository = repositoryService.initRepository(projectId, name);
            return ResponseEntity.ok(repository);
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PostMapping("/repositories/clone")
    public ResponseEntity<GitRepository> cloneRepository(
        @RequestParam String projectId,
        @RequestParam String name,
        @RequestParam String url,
        @RequestParam(required = false) String username,
        @RequestParam(required = false) String password,
        @RequestParam(required = false) String branch
    ) {
        try {
            GitRepository repository = repositoryService.cloneRepository(
                projectId, name, url, username, password, branch);
            return ResponseEntity.ok(repository);
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    //
    // Branch management endpoints
    //

    @GetMapping("/repositories/{id}/branches")
    public ResponseEntity<List<GitBranch>> getBranches(@PathVariable String id) {
        try {
            List<GitBranch> branches = repositoryService.getBranches(id);
            return ResponseEntity.ok(branches);
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PostMapping("/repositories/{id}/branches")
    public ResponseEntity<GitBranch> createBranch(
        @PathVariable String id,
        @RequestParam String name,
        @RequestParam(defaultValue = "true") boolean checkout
    ) {
        try {
            GitBranch branch = repositoryService.createBranch(id, name, checkout);
            return ResponseEntity.ok(branch);
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PostMapping("/repositories/{id}/branches/checkout")
    public ResponseEntity<GitBranch> checkoutBranch(
        @PathVariable String id,
        @RequestParam String name
    ) {
        try {
            GitBranch branch = repositoryService.checkoutBranch(id, name);
            return ResponseEntity.ok(branch);
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    //
    // File and commit endpoints
    //

    @GetMapping("/repositories/{id}/status")
    public ResponseEntity<List<GitFileStatus>> getStatus(@PathVariable String id) {
        try {
            List<GitFileStatus> status = repositoryService.getStatus(id);
            return ResponseEntity.ok(status);
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PostMapping("/repositories/{id}/stage")
    public ResponseEntity<Void> stageFiles(
        @PathVariable String id,
        @RequestBody List<String> filePaths
    ) {
        try {
            repositoryService.stageFiles(id, filePaths);
            return ResponseEntity.ok().build();
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    @PostMapping("/repositories/{id}/unstage")
    public ResponseEntity<Void> unstageFiles(
        @PathVariable String id,
        @RequestBody List<String> filePaths
    ) {
        try {
            repositoryService.unstageFiles(id, filePaths);
            return ResponseEntity.ok().build();
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    @PostMapping("/repositories/{id}/commit")
    public ResponseEntity<GitCommit> commit(
        @PathVariable String id,
        @RequestParam String message,
        @RequestParam String authorName,
        @RequestParam String authorEmail
    ) {
        try {
            GitCommit commit = repositoryService.commit(id, message, authorName, authorEmail);
            return ResponseEntity.ok(commit);
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @GetMapping("/repositories/{id}/commits")
    public ResponseEntity<List<GitCommit>> getCommits(
        @PathVariable String id,
        @RequestParam(defaultValue = "50") int maxCount
    ) {
        try {
            List<GitCommit> commits = repositoryService.getCommitHistory(id, maxCount);
            return ResponseEntity.ok(commits);
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    //
    // Remote management endpoints
    //

    @PostMapping("/repositories/{id}/remotes")
    public ResponseEntity<GitRepository> addRemote(
        @PathVariable String id,
        @RequestParam String name,
        @RequestParam String url,
        @RequestParam(required = false) String username,
        @RequestParam(required = false) String authType
    ) {
        try {
            GitRepository repository = repositoryService.addRemote(id, name, url, username, 
                                                                authType != null ? authType : "None");
            return ResponseEntity.ok(repository);
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @DeleteMapping("/repositories/{id}/remotes/{remoteName}")
    public ResponseEntity<GitRepository> removeRemote(
        @PathVariable String id,
        @PathVariable String remoteName
    ) {
        try {
            GitRepository repository = repositoryService.removeRemote(id, remoteName);
            return ResponseEntity.ok(repository);
        } catch (IOException | GitAPIException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    //
    // Synchronization endpoints
    //

    @PostMapping("/repositories/{id}/sync")
    public CompletableFuture<ResponseEntity<Map<String, Object>>> synchronize(@PathVariable String id) {
        return synchronizationService.synchronize(id)
            .thenApply(result -> {
                Map<String, Object> response = Map.of(
                    "success", result.isSuccess(),
                    "message", result.getMessage()
                );
                return ResponseEntity.ok(response);
            })
            .exceptionally(e -> ResponseEntity.badRequest().body(Map.of(
                "success", false,
                "message", e.getMessage()
            )));
    }

    @PostMapping("/repositories/{id}/fetch")
    public CompletableFuture<ResponseEntity<List<GitBranch>>> fetchRemotes(@PathVariable String id) {
        return synchronizationService.fetchRemotes(id)
            .thenApply(ResponseEntity::ok)
            .exceptionally(e -> ResponseEntity.badRequest().body(null));
    }

    //
    // Credential management endpoints
    //

    @GetMapping("/credentials")
    public List<GitCredential> getCredentials() {
        return credentialService.getCredentials();
    }

    @PostMapping("/credentials")
    public ResponseEntity<GitCredential> createCredential(@RequestBody GitCredential credential) {
        try {
            GitCredential created = credentialService.createCredential(credential);
            // Return a copy without sensitive data
            GitCredential result = new GitCredential(created);
            result.setPassword(null);
            result.setPrivateKey(null);
            result.setPassphrase(null);
            return ResponseEntity.ok(result);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PutMapping("/credentials/{id}")
    public ResponseEntity<GitCredential> updateCredential(
        @PathVariable String id,
        @RequestBody GitCredential credential
    ) {
        try {
            GitCredential updated = credentialService.updateCredential(id, credential);
            // Return a copy without sensitive data
            GitCredential result = new GitCredential(updated);
            result.setPassword(null);
            result.setPrivateKey(null);
            result.setPassphrase(null);
            return ResponseEntity.ok(result);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @DeleteMapping("/credentials/{id}")
    public ResponseEntity<Void> deleteCredential(@PathVariable String id) {
        try {
            credentialService.deleteCredential(id);
            return ResponseEntity.ok().build();
        } catch (IOException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    @PostMapping("/credentials/test")
    public ResponseEntity<Boolean> testCredential(@RequestBody GitCredential credential) {
        boolean isValid = credentialService.testCredential(credential);
        return ResponseEntity.ok(isValid);
    }

    //
    // Collaboration endpoints
    //

    @GetMapping("/repositories/{id}/pullrequests")
    public CompletableFuture<ResponseEntity<List<GitPullRequest>>> getPullRequests(@PathVariable String id) {
        return collaborationService.getPullRequests(id)
            .thenApply(ResponseEntity::ok)
            .exceptionally(e -> ResponseEntity.badRequest().body(null));
    }

    @GetMapping("/repositories/{id}/pullrequests/{prId}")
    public CompletableFuture<ResponseEntity<GitPullRequest>> getPullRequest(
        @PathVariable String id,
        @PathVariable int prId
    ) {
        return collaborationService.getPullRequest(id, prId)
            .thenApply(ResponseEntity::ok)
            .exceptionally(e -> ResponseEntity.badRequest().body(null));
    }

    @PostMapping("/repositories/{id}/pullrequests")
    public CompletableFuture<ResponseEntity<GitPullRequest>> createPullRequest(
        @PathVariable String id,
        @RequestParam String title,
        @RequestParam String description,
        @RequestParam String sourceBranch,
        @RequestParam String targetBranch,
        @RequestBody(required = false) List<String> reviewers
    ) {
        return collaborationService.createPullRequest(id, title, description, sourceBranch, targetBranch, reviewers)
            .thenApply(ResponseEntity::ok)
            .exceptionally(e -> ResponseEntity.badRequest().body(null));
    }

    @PostMapping("/repositories/{id}/pullrequests/{prId}/comments")
    public CompletableFuture<ResponseEntity<GitComment>> addPullRequestComment(
        @PathVariable String id,
        @PathVariable int prId,
        @RequestParam String content
    ) {
        return collaborationService.addPullRequestComment(id, prId, content)
            .thenApply(ResponseEntity::ok)
            .exceptionally(e -> ResponseEntity.badRequest().body(null));
    }

    @PostMapping("/repositories/{id}/pullrequests/{prId}/merge")
    public CompletableFuture<ResponseEntity<Boolean>> mergePullRequest(
        @PathVariable String id,
        @PathVariable int prId,
        @RequestParam String commitMessage
    ) {
        return collaborationService.mergePullRequest(id, prId, commitMessage)
            .thenApply(ResponseEntity::ok)
            .exceptionally(e -> ResponseEntity.badRequest().body(null));
    }
}

// src/main/java/com/automation/api/services/integration/ado/ADOWorkItemService.java
package com.automation.api.services.integration.ado;

import com.automation.api.models.integration.ado.*;
import com.automation.api.models.reporting.Attachment;
import com.automation.api.models.reporting.TestCase;
import com.automation.api.models.reporting.TestExecution;
import com.automation.api.models.reporting.TestStep;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;

/**
 * Service for managing Azure DevOps work items (bugs, tasks, etc.)
 */
@Service
public class ADOWorkItemService {

    private final ADOConnectionService connectionService;
    private final ADOTestPlanService testPlanService;

    @Autowired
    public ADOWorkItemService(
        ADOConnectionService connectionService,
        ADOTestPlanService testPlanService
    ) {
        this.connectionService = connectionService;
        this.testPlanService = testPlanService;
    }

    /**
     * Create a bug from a test failure
     */
    public ADOWorkItem createBugFromFailure(
        String connectionId,
        TestCase testCase,
        TestStep failedStep,
        String priority,
        String assignedTo
    ) throws IOException {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        // Create bug work item
        String title = "Test failure: " + testCase.getName();
        String repro = createReproSteps(testCase, failedStep);
        String errorMessage = failedStep.getError() != null ? failedStep.getError().getMessage() : "Unknown error";
        
        // Create JSON patch document for creating the bug
        List<Map<String, Object>> operations = new ArrayList<>();
        
        // Add basic fields
        operations.add(createJsonPatchOperation("add", "/fields/System.Title", title));
        operations.add(createJsonPatchOperation("add", "/fields/System.Description", repro));
        operations.add(createJsonPatchOperation("add", "/fields/Microsoft.VSTS.TCM.ReproSteps", repro));
        operations.add(createJsonPatchOperation("add", "/fields/Microsoft.VSTS.TCM.ErrorMessage", errorMessage));
        
        // Add priority if specified
        if (priority != null && !priority.isEmpty()) {
            operations.add(createJsonPatchOperation("add", "/fields/Microsoft.VSTS.Common.Priority", priority));
        }
        
        // Add assignee if specified
        if (assignedTo != null && !assignedTo.isEmpty()) {
            operations.add(createJsonPatchOperation("add", "/fields/System.AssignedTo", assignedTo));
        }
        
        // Create the bug
        ResponseEntity<Map> response = client.patch(
            "_apis/wit/workitems/$Bug?api-version=7.0",
            operations,
            Map.class
        );
        
        // Parse response
        Map<String, Object> responseBody = response.getBody();
        int bugId = ((Number) responseBody.get("id")).intValue();
        
        // Upload attachments if available
        if (failedStep.getAttachments() != null && !failedStep.getAttachments().isEmpty()) {
            for (Attachment attachment : failedStep.getAttachments()) {
                if (attachment.getType().equals("SCREENSHOT") || attachment.getType().equals("VIDEO")) {
                    addAttachmentToWorkItem(client, bugId, attachment);
                }
            }
        }
        
        // Link to test case if it has an ADO mapping
        TestCaseMapping mapping = testPlanService.getTestCaseMapping(testCase.getId());
        if (mapping != null) {
            linkWorkItems(client, bugId, mapping.getAdoId(), "Microsoft.VSTS.Common.TestedBy");
        }
        
        // Get the complete work item
        return getWorkItem(connectionId, bugId);
    }

    /**
     * Get a work item by ID
     */
    public ADOWorkItem getWorkItem(String connectionId, int workItemId) throws IOException {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        ResponseEntity<Map> response = client.get(
            String.format("_apis/wit/workitems/%d?api-version=7.0&$expand=all", workItemId),
            Map.class
        );
        
        Map<String, Object> workItemData = response.getBody();
        return parseWorkItem(workItemData);
    }

    /**
     * Search for work items
     */
    public List<ADOWorkItem> searchWorkItems(
        String connectionId,
        String query,
        int maxResults
    ) throws IOException {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        // Create the WIQL query
        Map<String, Object> wiqlQuery = new HashMap<>();
        wiqlQuery.put("query", query);
        
        // Execute the query
        ResponseEntity<Map> response = client.post(
            "_apis/wit/wiql?api-version=7.0",
            wiqlQuery,
            Map.class
        );
        
        // Parse the work item references
        Map<String, Object> responseBody = response.getBody();
        List<Map<String, Object>> workItems = (List<Map<String, Object>>) responseBody.get("workItems");
        
        List<ADOWorkItem> results = new ArrayList<>();
        
        // Limit the number of work items to fetch
        int count = Math.min(workItems.size(), maxResults);
        
        // Fetch each work item
        for (int i = 0; i < count; i++) {
            Map<String, Object> workItemRef = workItems.get(i);
            int id = ((Number) workItemRef.get("id")).intValue();
            ADOWorkItem workItem = getWorkItem(connectionId, id);
            results.add(workItem);
        }
        
        return results;
    }

    /**
     * Update a work item
     */
    public ADOWorkItem updateWorkItem(
        String connectionId,
        int workItemId,
        Map<String, Object> fields
    ) throws IOException {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        // Create JSON patch operations
        List<Map<String, Object>> operations = new ArrayList<>();
        
        // Add each field as a patch operation
        for (Map.Entry<String, Object> entry : fields.entrySet()) {
            operations.add(createJsonPatchOperation(
                "add", 
                "/fields/" + entry.getKey(), 
                entry.getValue()
            ));
        }
        
        // Update the work item
        ResponseEntity<Map> response = client.patch(
            String.format("_apis/wit/workitems/%d?api-version=7.0", workItemId),
            operations,
            Map.class
        );
        
        // Parse the updated work item
        Map<String, Object> workItemData = response.getBody();
        return parseWorkItem(workItemData);
    }

    /**
     * Link two work items
     */
    public void linkWorkItems(
        ADORestClient client,
        int sourceId,
        int targetId,
        String linkType
    ) throws IOException {
        // Create the link
        List<Map<String, Object>> operations = new ArrayList<>();
        
        Map<String, Object> relation = new HashMap<>();
        relation.put("rel", linkType);
        relation.put("url", String.format(
            "%s/_apis/wit/workItems/%d", 
            client.getBaseUrl(),
            targetId
        ));
        
        operations.add(createJsonPatchOperation(
            "add", 
            "/relations/-", 
            relation
        ));
        
        // Add the link
        client.patch(
            String.format("_apis/wit/workitems/%d?api-version=7.0", sourceId),
            operations,
            Map.class
        );
    }

    /**
     * Add an attachment to a work item
     */
    private void addAttachmentToWorkItem(
        ADORestClient client,
        int workItemId,
        Attachment attachment
    ) throws IOException {
        // Read attachment file
        File file = new File(attachment.getPath());
        if (!file.exists()) {
            return;
        }
        
        byte[] fileContent = Files.readAllBytes(file.toPath());
        
        // Upload the attachment
        ResponseEntity<Map> uploadResponse = client.post(
            "_apis/wit/attachments?fileName=" + attachment.getName() + "&api-version=7.0",
            fileContent,
            Map.class
        );
        
        Map<String, Object> uploadResult = uploadResponse.getBody();
        String attachmentUrl = (String) uploadResult.get("url");
        
        // Add attachment to work item
        List<Map<String, Object>> operations = new ArrayList<>();
        
        Map<String, Object> attachmentRelation = new HashMap<>();
        attachmentRelation.put("rel", "AttachedFile");
        attachmentRelation.put("url", attachmentUrl);
        
        operations.add(createJsonPatchOperation(
            "add", 
            "/relations/-", 
            attachmentRelation
        ));
        
        // Update the work item
        client.patch(
            String.format("_apis/wit/workitems/%d?api-version=7.0", workItemId),
            operations,
            Map.class
        );
    }

    /**
     * Create repro steps from a failed test
     */
    private String createReproSteps(TestCase testCase, TestStep failedStep) {
        StringBuilder sb = new StringBuilder();
        
        sb.append("<h3>Test Case: ").append(testCase.getName()).append("</h3>");
        sb.append("<p>").append(testCase.getDescription()).append("</p>");
        
        sb.append("<h4>Steps to Reproduce</h4>");
        sb.append("<ol>");
        
        // Add all steps up to and including the failed step
        boolean failedStepFound = false;
        for (TestStep step : testCase.getSteps()) {
            sb.append("<li>");
            sb.append("<div><strong>Action:</strong> ").append(step.getName()).append("</div>");
            
            // Add parameters if available
            if (step.getParameters() != null && !step.getParameters().isEmpty()) {
                sb.append("<div><strong>Parameters:</strong> ");
                for (Map.Entry<String, Object> param : step.getParameters().entrySet()) {
                    sb.append(param.getKey()).append("=").append(param.getValue()).append(", ");
                }
                // Remove trailing comma and space
                if (!step.getParameters().isEmpty()) {
                    sb.setLength(sb.length() - 2);
                }
                sb.append("</div>");
            }
            
            sb.append("</li>");
            
            if (step.getId().equals(failedStep.getId())) {
                failedStepFound = true;
                break;
            }
        }
        
        sb.append("</ol>");
        
        // Add error details
        if (failedStep.getError() != null) {
            sb.append("<h4>Error Details</h4>");
            sb.append("<div><strong>Message:</strong> ").append(failedStep.getError().getMessage()).append("</div>");
            
            if (failedStep.getError().getStackTrace() != null) {
                sb.append("<div><strong>Stack Trace:</strong><pre>")
                  .append(failedStep.getError().getStackTrace())
                  .append("</pre></div>");
            }
            
            if (failedStep.getError().getExpected() != null) {
                sb.append("<div><strong>Expected:</strong> ").append(failedStep.getError().getExpected()).append("</div>");
            }
            
            if (failedStep.getError().getActual() != null) {
                sb.append("<div><strong>Actual:</strong> ").append(failedStep.getError().getActual()).append("</div>");
            }
        }
        
        return sb.toString();
    }

    /**
     * Parse ADO work item from API response
     */
    private ADOWorkItem parseWorkItem(Map<String, Object> workItemData) {
        Map<String, Object> fields = (Map<String, Object>) workItemData.get("fields");
        
        ADOWorkItem workItem = new ADOWorkItem();
        workItem.setId(((Number) workItemData.get("id")).intValue());
        workItem.setType((String) fields.get("System.WorkItemType"));
        workItem.setTitle((String) fields.get("System.Title"));
        workItem.setState((String) fields.get("System.State"));
        
        // Parse priority
        Object priorityObj = fields.get("Microsoft.VSTS.Common.Priority");
        if (priorityObj instanceof Number) {
            workItem.setPriority(((Number) priorityObj).intValue());
        }
        
        // Parse assigned to
        Object assignedToObj = fields.get("System.AssignedTo");
        if (assignedToObj instanceof Map) {
            workItem.setAssignedTo((String) ((Map<String, Object>) assignedToObj).get("displayName"));
        } else if (assignedToObj instanceof String) {
            workItem.setAssignedTo((String) assignedToObj);
        }
        
        // Parse created by
        Object createdByObj = fields.get("System.CreatedBy");
        if (createdByObj instanceof Map) {
            workItem.setCreatedBy((String) ((Map<String, Object>) createdByObj).get("displayName"));
        } else if (createdByObj instanceof String) {
            workItem.setCreatedBy((String) createdByObj);
        }
        
        // Parse dates
        workItem.setCreatedDate(parseDate((String) fields.get("System.CreatedDate")));
        workItem.setChangedDate(parseDate((String) fields.get("System.ChangedDate")));
        
        // Parse description
        workItem.setDescription((String) fields.get("System.Description"));
        
        // Copy all fields
        workItem.setFields(new HashMap<>(fields));
        
        // Parse relations
        List<ADOWorkItemRelation> relations = new ArrayList<>();
        if (workItemData.containsKey("relations")) {
            List<Map<String, Object>> relationsData = (List<Map<String, Object>>) workItemData.get("relations");
            
            for (Map<String, Object> relationData : relationsData) {
                ADOWorkItemRelation relation = new ADOWorkItemRelation();
                relation.setRel((String) relationData.get("rel"));
                relation.setUrl((String) relationData.get("url"));
                relation.setAttributes((Map<String, Object>) relationData.get("attributes"));
                relations.add(relation);
            }
        }
        workItem.setRelations(relations);
        
        return workItem;
    }

    /**
     * Helper method to create a JSON patch operation
     */
    private Map<String, Object> createJsonPatchOperation(String op, String path, Object value) {
        Map<String, Object> operation = new HashMap<>();
        operation.put("op", op);
        operation.put("path", path);
        operation.put("value", value);
        return operation;
    }

    /**
     * Parse ISO date string to Date
     */
    private Date parseDate(String dateString) {
        if (dateString == null) {
            return null;
        }
        
        try {
            return new Date(Date.parse(dateString));
        } catch (Exception e) {
            return null;
        }
    }
}


// src/main/java/com/automation/api/services/integration/ado/ADOPipelineService.java
package com.automation.api.services.integration.ado;

import com.automation.api.models.integration.ado.*;
import com.automation.api.models.reporting.TestExecution;
import com.automation.api.services.execution.TestExecutionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

/**
 * Service for integrating with Azure DevOps pipelines
 */
@Service
public class ADOPipelineService {

    private final ADOConnectionService connectionService;
    private final ADOTestResultService testResultService;
    private final TestExecutionService testExecutionService;
    private final Executor executor = Executors.newFixedThreadPool(3);

    @Autowired
    public ADOPipelineService(
        ADOConnectionService connectionService,
        ADOTestResultService testResultService,
        TestExecutionService testExecutionService
    ) {
        this.connectionService = connectionService;
        this.testResultService = testResultService;
        this.testExecutionService = testExecutionService;
    }

    /**
     * Get a list of pipelines
     */
    public List<ADOPipeline> getPipelines(String connectionId) throws IOException {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        ResponseEntity<Map> response = client.get(
            "_apis/pipelines?api-version=7.0",
            Map.class
        );
        
        Map<String, Object> responseBody = response.getBody();
        List<Map<String, Object>> pipelinesData = (List<Map<String, Object>>) responseBody.get("value");
        
        List<ADOPipeline> pipelines = new ArrayList<>();
        for (Map<String, Object> pipelineData : pipelinesData) {
            ADOPipeline pipeline = parsePipeline(pipelineData);
            pipelines.add(pipeline);
        }
        
        return pipelines;
    }

    /**
     * Get a specific pipeline by ID
     */
    public ADOPipeline getPipeline(String connectionId, int pipelineId) throws IOException {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        ResponseEntity<Map> response = client.get(
            String.format("_apis/pipelines/%d?api-version=7.0", pipelineId),
            Map.class
        );
        
        Map<String, Object> pipelineData = response.getBody();
        return parsePipeline(pipelineData);
    }

    /**
     * Get pipeline runs
     */
    public List<ADOPipelineRun> getPipelineRuns(
        String connectionId, 
        int pipelineId, 
        int top
    ) throws IOException {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        ResponseEntity<Map> response = client.get(
            String.format("_apis/pipelines/%d/runs?api-version=7.0&$top=%d", pipelineId, top),
            Map.class
        );
        
        Map<String, Object> responseBody = response.getBody();
        List<Map<String, Object>> runsData = (List<Map<String, Object>>) responseBody.get("value");
        
        List<ADOPipelineRun> runs = new ArrayList<>();
        for (Map<String, Object> runData : runsData) {
            ADOPipelineRun run = parsePipelineRun(runData);
            runs.add(run);
        }
        
        return runs;
    }

    /**
     * Get a specific pipeline run
     */
    public ADOPipelineRun getPipelineRun(
        String connectionId, 
        int pipelineId,
        int runId
    ) throws IOException {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        ResponseEntity<Map> response = client.get(
            String.format("_apis/pipelines/%d/runs/%d?api-version=7.0", pipelineId, runId),
            Map.class
        );
        
        Map<String, Object> runData = response.getBody();
        return parsePipelineRun(runData);
    }

    /**
     * Run a pipeline with variables
     */
    public ADOPipelineRun runPipeline(
        String connectionId,
        int pipelineId,
        Map<String, String> variables
    ) throws IOException {
        ADORestClient client = connectionService.createRestClient(connectionId);
        
        Map<String, Object> requestBody = new HashMap<>();
        
        if (variables != null && !variables.isEmpty()) {
            Map<String, Object> variablesMap = new HashMap<>();
            for (Map.Entry<String, String> entry : variables.entrySet()) {
                Map<String, Object> variable = new HashMap<>();
                variable.put("value", entry.getValue());
                variablesMap.put(entry.getKey(), variable);
            }
            requestBody.put("variables", variablesMap);
        }
        
        ResponseEntity<Map> response = client.post(
            String.format("_apis/pipelines/%d/runs?api-version=7.0", pipelineId),
            requestBody,
            Map.class
        );
        
        Map<String, Object> runData = response.getBody();
        return parsePipelineRun(runData);
    }

    /**
     * Publish test results to a pipeline
     */
    public CompletableFuture<ADOTestRun> publishTestResultsToPipeline(
        String connectionId,
        String executionId,
        int buildId
    ) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Get the test execution
                TestExecution execution = testExecutionService.getTestExecution(executionId);
                
                // Create test run with build reference
                Map<String, Object> runRequest = new HashMap<>();
                runRequest.put("name", "Automated Test Run - " + execution.getId());
                runRequest.put("state", "InProgress");
                runRequest.put("build", new HashMap<String, Object>() {{
                    put("id", buildId);
                }});
                
                // Publish test results
                ADOTestRun testRun = testResultService.publishTestResults(
                    connectionId, 
                    execution, 
                    null  // No test plan ID
                );
                
                return testRun;
            } catch (IOException e) {
                throw new RuntimeException("Failed to publish test results to pipeline: " + e.getMessage(), e);
            }
        }, executor);
    }

    /**
     * Listen for webhook events from Azure DevOps
     * This would be used to trigger test executions when a build completes
     */
    public void handleWebhookEvent(Map<String, Object> eventData) {
        // Extract event type
        String eventType = (String) eventData.get("eventType");
        
        if ("build.complete".equals(eventType)) {
            // Extract build information
            Map<String, Object> resource = (Map<String, Object>) eventData.get("resource");
            int buildId = ((Number) resource.get("id")).intValue();
            String status = (String) resource.get("status");
            String result = (String) resource.get("result");
            
            // If build succeeded, trigger test execution
            if ("completed".equalsIgnoreCase(status) && "succeeded".equalsIgnoreCase(result)) {
                // In a real implementation, you would look up a mapping between
                // build definitions and test suites/configurations and trigger
                // the appropriate test execution
                handleSuccessfulBuild(buildId, resource);
            }
        } else if ("release.deployment.completed".equals(eventType)) {
            // Handle deployment completion events
            Map<String, Object> resource = (Map<String, Object>) eventData.get("resource");
            handleDeploymentComplete(resource);
        }
    }

    /**
     * Handle a successful build by triggering test execution
     */
    private void handleSuccessfulBuild(int buildId, Map<String, Object> buildData) {
        // In a real implementation, this would:
        // 1. Look up test configurations associated with this build
        // 2. Trigger test executions
        // 3. Report results back to ADO
        
        // This is just a skeleton implementation
        String definitionName = (String) ((Map<String, Object>) buildData.get("definition")).get("name");
        
        // Log the build information
        System.out.println("Received successful build: " + buildId + " for definition: " + definitionName);
        
        // In a real implementation, you'd trigger a test execution based on configuration
        /*
        testExecutionService.executeTestSuite(
            projectId,
            suiteId,
            environment,
            new HashMap<String, String>() {{
                put("buildId", String.valueOf(buildId));
            }}
        );
        */
    }

    /**
     * Handle a deployment completion event
     */
    private void handleDeploymentComplete(Map<String, Object> deploymentData) {
        // In a real implementation, this would:
        // 1. Identify the environment that was deployed to
        // 2. Trigger appropriate tests for that environment
        // 3. Report results back to ADO
        
        // This is just a skeleton implementation
        String environment = (String) deploymentData.get("releaseEnvironment");
        String status = (String) deploymentData.get("status");
        
        if ("succeeded".equalsIgnoreCase(status)) {
            System.out.println("Deployment completed successfully for environment: " + environment);
            
            // In a real implementation, you'd trigger tests for this environment
            /*
            testExecutionService.executeTestSuite(
                projectId,
                suiteId,
                environment,
                new HashMap<>()
            );
            */
        }
    }

    /**
     * Parse pipeline data from API response
     */
    private ADOPipeline parsePipeline(Map<String, Object> pipelineData) {
        ADOPipeline pipeline = new ADOPipeline();
        pipeline.setId(((Number) pipelineData.get("id")).intValue());
        pipeline.setName((String) pipelineData.get("name"));
        
        // Parse folder path if available
        if (pipelineData.containsKey("folder")) {
            pipeline.setFolder((String) pipelineData.get("folder"));
        } else {
            pipeline.setFolder("/");
        }
        
        // Parse revision
        if (pipelineData.containsKey("revision")) {
            pipeline.setRevision(((Number) pipelineData.get("revision")).intValue());
        }
        
        pipeline.setUrl((String) pipelineData.get("url"));
        
        return pipeline;
    }

    /**
     * Parse pipeline run data from API response
     */
    private ADOPipelineRun parsePipelineRun(Map<String, Object> runData) {
        ADOPipelineRun run = new ADOPipelineRun();
        run.setId(((Number) runData.get("id")).intValue());
        
        if (runData.containsKey("pipeline")) {
            Map<String, Object> pipelineRef = (Map<String, Object>) runData.get("pipeline");
            run.setPipelineId(((Number) pipelineRef.get("id")).intValue());
        }
        
        run.setState((String) runData.get("state"));
        run.setResult((String) runData.get("result"));
        
        // Parse dates
        run.setCreatedDate(parseDate((String) runData.get("createdDate")));
        if (runData.containsKey("finishedDate")) {
            run.setFinishedDate(parseDate((String) runData.get("finishedDate")));
        }
        
        run.setUrl((String) runData.get("url"));
        
        // Parse variables
        if (runData.containsKey("variables")) {
            Map<String, Object> variablesMap = (Map<String, Object>) runData.get("variables");
            Map<String, String> variables = new HashMap<>();
            
            for (Map.Entry<String, Object> entry : variablesMap.entrySet()) {
                Map<String, Object> variable = (Map<String, Object>) entry.getValue();
                variables.put(entry.getKey(), (String) variable.get("value"));
            }
            
            run.setVariables(variables);
        } else {
            run.setVariables(new HashMap<>());
        }
        
        return run;
    }

    /**
     * Parse ISO date string to Date
     */
    private Date parseDate(String dateString) {
        if (dateString == null) {
            return null;
        }
        
        try {
            return new Date(Date.parse(dateString));
        } catch (Exception e) {
            return null;
        }
    }
}


// src/main/java/com/automation/api/models/integration/ado/ADOConnection.java
package com.automation.api.models.integration.ado;

import java.util.Date;

/**
 * Represents a connection to Azure DevOps
 */
public class ADOConnection {
    private String id;
    private String name;
    private String url;
    private String pat;
    private String organization;
    private String project;
    private String team;
    private boolean isActive;
    private Date lastSync;
    private String status;
    private String errorMessage;
    
    public ADOConnection() {
    }
    
    public ADOConnection(ADOConnection other) {
        this.id = other.id;
        this.name = other.name;
        this.url = other.url;
        this.pat = other.pat;
        this.organization = other.organization;
        this.project = other.project;
        this.team = other.team;
        this.isActive = other.isActive;
        this.lastSync = other.lastSync;
        this.status = other.status;
        this.errorMessage = other.errorMessage;
    }
    
    // Getters and Setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    public String getPat() {
        return pat;
    }
    
    public void setPat(String pat) {
        this.pat = pat;
    }
    
    public String getOrganization() {
        return organization;
    }
    
    public void setOrganization(String organization) {
        this.organization = organization;
    }
    
    public String getProject() {
        return project;
    }
    
    public void setProject(String project) {
        this.project = project;
    }
    
    public String getTeam() {
        return team;
    }
    
    public void setTeam(String team) {
        this.team = team;
    }
    
    public boolean isActive() {
        return isActive;
    }
    
    public void setActive(boolean active) {
        isActive = active;
    }
    
    public Date getLastSync() {
        return lastSync;
    }
    
    public void setLastSync(Date lastSync) {
        this.lastSync = lastSync;
    }
    
    public String getStatus() {
        return status;
    }
    
    public void setStatus(String status) {
        this.status = status;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOTestPlan.java
package com.automation.api.models.integration.ado;

import java.util.List;

/**
 * Represents an Azure DevOps Test Plan
 */
public class ADOTestPlan {
    private int id;
    private String name;
    private List<ADOTestSuite> suites;
    
    // Getters and Setters
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public List<ADOTestSuite> getSuites() {
        return suites;
    }
    
    public void setSuites(List<ADOTestSuite> suites) {
        this.suites = suites;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOTestSuite.java
package com.automation.api.models.integration.ado;

import java.util.List;

/**
 * Represents an Azure DevOps Test Suite
 */
public class ADOTestSuite {
    private int id;
    private String name;
    private Integer parentId;
    private List<ADOTestCase> testCases;
    private List<ADOTestSuite> childSuites;
    
    // Getters and Setters
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public Integer getParentId() {
        return parentId;
    }
    
    public void setParentId(Integer parentId) {
        this.parentId = parentId;
    }
    
    public List<ADOTestCase> getTestCases() {
        return testCases;
    }
    
    public void setTestCases(List<ADOTestCase> testCases) {
        this.testCases = testCases;
    }
    
    public List<ADOTestSuite> getChildSuites() {
        return childSuites;
    }
    
    public void setChildSuites(List<ADOTestSuite> childSuites) {
        this.childSuites = childSuites;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOTestCase.java
package com.automation.api.models.integration.ado;

import java.util.List;

/**
 * Represents an Azure DevOps Test Case
 */
public class ADOTestCase {
    private int id;
    private String name;
    private String state;
    private int priority;
    private List<ADOTestStep> steps;
    private String automationStatus;
    private String areaPath;
    private String iterationPath;
    private String workItemType;
    private List<String> tags;
    private List<ADOAttachment> attachments;
    
    // Getters and Setters
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getState() {
        return state;
    }
    
    public void setState(String state) {
        this.state = state;
    }
    
    public int getPriority() {
        return priority;
    }
    
    public void setPriority(int priority) {
        this.priority = priority;
    }
    
    public List<ADOTestStep> getSteps() {
        return steps;
    }
    
    public void setSteps(List<ADOTestStep> steps) {
        this.steps = steps;
    }
    
    public String getAutomationStatus() {
        return automationStatus;
    }
    
    public void setAutomationStatus(String automationStatus) {
        this.automationStatus = automationStatus;
    }
    
    public String getAreaPath() {
        return areaPath;
    }
    
    public void setAreaPath(String areaPath) {
        this.areaPath = areaPath;
    }
    
    public String getIterationPath() {
        return iterationPath;
    }
    
    public void setIterationPath(String iterationPath) {
        this.iterationPath = iterationPath;
    }
    
    public String getWorkItemType() {
        return workItemType;
    }
    
    public void setWorkItemType(String workItemType) {
        this.workItemType = workItemType;
    }
    
    public List<String> getTags() {
        return tags;
    }
    
    public void setTags(List<String> tags) {
        this.tags = tags;
    }
    
    public List<ADOAttachment> getAttachments() {
        return attachments;
    }
    
    public void setAttachments(List<ADOAttachment> attachments) {
        this.attachments = attachments;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOTestStep.java
package com.automation.api.models.integration.ado;

import java.util.Map;

/**
 * Represents a step in an Azure DevOps Test Case
 */
public class ADOTestStep {
    private int id;
    private String action;
    private String expectedResult;
    private Map<String, String> parameters;
    
    // Getters and Setters
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getAction() {
        return action;
    }
    
    public void setAction(String action) {
        this.action = action;
    }
    
    public String getExpectedResult() {
        return expectedResult;
    }
    
    public void setExpectedResult(String expectedResult) {
        this.expectedResult = expectedResult;
    }
    
    public Map<String, String> getParameters() {
        return parameters;
    }
    
    public void setParameters(Map<String, String> parameters) {
        this.parameters = parameters;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOAttachment.java
package com.automation.api.models.integration.ado;

import java.util.Date;

/**
 * Represents an attachment in Azure DevOps
 */
public class ADOAttachment {
    private String id;
    private String name;
    private String url;
    private String contentType;
    private long size;
    private Date addedDate;
    
    // Getters and Setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    public String getContentType() {
        return contentType;
    }
    
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }
    
    public long getSize() {
        return size;
    }
    
    public void setSize(long size) {
        this.size = size;
    }
    
    public Date getAddedDate() {
        return addedDate;
    }
    
    public void setAddedDate(Date addedDate) {
        this.addedDate = addedDate;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOTestRun.java
package com.automation.api.models.integration.ado;

import java.util.Date;
import java.util.List;

/**
 * Represents a test run in Azure DevOps
 */
public class ADOTestRun {
    private int id;
    private String name;
    private String state;
    private Date startedDate;
    private Date completedDate;
    private Integer testPlanId;
    private Integer buildId;
    private Integer releaseId;
    private List<ADOTestResult> results;
    
    // Getters and Setters
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getState() {
        return state;
    }
    
    public void setState(String state) {
        this.state = state;
    }
    
    public Date getStartedDate() {
        return startedDate;
    }
    
    public void setStartedDate(Date startedDate) {
        this.startedDate = startedDate;
    }
    
    public Date getCompletedDate() {
        return completedDate;
    }
    
    public void setCompletedDate(Date completedDate) {
        this.completedDate = completedDate;
    }
    
    public Integer getTestPlanId() {
        return testPlanId;
    }
    
    public void setTestPlanId(Integer testPlanId) {
        this.testPlanId = testPlanId;
    }
    
    public Integer getBuildId() {
        return buildId;
    }
    
    public void setBuildId(Integer buildId) {
        this.buildId = buildId;
    }
    
    public Integer getReleaseId() {
        return releaseId;
    }
    
    public void setReleaseId(Integer releaseId) {
        this.releaseId = releaseId;
    }
    
    public List<ADOTestResult> getResults() {
        return results;
    }
    
    public void setResults(List<ADOTestResult> results) {
        this.results = results;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOTestResult.java
package com.automation.api.models.integration.ado;

import java.util.Date;
import java.util.List;

/**
 * Represents a test result in Azure DevOps
 */
public class ADOTestResult {
    private int id;
    private int testCaseId;
    private String outcome;
    private Date startedDate;
    private Date completedDate;
    private long duration;
    private String errorMessage;
    private String stackTrace;
    private List<ADOTestStepResult> stepResults;
    private List<ADOResultAttachment> attachments;
    
    // Getters and Setters
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public int getTestCaseId() {
        return testCaseId;
    }
    
    public void setTestCaseId(int testCaseId) {
        this.testCaseId = testCaseId;
    }
    
    public String getOutcome() {
        return outcome;
    }
    
    public void setOutcome(String outcome) {
        this.outcome = outcome;
    }
    
    public Date getStartedDate() {
        return startedDate;
    }
    
    public void setStartedDate(Date startedDate) {
        this.startedDate = startedDate;
    }
    
    public Date getCompletedDate() {
        return completedDate;
    }
    
    public void setCompletedDate(Date completedDate) {
        this.completedDate = completedDate;
    }
    
    public long getDuration() {
        return duration;
    }
    
    public void setDuration(long duration) {
        this.duration = duration;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
    
    public String getStackTrace() {
        return stackTrace;
    }
    
    public void setStackTrace(String stackTrace) {
        this.stackTrace = stackTrace;
    }
    
    public List<ADOTestStepResult> getStepResults() {
        return stepResults;
    }
    
    public void setStepResults(List<ADOTestStepResult> stepResults) {
        this.stepResults = stepResults;
    }
    
    public List<ADOResultAttachment> getAttachments() {
        return attachments;
    }
    
    public void setAttachments(List<ADOResultAttachment> attachments) {
        this.attachments = attachments;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOTestStepResult.java
package com.automation.api.models.integration.ado;

import java.util.List;

/**
 * Represents a test step result in Azure DevOps
 */
public class ADOTestStepResult {
    private int stepId;
    private String outcome;
    private String errorMessage;
    private List<ADOResultAttachment> attachments;
    
    // Getters and Setters
    public int getStepId() {
        return stepId;
    }
    
    public void setStepId(int stepId) {
        this.stepId = stepId;
    }
    
    public String getOutcome() {
        return outcome;
    }
    
    public void setOutcome(String outcome) {
        this.outcome = outcome;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
    
    public List<ADOResultAttachment> getAttachments() {
        return attachments;
    }
    
    public void setAttachments(List<ADOResultAttachment> attachments) {
        this.attachments = attachments;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOResultAttachment.java
package com.automation.api.models.integration.ado;

/**
 * Represents an attachment for a test result in Azure DevOps
 */
public class ADOResultAttachment {
    private String id;
    private String name;
    private String type;
    private String url;
    private String contentType;
    private String comment;
    
    // Getters and Setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getType() {
        return type;
    }
    
    public void setType(String type) {
        this.type = type;
    }
    
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    public String getContentType() {
        return contentType;
    }
    
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }
    
    public String getComment() {
        return comment;
    }
    
    public void setComment(String comment) {
        this.comment = comment;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOWorkItem.java
package com.automation.api.models.integration.ado;

import java.util.Date;
import java.util.List;
import java.util.Map;

/**
 * Represents a work item in Azure DevOps
 */
public class ADOWorkItem {
    private int id;
    private String type;
    private String title;
    private String state;
    private int priority;
    private String assignedTo;
    private String createdBy;
    private Date createdDate;
    private Date changedDate;
    private String description;
    private Map<String, Object> fields;
    private List<ADOWorkItemRelation> relations;
    
    // Getters and Setters
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getType() {
        return type;
    }
    
    public void setType(String type) {
        this.type = type;
    }
    
    public String getTitle() {
        return title;
    }
    
    public void setTitle(String title) {
        this.title = title;
    }
    
    public String getState() {
        return state;
    }
    
    public void setState(String state) {
        this.state = state;
    }
    
    public int getPriority() {
        return priority;
    }
    
    public void setPriority(int priority) {
        this.priority = priority;
    }
    
    public String getAssignedTo() {
        return assignedTo;
    }
    
    public void setAssignedTo(String assignedTo) {
        this.assignedTo = assignedTo;
    }
    
    public String getCreatedBy() {
        return createdBy;
    }
    
    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
    
    public Date getCreatedDate() {
        return createdDate;
    }
    
    public void setCreatedDate(Date createdDate) {
        this.createdDate = createdDate;
    }
    
    public Date getChangedDate() {
        return changedDate;
    }
    
    public void setChangedDate(Date changedDate) {
        this.changedDate = changedDate;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public Map<String, Object> getFields() {
        return fields;
    }
    
    public void setFields(Map<String, Object> fields) {
        this.fields = fields;
    }
    
    public List<ADOWorkItemRelation> getRelations() {
        return relations;
    }
    
    public void setRelations(List<ADOWorkItemRelation> relations) {
        this.relations = relations;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOWorkItemRelation.java
package com.automation.api.models.integration.ado;

import java.util.Map;

/**
 * Represents a relation between work items in Azure DevOps
 */
public class ADOWorkItemRelation {
    private String rel;
    private String url;
    private Map<String, Object> attributes;
    
    // Getters and Setters
    public String getRel() {
        return rel;
    }
    
    public void setRel(String rel) {
        this.rel = rel;
    }
    
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    public Map<String, Object> getAttributes() {
        return attributes;
    }
    
    public void setAttributes(Map<String, Object> attributes) {
        this.attributes = attributes;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOPipeline.java
package com.automation.api.models.integration.ado;

/**
 * Represents a pipeline in Azure DevOps
 */
public class ADOPipeline {
    private int id;
    private String name;
    private String folder;
    private int revision;
    private String url;
    
    // Getters and Setters
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getFolder() {
        return folder;
    }
    
    public void setFolder(String folder) {
        this.folder = folder;
    }
    
    public int getRevision() {
        return revision;
    }
    
    public void setRevision(int revision) {
        this.revision = revision;
    }
    
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ADOPipelineRun.java
package com.automation.api.models.integration.ado;

import java.util.Date;
import java.util.Map;

/**
 * Represents a pipeline run in Azure DevOps
 */
public class ADOPipelineRun {
    private int id;
    private int pipelineId;
    private String state;
    private String result;
    private Date createdDate;
    private Date finishedDate;
    private String url;
    private Map<String, String> variables;
    
    // Getters and Setters
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public int getPipelineId() {
        return pipelineId;
    }
    
    public void setPipelineId(int pipelineId) {
        this.pipelineId = pipelineId;
    }
    
    public String getState() {
        return state;
    }
    
    public void setState(String state) {
        this.state = state;
    }
    
    public String getResult() {
        return result;
    }
    
    public void setResult(String result) {
        this.result = result;
    }
    
    public Date getCreatedDate() {
        return createdDate;
    }
    
    public void setCreatedDate(Date createdDate) {
        this.createdDate = createdDate;
    }
    
    public Date getFinishedDate() {
        return finishedDate;
    }
    
    public void setFinishedDate(Date finishedDate) {
        this.finishedDate = finishedDate;
    }
    
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    public Map<String, String> getVariables() {
        return variables;
    }
    
    public void setVariables(Map<String, String> variables) {
        this.variables = variables;
    }
}

// src/main/java/com/automation/api/models/integration/ado/TestCaseMapping.java
package com.automation.api.models.integration.ado;

import java.util.Date;
import java.util.Map;

/**
 * Represents a mapping between local test cases and Azure DevOps test cases
 */
public class TestCaseMapping {
    private String localId;
    private int adoId;
    private String adoTestCaseUrl;
    private String name;
    private Date lastSyncedLocal;
    private Date lastSyncedADO;
    private String syncStatus;
    private Map<String, String> mappedFields;
    
    // Getters and Setters
    public String getLocalId() {
        return localId;
    }
    
    public void setLocalId(String localId) {
        this.localId = localId;
    }
    
    public int getAdoId() {
        return adoId;
    }
    
    public void setAdoId(int adoId) {
        this.adoId = adoId;
    }
    
    public String getAdoTestCaseUrl() {
        return adoTestCaseUrl;
    }
    
    public void setAdoTestCaseUrl(String adoTestCaseUrl) {
        this.adoTestCaseUrl = adoTestCaseUrl;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public Date getLastSyncedLocal() {
        return lastSyncedLocal;
    }
    
    public void setLastSyncedLocal(Date lastSyncedLocal) {
        this.lastSyncedLocal = lastSyncedLocal;
    }
    
    public Date getLastSyncedADO() {
        return lastSyncedADO;
    }
    
    public void setLastSyncedADO(Date lastSyncedADO) {
        this.lastSyncedADO = lastSyncedADO;
    }
    
    public String getSyncStatus() {
        return syncStatus;
    }
    
    public void setSyncStatus(String syncStatus) {
        this.syncStatus = syncStatus;
    }
    
    public Map<String, String> getMappedFields() {
        return mappedFields;
    }
    
    public void setMappedFields(Map<String, String> mappedFields) {
        this.mappedFields = mappedFields;
    }
}

// src/main/java/com/automation/api/models/integration/ado/ExecutionIndex.java
package com.automation.api.models.integration.ado;

import java.util.Date;

/**
 * Represents an index entry for test executions
 */
public class ExecutionIndex {
    private String id;
    private Date startTime;
    private Date endTime;
    private long duration;
    private String status;
    private String environment;
    private String browser;
    private int totalTests;
    private int passedTests;
    private int failedTests;
    private int brokenTests;
    private int skippedTests;
    
    public ExecutionIndex() {
    }
    
    public ExecutionIndex(
        String id,
        Date startTime,
        Date endTime,
        long duration,
        String status,
        String environment,
        String browser,
        int totalTests,
        int passedTests,
        int failedTests,
        int brokenTests,
        int skippedTests
    ) {
        this.id = id;
        this.startTime = startTime;
        this.endTime = endTime;
        this.duration = duration;
        this.status = status;
        this.environment = environment;
        this.browser = browser;
        this.totalTests = totalTests;
        this.passedTests = passedTests;
        this.failedTests = failedTests;
        this.brokenTests = brokenTests;
        this.skippedTests = skippedTests;
    }
    
    // Getters and Setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public Date getStartTime() {
        return startTime;
    }
    
    public void setStartTime(Date startTime) {
        this.startTime = startTime;
    }
    
    public Date getEndTime() {
        return endTime;
    }
    
    public void setEndTime(Date endTime) {
        this.endTime = endTime;
    }
    
    public long getDuration() {
        return duration;
    }
    
    public void setDuration(long duration) {
        this.duration = duration;
    }
    
    public String getStatus() {
        return status;
    }
    
    public void setStatus(String status) {
        this.status = status;
    }
    
    public String getEnvironment() {
        return environment;
    }
    
    public void setEnvironment(String environment) {
        this.environment = environment;
    }
    
    public String getBrowser() {
        return browser;
    }
    
    public void setBrowser(String browser) {
        this.browser = browser;
    }
    
    public int getTotalTests() {
        return totalTests;
    }
    
    public void setTotalTests(int totalTests) {
        this.totalTests = totalTests;
    }
    
    public int getPassedTests() {
        return passedTests;
    }
    
    public void setPassedTests(int passedTests) {
        this.passedTests = passedTests;
    }
    
    public int getFailedTests() {
        return failedTests;
    }
    
    public void setFailedTests(int failedTests) {
        this.failedTests = failedTests;
    }
    
    public int getBrokenTests() {
        return brokenTests;// src/main/java/com/automation/api/controllers/integration/ADOController.java
package com.automation.api.controllers.integration;

import com.automation.api.models.integration.ado.*;
import com.automation.api.models.reporting.TestExecution;
import com.automation.api.models.reporting.TestCase;
import com.automation.api.models.reporting.TestStep;
import com.automation.api.services.integration.ado.*;
import com.automation.api.services.reporting.ReportingService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.CompletableFuture;

/**
 * REST API controller for Azure DevOps integration
 */
@RestController
@RequestMapping("/api/ado")
public class ADOController {

    private final ADOConnectionService connectionService;
    private final ADOTestPlanService testPlanService;
    private final ADOTestResultService testResultService;
    private final ADOWorkItemService workItemService;
    private final ADOPipelineService pipelineService;
    private final ReportingService reportingService;

    @Autowired
    public ADOController(
        ADOConnectionService connectionService,
        ADOTestPlanService testPlanService,
        ADOTestResultService testResultService,
        ADOWorkItemService workItemService,
        ADOPipelineService pipelineService,
        ReportingService reportingService
    ) {
        this.connectionService = connectionService;
        this.testPlanService = testPlanService;
        this.testResultService = testResultService;
        this.workItemService = workItemService;
        this.pipelineService = pipelineService;
        this.reportingService = reportingService;
    }

    //
    // Connection management endpoints
    //

    @GetMapping("/connections")
    public List<ADOConnection> getConnections() {
        return connectionService.getConnections();
    }

    @GetMapping("/connections/{id}")
    public ADOConnection getConnection(@PathVariable String id) {
        return connectionService.getConnection(id);
    }

    @PostMapping("/connections")
    public ResponseEntity<ADOConnection> createConnection(@RequestBody ADOConnection connection) {
        try {
            ADOConnection created = connectionService.createConnection(connection);
            return ResponseEntity.ok(created);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PutMapping("/connections/{id}")
    public ResponseEntity<ADOConnection> updateConnection(
        @PathVariable String id,
        @RequestBody ADOConnection connection
    ) {
        try {
            ADOConnection updated = connectionService.updateConnection(id, connection);
            return ResponseEntity.ok(updated);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @DeleteMapping("/connections/{id}")
    public ResponseEntity<Void> deleteConnection(@PathVariable String id) {
        try {
            connectionService.deleteConnection(id);
            return ResponseEntity.ok().build();
        } catch (IOException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    @PostMapping("/connections/{id}/test")
    public ResponseEntity<Boolean> testConnection(@PathVariable String id) {
        ADOConnection connection = connectionService.getConnection(id);
        if (connection == null) {
            return ResponseEntity.notFound().build();
        }
        
        boolean isValid = connectionService.testConnection(connection);
        return ResponseEntity.ok(isValid);
    }

    @GetMapping("/connections/{id}/projects")
    public ResponseEntity<List<Map<String, Object>>> getProjects(@PathVariable String id) {
        try {
            List<Map<String, Object>> projects = connectionService.getProjects(id);
            return ResponseEntity.ok(projects);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @GetMapping("/connections/{id}/teams")
    public ResponseEntity<List<Map<String, Object>>> getTeams(
        @PathVariable String id,
        @RequestParam String projectName
    ) {
        try {
            List<Map<String, Object>> teams = connectionService.getTeams(id, projectName);
            return ResponseEntity.ok(teams);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    //
    // Test Plan management endpoints
    //

    @GetMapping("/connections/{id}/testplans")
    public ResponseEntity<List<ADOTestPlan>> getTestPlans(@PathVariable String id) {
        try {
            List<ADOTestPlan> testPlans = testPlanService.getTestPlans(id);
            return ResponseEntity.ok(testPlans);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @GetMapping("/connections/{id}/testplans/{planId}")
    public ResponseEntity<ADOTestPlan> getTestPlan(
        @PathVariable String id,
        @PathVariable int planId
    ) {
        try {
            ADOTestPlan testPlan = testPlanService.getTestPlan(id, planId);
            return ResponseEntity.ok(testPlan);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @GetMapping("/connections/{id}/testplans/{planId}/suites")
    public ResponseEntity<List<ADOTestSuite>> getTestSuites(
        @PathVariable String id,
        @PathVariable int planId
    ) {
        try {
            List<ADOTestSuite> testSuites = testPlanService.getTestSuites(id, planId);
            return ResponseEntity.ok(testSuites);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @GetMapping("/connections/{id}/testplans/{planId}/suites/{suiteId}/testcases")
    public ResponseEntity<List<ADOTestCase>> getTestCases(
        @PathVariable String id,
        @PathVariable int planId,
        @PathVariable int suiteId
    ) {
        try {
            List<ADOTestCase> testCases = testPlanService.getTestCases(id, planId, suiteId);
            return ResponseEntity.ok(testCases);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PostMapping("/connections/{id}/testplans/{planId}/suites/{suiteId}/import")
    public ResponseEntity<List<TestCase>> importTestCases(
        @PathVariable String id,
        @PathVariable int planId,
        @PathVariable int suiteId,
        @RequestParam String projectId
    ) {
        try {
            List<TestCase> importedTests = testPlanService.importTestCases(projectId, id, planId, suiteId);
            return ResponseEntity.ok(importedTests);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PostMapping("/connections/{id}/testcases")
    public ResponseEntity<ADOTestCase> createTestCase(
        @PathVariable String id,
        @RequestBody ADOTestCase testCase
    ) {
        try {
            ADOTestCase created = testPlanService.createTestCase(id, testCase);
            return ResponseEntity.ok(created);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @GetMapping("/testcases/{testCaseId}/mapping")
    public ResponseEntity<TestCaseMapping> getTestCaseMapping(@PathVariable String testCaseId) {
        TestCaseMapping mapping = testPlanService.getTestCaseMapping(testCaseId);
        if (mapping == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(mapping);
    }

    @PutMapping("/testcases/{testCaseId}/mapping")
    public ResponseEntity<TestCaseMapping> updateTestCaseMapping(
        @PathVariable String testCaseId,
        @RequestBody TestCaseMapping mapping
    ) {
        try {
            testPlanService.updateTestCaseMapping(mapping);
            return ResponseEntity.ok(mapping);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    //
    // Test Results endpoints
    //

    @PostMapping("/connections/{id}/testruns")
    public ResponseEntity<ADOTestRun> publishTestResults(
        @PathVariable String id,
        @RequestParam String executionId,
        @RequestParam(required = false) Integer testPlanId
    ) {
        try {
            // Get the test execution
            TestExecution execution = reportingService.getTestExecution(executionId);
            
            // Publish results
            ADOTestRun testRun = testResultService.publishTestResults(id, execution, testPlanId);
            return ResponseEntity.ok(testRun);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @GetMapping("/connections/{id}/testruns/{runId}")
    public ResponseEntity<ADOTestRun> getTestRun(
        @PathVariable String id,
        @PathVariable int runId
    ) {
        try {
            ADOTestRun testRun = testResultService.getTestRun(id, runId);
            return ResponseEntity.ok(testRun);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    //
    // Work Item endpoints
    //

    @PostMapping("/connections/{id}/workitems/bugs")
    public ResponseEntity<ADOWorkItem> createBugFromFailure(
        @PathVariable String id,
        @RequestParam String executionId,
        @RequestParam String testCaseId,
        @RequestParam String stepId,
        @RequestParam(required = false) String priority,
        @RequestParam(required = false) String assignedTo
    ) {
        try {
            // Get the test execution
            TestExecution execution = reportingService.getTestExecution(executionId);
            
            // Find the test case
            TestCase testCase = execution.getTestCases().stream()
                .filter(tc -> tc.getId().equals(testCaseId))
                .findFirst()
                .orElse(null);
            
            if (testCase == null) {
                return ResponseEntity.badRequest().body(null);
            }
            
            // Find the failed step
            TestStep failedStep = testCase.getSteps().stream()
                .filter(s -> s.getId().equals(stepId))
                .findFirst()
                .orElse(null);
            
            if (failedStep == null) {
                return ResponseEntity.badRequest().body(null);
            }
            
            // Create bug
            ADOWorkItem bug = workItemService.createBugFromFailure(
                id, testCase, failedStep, priority, assignedTo);
            return ResponseEntity.ok(bug);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @GetMapping("/connections/{id}/workitems/{workItemId}")
    public ResponseEntity<ADOWorkItem> getWorkItem(
        @PathVariable String id,
        @PathVariable int workItemId
    ) {
        try {
            ADOWorkItem workItem = workItemService.getWorkItem(id, workItemId);
            return ResponseEntity.ok(workItem);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PostMapping("/connections/{id}/workitems/search")
    public ResponseEntity<List<ADOWorkItem>> searchWorkItems(
        @PathVariable String id,
        @RequestParam String query,
        @RequestParam(defaultValue = "10") int maxResults
    ) {
        try {
            List<ADOWorkItem> workItems = workItemService.searchWorkItems(id, query, maxResults);
            return ResponseEntity.ok(workItems);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PutMapping("/connections/{id}/workitems/{workItemId}")
    public ResponseEntity<ADOWorkItem> updateWorkItem(
        @PathVariable String id,
        @PathVariable int workItemId,
        @RequestBody Map<String, Object> fields
    ) {
        try {
            ADOWorkItem workItem = workItemService.updateWorkItem(id, workItemId, fields);
            return ResponseEntity.ok(workItem);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    //
    // Pipeline endpoints
    //

    @GetMapping("/connections/{id}/pipelines")
    public ResponseEntity<List<ADOPipeline>> getPipelines(@PathVariable String id) {
        try {
            List<ADOPipeline> pipelines = pipelineService.getPipelines(id);
            return ResponseEntity.ok(pipelines);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @GetMapping("/connections/{id}/pipelines/{pipelineId}")
    public ResponseEntity<ADOPipeline> getPipeline(
        @PathVariable String id,
        @PathVariable int pipelineId
    ) {
        try {
            ADOPipeline pipeline = pipelineService.getPipeline(id, pipelineId);
            return ResponseEntity.ok(pipeline);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @GetMapping("/connections/{id}/pipelines/{pipelineId}/runs")
    public ResponseEntity<List<ADOPipelineRun>> getPipelineRuns(
        @PathVariable String id,
        @PathVariable int pipelineId,
        @RequestParam(defaultValue = "10") int top
    ) {
        try {
            List<ADOPipelineRun> runs = pipelineService.getPipelineRuns(id, pipelineId, top);
            return ResponseEntity.ok(runs);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @GetMapping("/connections/{id}/pipelines/{pipelineId}/runs/{runId}")
    public ResponseEntity<ADOPipelineRun> getPipelineRun(
        @PathVariable String id,
        @PathVariable int pipelineId,
        @PathVariable int runId
    ) {
        try {
            ADOPipelineRun run = pipelineService.getPipelineRun(id, pipelineId, runId);
            return ResponseEntity.ok(run);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PostMapping("/connections/{id}/pipelines/{pipelineId}/run")
    public ResponseEntity<ADOPipelineRun> runPipeline(
        @PathVariable String id,
        @PathVariable int pipelineId,
        @RequestBody(required = false) Map<String, String> variables
    ) {
        try {
            ADOPipelineRun run = pipelineService.runPipeline(id, pipelineId, variables);
            return ResponseEntity.ok(run);
        } catch (IOException e) {
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PostMapping("/connections/{id}/pipelines/results")
    public CompletableFuture<ResponseEntity<ADOTestRun>> publishTestResultsToPipeline(
        @PathVariable String id,
        @RequestParam String executionId,
        @RequestParam int buildId
    ) {
        return pipelineService.publishTestResultsToPipeline(id, executionId, buildId)
            .thenApply(ResponseEntity::ok)
            .exceptionally(e -> ResponseEntity.badRequest().body(null));
    }

    @PostMapping("/webhook")
    public ResponseEntity<Void> handleWebhook(@RequestBody Map<String, Object> eventData) {
        try {
            pipelineService.handleWebhookEvent(eventData);
            return ResponseEntity.ok().build();
        } catch (Exception e) {
            return ResponseEntity.badRequest().build();
        }
    }
}



    }
    
    public void setBrokenTests(int brokenTests) {
        this.brokenTests = brokenTests;
    }
    
    public int getSkippedTests() {
        return skippedTests;
    }
    
    public void setSkippedTests(int skippedTests) {
        this.skippedTests = skippedTests;
    }
}


